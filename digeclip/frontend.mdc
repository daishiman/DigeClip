---
description: 
globs: 
alwaysApply: false
---
# フロントエンド実装ガイドライン

## テスト

### APIクライアントのテスト

APIクライアントのテストでは、以下のポイントに注意して実装してください：

```typescript
// APIクライアントのテスト例
import { apiClient } from '../client';
import axios from 'axios';

// axiosをモック化
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('API Client', () => {
  beforeEach(() => {
    jest.resetAllMocks();
    // localStorageのモック
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn()
      },
      writable: true
    });
  });

  it('GETリクエストを正しく送信する', async () => {
    // モックレスポンスの設定
    mockedAxios.get.mockResolvedValueOnce({
      data: { id: 1, name: 'テスト' },
      status: 200,
      statusText: 'OK',
      headers: {},
      config: {}
    });

    // テスト対象の関数を実行
    const result = await apiClient.get('/test');

    // 期待する結果を検証
    expect(mockedAxios.get).toHaveBeenCalledWith('/test');
    expect(result).toEqual({ id: 1, name: 'テスト' });
  });

  it('認証トークンをヘッダーに追加する', async () => {
    // localStorageからトークンを取得するモック
    jest.spyOn(window.localStorage, 'getItem').mockReturnValueOnce('test-token');

    mockedAxios.get.mockResolvedValueOnce({
      data: {},
      status: 200,
      statusText: 'OK',
      headers: {},
      config: {}
    });

    await apiClient.get('/authenticated-endpoint');

    // 認証ヘッダーが正しく設定されていることを確認
    expect(mockedAxios.get).toHaveBeenCalledWith('/authenticated-endpoint');
    expect(window.localStorage.getItem).toHaveBeenCalledWith('auth-token');
  });

  it('エラーレスポンスを適切に処理する', async () => {
    // エラーレスポンスのモック
    const errorResponse = {
      response: {
        data: {
          error: {
            code: 'E400',
            message: 'バリデーションエラー'
          }
        },
        status: 400,
        statusText: 'Bad Request',
        headers: {},
        config: {}
      }
    };

    mockedAxios.get.mockRejectedValueOnce(errorResponse);

    // エラーがスローされることを確認
    await expect(apiClient.get('/error-endpoint')).rejects.toThrow('バリデーションエラー');
  });
});
```

### React Queryフックのテスト

React Queryフックのテストでは、以下のポイントに注意して実装してください：

```typescript
// React Queryフックのテスト例
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useContents } from '../hooks/useContents';
import { contentService } from '../services/contentService';

// サービスをモック化
jest.mock('../services/contentService');

describe('useContents Hook', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  beforeEach(() => {
    jest.resetAllMocks();
    queryClient.clear();
  });

  it('コンテンツリストを取得する', async () => {
    // モックデータ
    const mockContents = [
      { id: '1', title: 'コンテンツ1' },
      { id: '2', title: 'コンテンツ2' }
    ];

    // サービス関数のモック
    (contentService.getContents as jest.Mock).mockResolvedValueOnce({
      data: mockContents,
      meta: { total: 2 }
    });

    // フックをレンダリング
    const { result } = renderHook(() => useContents(), { wrapper });

    // 初期状態ではローディング中
    expect(result.current.isLoading).toBe(true);

    // データが取得されるまで待機
    await waitFor(() => expect(result.current.isLoading).toBe(false));

    // 取得したデータを検証
    expect(result.current.data).toEqual(mockContents);
    expect(contentService.getContents).toHaveBeenCalledTimes(1);
  });

  it('エラー時に適切に処理する', async () => {
    // エラーをモック
    (contentService.getContents as jest.Mock).mockRejectedValueOnce(
      new Error('データの取得に失敗しました')
    );

    // フックをレンダリング
    const { result } = renderHook(() => useContents(), { wrapper });

    // エラー状態になるまで待機
    await waitFor(() => expect(result.current.isError).toBe(true));

    // エラーメッセージを検証
    expect(result.current.error).toBeDefined();
    expect(result.current.error.message).toBe('データの取得に失敗しました');
  });

  it('データを再取得できる', async () => {
    // 初回データ取得のモック
    (contentService.getContents as jest.Mock).mockResolvedValueOnce({
      data: [{ id: '1', title: 'コンテンツ1' }],
      meta: { total: 1 }
    });

    // フックをレンダリング
    const { result } = renderHook(() => useContents(), { wrapper });

    // データが取得されるまで待機
    await waitFor(() => expect(result.current.isLoading).toBe(false));

    // 再取得用のモック
    (contentService.getContents as jest.Mock).mockResolvedValueOnce({
      data: [{ id: '1', title: '更新されたコンテンツ' }],
      meta: { total: 1 }
    });

    // データを再取得
    result.current.refetch();

    // 再取得が完了するまで待機
    await waitFor(() => expect(result.current.isFetching).toBe(false));

    // 更新されたデータを検証
    expect(result.current.data[0].title).toBe('更新されたコンテンツ');
    expect(contentService.getContents).toHaveBeenCalledTimes(2);
  });
});
```

### コンポーネントのテスト

UIコンポーネントのテストでは、以下のポイントに注意して実装してください：

```typescript
// コンポーネントのテスト例
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ContentList } from '../components/ContentList';
import { useContents } from '../hooks/useContents';

// フックをモック化
jest.mock('../hooks/useContents');

describe('ContentList Component', () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  it('コンテンツリストを表示する', () => {
    // モックデータ
    const mockContents = [
      { id: '1', title: 'コンテンツ1', summary: '要約1' },
      { id: '2', title: 'コンテンツ2', summary: '要約2' }
    ];

    // フックのモック
    (useContents as jest.Mock).mockReturnValue({
      data: mockContents,
      isLoading: false,
      isError: false,
      error: null,
      refetch: jest.fn()
    });

    // コンポーネントをレンダリング
    render(<ContentList />);

    // コンテンツが表示されていることを確認
    expect(screen.getByText('コンテンツ1')).toBeInTheDocument();
    expect(screen.getByText('コンテンツ2')).toBeInTheDocument();
    expect(screen.getByText('要約1')).toBeInTheDocument();
    expect(screen.getByText('要約2')).toBeInTheDocument();
  });

  it('ローディング中の表示を確認する', () => {
    // ローディング状態のモック
    (useContents as jest.Mock).mockReturnValue({
      data: [],
      isLoading: true,
      isError: false,
      error: null,
      refetch: jest.fn()
    });

    // コンポーネントをレンダリング
    render(<ContentList />);

    // ローディング表示を確認
    expect(screen.getByText('読み込み中...')).toBeInTheDocument();
  });

  it('エラー時の表示を確認する', () => {
    // エラー状態のモック
    (useContents as jest.Mock).mockReturnValue({
      data: [],
      isLoading: false,
      isError: true,
      error: new Error('データの取得に失敗しました'),
      refetch: jest.fn()
    });

    // コンポーネントをレンダリング
    render(<ContentList />);

    // エラー表示を確認
    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();
    expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();
  });

  it('再取得ボタンをクリックできる', async () => {
    // モックの設定
    const refetchMock = jest.fn();
    (useContents as jest.Mock).mockReturnValue({
      data: [],
      isLoading: false,
      isError: true,
      error: new Error('データの取得に失敗しました'),
      refetch: refetchMock
    });

    // コンポーネントをレンダリング
    render(<ContentList />);

    // 再取得ボタンをクリック
    const retryButton = screen.getByText('再試行');
    await userEvent.click(retryButton);

    // refetch関数が呼ばれたことを確認
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
});
```

### テストカバレッジの目標

フロントエンドのテストカバレッジは以下の目標を設定してください：

1. **APIクライアント**: 90%以上のカバレッジ
   - すべてのHTTPメソッド（GET, POST, PUT, DELETE）
   - 認証トークンの処理
   - エラーハンドリング

2. **サービスレイヤー**: 80%以上のカバレッジ
   - 主要なビジネスロジック
   - データ変換処理
   - エラー処理

3. **React Queryフック**: 80%以上のカバレッジ
   - データ取得
   - キャッシュ操作
   - エラー状態

4. **UIコンポーネント**: 70%以上のカバレッジ
   - 主要なユーザーインタラクション
   - 条件付きレンダリング
   - エラー状態の表示

### テスト実行のベストプラクティス

1. **継続的インテグレーション**:
   - プルリクエスト時に自動的にテストを実行
   - カバレッジレポートを生成して確認

2. **テストの分類**:
   - 単体テスト: 個々の関数やコンポーネント
   - 統合テスト: 複数のコンポーネントやサービスの連携
   - E2Eテスト: ユーザーフローの検証

3. **テストデータ**:
   - テストごとにモックデータを用意
   - テストデータは実際のデータ構造に近いものを使用
   - 境界値や特殊なケースも考慮

4. **テストの独立性**:
   - 各テストは独立して実行できるようにする
   - テスト間で状態を共有しない
   - beforeEach/afterEachでテスト環境をリセット