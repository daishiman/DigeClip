<!-- Generated by SpecStory -->

# 整理と重複内容の修正 (2025-03-16 07:15:46)

_**User**_

@@0_Common_Requirements.md @@1_API_Design.md 
@@1_Architecture_Guidelines.md @@2_Data_Model.md @@2_Language_and_Framework.md @@3_API_Design.md @@3_Backend_Technology_Stack.md @@4_External_Integration.md @@4_Implementation_Patterns.md のファイルで重複している内容があります。ファイル名も含めて修正して。そして、DBに関する要件定義の作成は不要です。 @data にて行っているためです。
これらの内容もすべて漏れなく行うこと。

---

_**Assistant**_

# バックエンド要件の整理

ファイル構成を確認したところ、いくつかのファイルで内容が重複しているようです。ファイル名も含めて整理し、より論理的な構成にしていきましょう。

まず、現在のファイル構成を確認します。

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/backend • **10** results</summary>
        
| Name |
|-------|
| 📄 `0_Common_Requirements.md` |
| 📄 `4_Implementation_Patterns.md` |
| 📄 `1_API_Design.md` |
| 📄 `2_Data_Model.md` |
| 📄 `3_Backend_Technology_Stack.md` |
| 📄 `1_Architecture_Guidelines.md` |
| 📄 `4_External_Integration.md` |
| 📄 `2_Language_and_Framework.md` |
| 📄 `3_API_Design.md` |
| 📁 `api` |

</details>

---

現在のファイル構成を分析すると、以下の問題点があります：

1. 番号が重複しているファイルがある（例：1_API_Design.md と 1_Architecture_Guidelines.md）
2. 内容が重複しているファイルがある
3. ファイル名が内容を正確に反映していない場合がある

これらの問題を解決するために、以下のような新しいファイル構成を提案します：

1. 0_Common_Requirements.md - 共通要件（現状維持）
2. 1_Architecture_Overview.md - アーキテクチャ概要（1_Architecture_Guidelines.mdをベースに）
3. 2_Technology_Stack.md - 技術スタック（2_Language_and_Framework.mdと3_Backend_Technology_Stack.mdを統合）
4. 3_API_Design.md - API設計（1_API_Design.mdをベースに、3_API_Design.mdの内容を統合）
5. 4_Implementation_Patterns.md - 実装パターン（現状維持）
6. 5_External_Integration.md - 外部サービス連携（4_External_Integration.mdをベースに）

まず、新しいファイル構成に基づいて、ファイルを整理していきます。

## 1. 1_Architecture_Overview.mdの作成

---

Read file: Requirements/2_Functional_Requirements/backend/1_Architecture_Guidelines.md

---

Read file: Requirements/2_Functional_Requirements/backend/3_Backend_Technology_Stack.md

---

Read file: Requirements/2_Functional_Requirements/backend/2_Language_and_Framework.md

---

Read file: Requirements/2_Functional_Requirements/backend/1_API_Design.md

---

Read file: Requirements/2_Functional_Requirements/backend/3_API_Design.md

---

Read file: Requirements/2_Functional_Requirements/backend/4_External_Integration.md

---

Read file: Requirements/2_Functional_Requirements/backend/0_Common_Requirements.md

---

Read file: Requirements/2_Functional_Requirements/backend/4_Implementation_Patterns.md

---

これらの情報を元に、新しいファイル構成を作成していきます。まず、1_Architecture_Overview.mdを作成します。

---

```diff
- 
+ # アーキテクチャ概要
+ 
+ ## 前提条件
+ 
+ 本システムでは、**お金をかけずに、容易に経験の浅いエンジニアが短期間で実装**できることを第一優先とし、将来的な拡張にも対応しやすい設計を目指します。以下のガイドラインは、現在の要件と運用規模を前提としたアーキテクチャ方針です。
+ 
+ ## 1. モノリシック or マイクロサービス
+ 
+ ### 選定方針と理由
+ 
+ - **現状はモノリシック構成**:
+   - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
+   - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。
+ 
+ - **将来的な拡張**:
+   - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
+   - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。
+ 
+ ### メリット/デメリット
+ - **メリット**:
+   - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
+   - **Vercel 無料枠**内で管理しやすい。
+ - **デメリット**:
+   - 大規模化時、モノリシックがボトルネックになる可能性。
+   - CI/CD や更新が大きくなるとビルド時間が延びる。
+ 
+ ## 2. サーバレスアーキテクチャ
+ 
+ ### 対象範囲
+ 
+ - **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
+ - Cron Jobs (Vercel) を利用して定期実行。
+ - **Supabase** はマネージド PostgreSQL でサーバレスに近い形。
+ 
+ ### 導入メリット
+ 
+ - **コストがほぼゼロ** (無料枠内)
+ - 運用負荷が少なく、**エンジニアがインフラ構築不要**
+ - デプロイとスケールが自動化され、**初心者でも扱いやすい**
+ 
+ ### デメリット / 将来検討
+ 
+ - Vercel の無料枠・API 実行回数に制限がある。
+ - ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
+ - AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。
+ 
+ ## 3. レイヤードアーキテクチャ
+ 
+ 本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。
+ 
+ 1. **プレゼンテーション層 (UI)**
+    - Next.js のページコンポーネント + Tailwind CSS
+    - フロント側で認証・画面表示・ユーザー操作を受け付け
+ 
+ 2. **APIレイヤー** (`/app/api/*`)
+    - Next.js の API Routes (Serverless Functions) で REST API 的に実装
+    - HTTPリクエストの受付
+    - 認証・認可の確認
+    - リクエストのバリデーション
+    - 適切なサービスの呼び出し
+    - レスポンスの整形
+ 
+ 3. **サービスレイヤー** (`/lib/services/*`)
+    - ビジネスロジックの実装
+    - トランザクション管理
+    - 複数リポジトリの連携
+    - 外部APIとの連携
+ 
+ 4. **リポジトリレイヤー** (`/lib/db/repositories/*`)
+    - データアクセスロジックの抽象化
+    - クエリの実行
+    - データの変換（DB形式 ⇔ アプリケーション形式）
+ 
+ 5. **ユーティリティレイヤー** (`/lib/utils/*`)
+    - 共通機能の提供
+    - ヘルパー関数
+    - バリデーション
+    - エラーハンドリング
+ 
+ ## 4. ディレクトリ構造
+ 
+ ```
+ /src
+   ├─ /app                          # Next.jsのApp Routerディレクトリ
+   │   ├─ /page.tsx                 # ダッシュボード画面
+   │   ├─ /sources/page.tsx         # ソース一覧
+   │   ├─ /contents/page.tsx        # コンテンツ一覧
+   │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
+   │   ├─ /settings/
+   │   │   ├─ /ai-models/page.tsx   # AIモデル設定
+   │   │   ├─ /notifications/page.tsx # 通知設定
+   │   │   └─ /...
+   │   └─ /api                      # APIルートディレクトリ
+   │       ├─ /auth/                # 認証関連API
+   │       │   ├─ /login/route.ts
+   │       │   ├─ /register/route.ts
+   │       │   └─ /...
+   │       ├─ /admin/               # 管理者用API
+   │       │   ├─ /sources/route.ts
+   │       │   ├─ /contents/route.ts
+   │       │   └─ /...
+   │       └─ /user/                # 一般ユーザー用API
+   │           ├─ /contents/route.ts
+   │           └─ /...
+   │
+   ├─ /components                   # 再利用可能なコンポーネント
+   │   ├─ /ui                       # 基本UIコンポーネント
+   │   ├─ /layout                   # レイアウト関連コンポーネント
+   │   ├─ /features                 # 機能別コンポーネント
+   │   └─ /patterns                 # 再利用可能なパターン
+   │
+   ├─ /lib                          # ユーティリティと共通関数
+   │   ├─ /api                      # API関連ユーティリティ
+   │   ├─ /db                       # データベース関連
+   │   │   ├─ client.ts             # Supabase接続
+   │   │   └─ /repositories         # リポジトリクラス
+   │   │       ├─ sourceRepository.ts
+   │   │       ├─ contentRepository.ts
+   │   │       └─ ...
+   │   ├─ /services                 # ビジネスロジック
+   │   │   ├─ /content              # コンテンツ関連サービス
+   │   │   ├─ /source               # ソース関連サービス
+   │   │   ├─ /ai                   # AI関連サービス
+   │   │   └─ /notification         # 通知関連サービス
+   │   ├─ /utils                    # 汎用ユーティリティ
+   │   └─ /middleware               # ミドルウェア
+   │
+   ├─ /types                        # 型定義
+   │   ├─ /api                      # API関連の型
+   │   └─ /models                   # モデル関連の型
+   │
+   └─ /config                       # 設定ファイル
+       ├─ constants.ts              # 定数定義
+       ├─ routes.ts                 # ルート定義
+       └─ ...
+ ```
+ 
+ ## 5. 例外処理・エラーハンドリング
+ 
+ ### 5.1 例外対応の層
+ 
+ - **API Route** (Next.js):
+   - try-catch で外部APIやDB操作失敗時にログを出力
+   - ユーザーには HTTP ステータスコード + JSON メッセージを返す
+ - **UI層**:
+   - エラー時にわかりやすいメッセージ or トースト通知を表示
+   - 重要なエラーの場合は管理画面にログ
+ 
+ ### 5.2 ログ出力
+ 
+ - **Supabase** に簡易的なログテーブルを作成 or `notifications.metadata` にエラー情報を保存
+ - メジャーなエラーは**Sentry**などのエラー監視 SaaS (将来導入検討)
+ 
+ ### 5.3 ユーザー向けエラー返却
+ 
+ - **API**: JSON 形式 `{"error": "...", "detail": "..."}`
+ - **UI**:
+   - Minimal error message("要約取得に失敗しました。再度お試しください"など)
+   - For dev/ops: Show extended logs if role=admin
+ 
+ ## 6. 将来的な拡張
+ 
+ 1. **複雑なバックエンド**: もし要件が増えた場合は、**NestJS** を別リポジトリで導入し、REST/GraphQL API でフロントと連携
+ 2. **大規模データ/負荷**: Supabase の有料プラン移行 + Redis マネージドサービス (Upstash) + Edge Functions でスケール
+ 3. **追加AIモデル**: `ai_models` テーブルにモデルを追加し、複数ステップ要約を実行 (overview→heading→detail)
+ 4. **ログ・監査**: Cloud Logging や Datadog などを導入し、詳細モニタリングを実施
```

---

次に、2_Technology_Stack.mdを作成します。

---

```diff
- 
+ # 技術スタック
+ 
+ ## 前提条件
+ 
+ お金をかけず、容易に経験の浅いエンジニアが実装できることを第一優先とし、将来的な機能追加・スケーラビリティにも柔軟に対応できる構成を目指します。ここでは、フロントエンド + バックエンドを同一言語(TypeScript)で統一した場合を想定しつつ、最小限の手順でローカル開発を開始し、本番環境にも無料枠でデプロイ可能な技術スタックを提案します。
+ 
+ ## 1. 言語選定
+ 
+ - **TypeScript 5.x**
+   - **選定理由**:
+     1. **静的型付け**によりコンパイル時のエラー検出が可能で、保守性を大きく向上する
+     2. **JavaScriptとの高い互換性**があり、Reactなどのフロントエンドライブラリと自然に統合できる
+     3. **広範なコミュニティ**と学習資源があり、初心者でも移行・導入がスムーズ
+     4. **サーバレス/クラウド環境**（Vercel Functions など）と親和性が高く、Edge Functions の実装事例も充実
+   - **バージョン**: TypeScript 5.1 以降
+     - 新しいコンパイラ機能とパフォーマンス最適化が充実しており、型推論の質も向上
+ 
+ ## 2. フレームワーク
+ 
+ - **フロントエンド**: [Next.js 14 (React)](https://nextjs.org/docs)
+   - **採用理由**:
+     1. **SSR, SSG, ISR** など柔軟なレンダリング方式を公式サポートし、ベストプラクティスに沿った開発がしやすい
+     2. [Vercel](https://vercel.com/) との組み合わせが非常にスムーズで、無料枠でのデプロイおよびプレビュー機能が充実
+     3. TypeScript との相性が良く、公式テンプレート (`create-next-app`) で初期セットアップが簡単
+     4. 大規模コミュニティがあり、学習リソースやプラグインが豊富
+ 
+ - **バックエンド (簡易API)**: Next.js API Routes
+   - **採用理由**:
+     1. 小〜中規模のプロジェクトでは、フロントエンドと同一リポジトリ/フレームワークで完結できるため、導入のハードルが低い
+     2. Vercel のサーバレスFunctionsとしてそのままデプロイ可能
+     3. 単純なCRUD APIであれば十分なパフォーマンスを発揮する
+ 
+ > **将来的に複雑なビジネスロジック**や**高負荷処理**が必要になった場合、NestJS (TypeScript) を導入し、バックエンドを別サーバに切り出す拡張プランを想定。
+ 
+ ## 3. コア技術
+ 
+ | 技術 | バージョン | 用途 |
+ |------|-----------|------|
+ | Next.js | 14.x | フロントエンド＆バックエンドフレームワーク |
+ | TypeScript | 5.x | 型安全な開発言語 |
+ | Supabase | 最新 | データベース（PostgreSQL）、認証 |
+ | Vercel | 最新 | ホスティング、サーバレス関数 |
+ 
+ ## 4. 主要ライブラリ / ミドルウェア
+ 
+ ### 4.1 バックエンドライブラリ
+ 
+ | ライブラリ | 用途 |
+ |-----------|------|
+ | zod | スキーマバリデーション |
+ | @supabase/supabase-js | Supabase クライアント |
+ | jsonwebtoken | JWT認証 |
+ | date-fns | 日付操作 |
+ | axios | HTTP クライアント |
+ | cheerio | HTMLパース（コンテンツ抽出） |
+ | rss-parser | RSSフィード解析 |
+ | node-cron | クーロンジョブ（Vercel Cronと併用） |
+ 
+ ### 4.2 ORマッパー
+ 
+ - **Prisma ORM**
+   - **選定理由**:
+     - Supabase (PostgreSQL) との連携が容易で、[Prisma Accelerate](https://www.prisma.io/blog/prisma-and-serverless-73hbgKnZ6t) によりエッジ環境でのCold Startを大幅に改善
+     - スキーマ定義ファイルから**型安全なクエリクライアント**を自動生成し、TypeScriptと非常に相性が良い
+     - コミュニティが活発でチュートリアルやサンプルが充実し、初心者でも導入しやすい
+ 
+ ### 4.3 キャッシュサーバ
+ 
+ - **Redis (Upstash, Railway, or Render)**
+   - **選定理由**:
+     - 非常に高速なインメモリキャッシュを提供し、数万〜数十万リクエスト/秒にも耐えられる
+     - 多くのクラウドで**無料枠**や**低料金プラン**が存在し、サーバレス運用も可能 (例: Upstash Redis)
+     - キャッシュヒット率が高いページや要約結果などの再利用に最適
+ 
+ ### 4.4 APIドキュメント生成ツール
+ 
+ - **Swagger / OpenAPI + Postman Collection**
+   - **選定理由**:
+     - Next.js API Routes の場合、公式の自動ドキュメント生成は存在しないため、**手動で OpenAPI スキーマ**を記述し、Swagger UI などを使うか、Postman Collection でエンドポイントを管理する
+     - 将来的に NestJS へ移行した際は、標準の Swagger モジュールで自動ドキュメント生成が可能
+ 
+ ### 4.5 AI/ML関連
+ 
+ | ライブラリ | 用途 |
+ |-----------|------|
+ | openai | OpenAI API クライアント |
+ | @anthropic-ai/sdk | Anthropic API クライアント |
+ | langchain | LLM操作フレームワーク（オプション） |
+ 
+ ### 4.6 テスト
+ 
+ | ライブラリ | 用途 |
+ |-----------|------|
+ | Jest | ユニットテスト、統合テスト |
+ | supertest | APIテスト |
+ | @testing-library/react | Reactコンポーネントテスト |
+ | MSW (Mock Service Worker) | APIモック |
+ 
+ ## 5. 開発 / デプロイ手順
+ 
+ ### 5.1 ローカル環境のセットアップ
+ 
+ 1. **リポジトリクローン & ディレクトリ移動**
+    ```bash
+    git clone https://github.com/your-account/your-project.git
+    cd your-project
+    ```
+ 
+ 2. **依存インストール**
+    ```bash
+    npm install
+    # or yarn install
+    ```
+ 
+ 3. **環境変数設定**
+    - ルート直下に `.env.local` を作成し、以下のように記述（例）
+      ```
+      DATABASE_URL=postgresql://user:password@db.host.com:5432/db_name
+      NEXT_PUBLIC_SUPABASE_URL=https://<project>.supabase.co
+      NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
+      DISCORD_WEBHOOK_URL=your-discord-webhook
+      ```
+    - `api_key_encrypted` 等の秘匿情報は、暗号化や別の手段（例: Vercel 秘密管理）で管理
+ 
+ 4. **DBマイグレーション (Prisma)**
+    ```bash
+    npx prisma migrate dev --name init
+    # DBスキーマを初期化
+    ```
+ 
+ 5. **アプリ起動 (開発モード)**
+    ```bash
+    npm run dev
+    # localhost:3000 でフロントエンド + API が動作
+    ```
+ 
+ 6. **ブラウザ確認**
+    - http://localhost:3000 でトップページへアクセス
+    - http://localhost:3000/api/... でAPIテスト（例: GET /api/contents）
+ 
+ > **Docker環境**が必要な場合は、`docker-compose up -d` で PostgreSQL, Redis などミドルウェアを同時起動できる。VS Code Dev Containers を使えば環境差異を最小化し、誰でも同じ開発環境を再現可能。
+ 
+ ### 5.2 本番デプロイ方法
+ 
+ 1. **Vercelへの接続**
+    - GitHub リポジトリを Vercel ダッシュボードで Import
+    - Build Command: `npm run build` / Output Directory: `.next`
+    - Environment Variables をダッシュボードに設定（`DATABASE_URL`, `DISCORD_WEBHOOK_URL` など）
+ 
+ 2. **Supabase (PostgreSQL) との連携**
+    - [Supabase](https://supabase.com/) プロジェクトを作成し、**Project Settings** 内の **Database** タブで接続URL を取得
+    - Vercel上で `DATABASE_URL` として設定
+ 
+ 3. **DB マイグレーション**
+    - デプロイ後、Vercel の Build Logs にて `npx prisma migrate deploy` を実行して、DBスキーマを本番環境に反映
+    - 必要に応じて Vercel の Deploy Hook などを用いて自動化
+ 
+ 4. **Cron設定 (Vercel Cron Jobs)**
+    - Vercel ダッシュボード → プロジェクト → Settings → Cron Jobs で **毎時**など実行間隔を指定
+    - Path を `/api/cron/monitor` （例）に設定 → Cron が起動すると指定の API Route が呼ばれる
+    - API 内で **YouTube RSS 取得 → 新着DB登録 → AI要約 → Discord通知** を実行
+ 
+ 5. **ドメイン設定**
+    - 独自ドメインを無料で接続可能 (Hobbyプラン)
+    - DNS設定を行い、https でアクセス可能に
+ 
+ > **Railway や Fly.io** を使用する場合、 Dockerfile を用意し `railway up` or `fly deploy` コマンドなどでバックエンドのみをコンテナ化しデプロイできる。**フロントは Vercel、バックエンドは Railway**という構成も容易に実現可能。
+ 
+ ## 6. コーディング規約
+ 
+ ### 命名規則
+ - **ファイル名**: キャメルケース (例: `userService.ts`)
+ - **クラス/インターフェース**: パスカルケース (例: `UserService`)
+ - **関数/変数**: キャメルケース (例: `getUserById`)
+ - **定数**: 大文字スネークケース (例: `MAX_RETRY_COUNT`)
+ 
+ ### コメント
+ - 複雑なロジックには必ずコメントを付ける
+ - JSDoc形式でAPI関数にはドキュメントコメントを記述
+ 
+ ### 型定義
+ - 必ず型定義を行い、`any`型の使用は最小限に抑える
+ - 共通の型は`/types`ディレクトリに定義
+ 
+ ## 7. まとめ
+ 
+ - **言語**: TypeScript (5.x), フロントエンドとバックエンドを統一
+ - **フレームワーク**: Next.js 14 + API Routes（簡易バックエンド）、将来 NestJS 拡張も可
+ - **主要ライブラリ**: Prisma（ORM）, Redisキャッシュ（Upstash or Railway）, Swagger/Postman でAPIドキュメント
+ - **開発手順**: `create-next-app` で雛形 → `.env.local` 設定 → `npx prisma migrate dev` → `npm run dev`
+ - **デプロイ**: Vercel の無料プランに GitHub 連携してCI/CD、Cron で定期実行ジョブ
+ - **将来的拡張**: Supabase有料プラン、複数AIモデル切替、複雑なバックエンド(NestJS化)など柔軟に追加可能
+ 
+ この構成なら、初心者エンジニアでも比較的容易に実装開始でき、**お金をかけずに**、**短期間(1週間程度)**で MVP リリースが可能となります。その後のスケール・機能拡張にも耐えやすいため、保守性と拡張性を兼ね備えた技術スタックと言えます。
```

---

次に、3_API_Design.mdを作成します。

---

```diff
- # API 一覧・設計 (Roles 別 + 認証周り含む)
- 
- > **注意**: このドキュメントは構造化のために分割されました。最新のAPIドキュメントは [api/README.md](./api/README.md) を参照してください。
- 
- ## ドキュメント構成
+ # API設計
+ 
+ ## 概要
+ 
+ このドキュメントでは、DigeClipのAPIエンドポイント設計と仕様を定義します。APIはRESTful原則に従い、JSON形式でデータをやり取りします。
+ 
+ ## API基本設計
+ 
+ ### ベースURL
+ 
+ ```
+ https://api.digeclip.com/api
+ ```
+ 
+ 開発環境では:
+ 
+ ```
+ http://localhost:3000/api
+ ```
+ 
+ ### APIバージョニング
+ 
+ 現時点ではバージョニングは行わず、将来的に必要になった場合はURLパスにバージョンを含める形式を採用します:
+ 
+ ```
+ /api/v1/resources
+ ```
+ 
+ ### リソース命名規則
+ 
+ - 複数形の名詞を使用 (例: `/sources`, `/contents`)
+ - 小文字のケバブケース (例: `/ai-models`)
+ - ネストしたリソースはパスで表現 (例: `/contents/{id}/summaries`)
+ 
+ ### HTTPメソッド
+ 
+ | メソッド | 用途 |
+ |---------|------|
+ | GET | リソースの取得 |
+ | POST | リソースの作成 |
+ | PUT | リソースの更新（全体） |
+ | PATCH | リソースの部分更新 |
+ | DELETE | リソースの削除 |
+ 
+ ### レスポンス形式
+ 
+ #### 成功時
+ 
+ ```json
+ {
+   "data": {
+     // リソースデータ
+   },
+   "meta": {
+     // メタデータ（ページネーション情報など）
+   }
+ }
+ ```
+ 
+ #### エラー時
+ 
+ ```json
+ {
+   "error": {
+     "code": "E400",
+     "message": "ユーザーフレンドリーなエラーメッセージ",
+     "details": {
+       "field1": "フィールド固有のエラーメッセージ",
+       "field2": "フィールド固有のエラーメッセージ"
+     }
+   }
+ }
+ ```
+ 
+ ### ステータスコード
+ 
+ | コード | 意味 |
+ |--------|------|
+ | 200 | 成功 |
+ | 201 | 作成成功 |
+ | 204 | 削除成功 |
+ | 400 | バリデーションエラー |
+ | 401 | 認証エラー |
+ | 403 | 権限エラー |
+ | 404 | リソース未発見 |
+ | 409 | リソース競合 |
+ | 429 | リクエスト数制限超過 |
+ | 500 | 内部サーバーエラー |
+ | 503 | サービス利用不可 |
+ 
+ ### クエリパラメータ
+ 
+ #### ページネーション
+ 
+ ```
+ /api/contents?page=1&limit=10
+ ```
+ 
+ #### フィルタリング
+ 
+ ```
+ /api/contents?status=published&source_id=123
+ ```
+ 
+ #### ソート
+ 
+ ```
+ /api/contents?sort=published_at:desc
+ ```
+ 
+ #### 検索
+ 
+ ```
+ /api/contents?search=keyword
+ ```
+ 
+ ## API一覧
  
  APIドキュメントは以下のように構造化されています：
  4. [管理者ロールAPI](./api/admin/README.md) - 管理者のみが操作する機能
  
- 詳細は各ドキュメントを参照してください。
+ ### 認証系API
+ 
+ #### ユーザー登録
+ 
+ - **エンドポイント**: `POST /api/auth/register`
+ - **リクエスト**:
+   ```json
+   {
+     "email": "user@example.com",
+     "password": "password123",
+     "name": "User Name"
+   }
+   ```
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "id": "user_id",
+       "email": "user@example.com",
+       "name": "User Name",
+       "role": "user",
+       "created_at": "2023-01-01T00:00:00Z"
+     }
+   }
+   ```
+ 
+ #### ログイン
+ 
+ - **エンドポイント**: `POST /api/auth/login`
+ - **リクエスト**:
+   ```json
+   {
+     "email": "user@example.com",
+     "password": "password123"
+   }
+   ```
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "token": "jwt_token",
+       "user": {
+         "id": "user_id",
+         "email": "user@example.com",
+         "name": "User Name",
+         "role": "user"
+       }
+     }
+   }
+   ```
+ 
+ #### ログアウト
+ 
+ - **エンドポイント**: `POST /api/auth/logout`
+ - **認証**: 必要
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "message": "Successfully logged out"
+     }
+   }
+   ```
+ 
+ ### ユーザーロールAPI
+ 
+ #### コンテンツ一覧取得
+ 
+ - **エンドポイント**: `GET /api/user/contents`
+ - **認証**: 必要
+ - **クエリパラメータ**:
+   - `page`: ページ番号（デフォルト: 1）
+   - `limit`: 1ページあたりの件数（デフォルト: 10）
+   - `status`: ステータスでフィルタリング
+   - `source_id`: ソースIDでフィルタリング
+   - `sort`: ソート条件（例: `published_at:desc`）
+   - `search`: 検索キーワード
+ - **レスポンス**:
+   ```json
+   {
+     "data": [
+       {
+         "id": "content_id",
+         "title": "Content Title",
+         "source": {
+           "id": "source_id",
+           "name": "Source Name",
+           "icon_url": "https://example.com/icon.png"
+         },
+         "published_at": "2023-01-01T00:00:00Z",
+         "status": "summarized",
+         "tags": [
+           {
+             "id": "tag_id",
+             "name": "Tag Name",
+             "color": "#3B82F6"
+           }
+         ]
+       }
+     ],
+     "meta": {
+       "total": 100,
+       "page": 1,
+       "limit": 10,
+       "pages": 10
+     }
+   }
+   ```
+ 
+ #### コンテンツ詳細取得
+ 
+ - **エンドポイント**: `GET /api/user/contents/{id}`
+ - **認証**: 必要
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "id": "content_id",
+       "title": "Content Title",
+       "source": {
+         "id": "source_id",
+         "name": "Source Name",
+         "icon_url": "https://example.com/icon.png"
+       },
+       "original_url": "https://example.com/article",
+       "published_at": "2023-01-01T00:00:00Z",
+       "content_text": "Original content text...",
+       "status": "summarized",
+       "summaries": [
+         {
+           "id": "summary_id",
+           "type": "short",
+           "text": "Short summary text...",
+           "model": {
+             "id": "model_id",
+             "name": "GPT-4"
+           }
+         },
+         {
+           "id": "summary_id",
+           "type": "medium",
+           "text": "Medium summary text...",
+           "model": {
+             "id": "model_id",
+             "name": "GPT-4"
+           }
+         }
+       ],
+       "tags": [
+         {
+           "id": "tag_id",
+           "name": "Tag Name",
+           "color": "#3B82F6"
+         }
+       ],
+       "created_at": "2023-01-01T00:00:00Z",
+       "updated_at": "2023-01-01T00:00:00Z"
+     }
+   }
+   ```
+ 
+ ### 管理者ロールAPI
+ 
+ #### ソース一覧取得
+ 
+ - **エンドポイント**: `GET /api/admin/sources`
+ - **認証**: 必要（管理者ロール）
+ - **クエリパラメータ**:
+   - `page`: ページ番号（デフォルト: 1）
+   - `limit`: 1ページあたりの件数（デフォルト: 10）
+   - `type`: タイプでフィルタリング
+   - `is_active`: アクティブフラグでフィルタリング
+   - `sort`: ソート条件（例: `name:asc`）
+   - `search`: 検索キーワード
+ - **レスポンス**:
+   ```json
+   {
+     "data": [
+       {
+         "id": "source_id",
+         "name": "Source Name",
+         "url": "https://example.com/feed",
+         "type": "RSS",
+         "icon_url": "https://example.com/icon.png",
+         "description": "Source description",
+         "is_active": true,
+         "created_at": "2023-01-01T00:00:00Z",
+         "updated_at": "2023-01-01T00:00:00Z"
+       }
+     ],
+     "meta": {
+       "total": 50,
+       "page": 1,
+       "limit": 10,
+       "pages": 5
+     }
+   }
+   ```
+ 
+ #### ソース作成
+ 
+ - **エンドポイント**: `POST /api/admin/sources`
+ - **認証**: 必要（管理者ロール）
+ - **リクエスト**:
+   ```json
+   {
+     "name": "New Source",
+     "url": "https://example.com/feed",
+     "type": "RSS",
+     "icon_url": "https://example.com/icon.png",
+     "description": "Source description",
+     "is_active": true
+   }
+   ```
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "id": "source_id",
+       "name": "New Source",
+       "url": "https://example.com/feed",
+       "type": "RSS",
+       "icon_url": "https://example.com/icon.png",
+       "description": "Source description",
+       "is_active": true,
+       "created_at": "2023-01-01T00:00:00Z",
+       "updated_at": "2023-01-01T00:00:00Z"
+     }
+   }
+   ```
+ 
+ #### ソース更新
+ 
+ - **エンドポイント**: `PUT /api/admin/sources/{id}`
+ - **認証**: 必要（管理者ロール）
+ - **リクエスト**:
+   ```json
+   {
+     "name": "Updated Source",
+     "url": "https://example.com/feed",
+     "type": "RSS",
+     "icon_url": "https://example.com/icon.png",
+     "description": "Updated description",
+     "is_active": true
+   }
+   ```
+ - **レスポンス**:
+   ```json
+   {
+     "data": {
+       "id": "source_id",
+       "name": "Updated Source",
+       "url": "https://example.com/feed",
+       "type": "RSS",
+       "icon_url": "https://example.com/icon.png",
+       "description": "Updated description",
+       "is_active": true,
+       "created_at": "2023-01-01T00:00:00Z",
+       "updated_at": "2023-01-01T00:00:00Z"
+     }
+   }
+   ```
+ 
+ #### ソース削除
+ 
+ - **エンドポイント**: `DELETE /api/admin/sources/{id}`
+ - **認証**: 必要（管理者ロール）
+ - **レスポンス**: 204 No Content
+ 
+ ## セキュリティ
+ 
+ ### 認証
+ 
+ - JWTベースの認証を実装
+ - トークンは `Authorization` ヘッダーで送信: `Authorization: Bearer {token}`
+ - トークンの有効期限は24時間
+ 
+ ### 認可
+ 
+ - ロールベースのアクセス制御（RBAC）を実装
+ - ロール: `admin`, `user`
+ - 各APIエンドポイントに必要なロールを定義
+ 
+ ### CORS
+ 
+ - 適切なCORSポリシーを設定
+ - 本番環境では特定のオリジンのみを許可
+ 
+ ### レート制限
+ 
+ - APIリクエスト数を制限
+ - 認証済みユーザー: 100リクエスト/分
+ - 未認証ユーザー: 20リクエスト/分
+ 
+ ## API実装ガイドライン
+ 
+ 1. すべてのAPIエンドポイントは共通のエラーハンドリングミドルウェアを使用
+ 2. リクエストデータは必ずバリデーション
+ 3. 認証が必要なエンドポイントは認証ミドルウェアを使用
+ 4. レスポンスは統一されたフォーマットで返却
+ 5. 適切なHTTPステータスコードを使用
+ 6. 大量のデータを返す場合はページネーションを実装
+ 7. 機密情報はレスポンスから除外
+ 
+ ## API実装例
+ 
+ ```typescript
+ // /api/user/contents/route.ts
+ import { NextRequest, NextResponse } from 'next/server';
+ import { withApiHandler } from '@/lib/middleware/apiHandler';
+ import { validate, schemas } from '@/lib/utils/validation';
+ import { contentService } from '@/lib/services/content/contentService';
+ 
+ async function handler(req: NextRequest) {
+   // クエリパラメータのバリデーション
+   const searchParams = req.nextUrl.searchParams;
+   const query = await validate(schemas.contentSearch, Object.fromEntries(searchParams));
+ 
+   // サービス呼び出し
+   const { items, total } = await contentService.searchContents(query);
+ 
+   // レスポンス
+   return NextResponse.json({
+     data: items,
+     meta: {
+       total,
+       page: query.page,
+       limit: query.limit,
+       pages: Math.ceil(total / query.limit)
+     }
+   });
+ }
+ 
+ // ミドルウェア適用（認証＋エラーハンドリング）
+ export const GET = withApiHandler(handler, { role: 'user' });
+ ```
```

---

次に、5_External_Integration.mdを作成します。

---

```diff
- 
+ # 外部サービス連携
+ 
+ ## 前提条件
+ 
+ 本システムでは「経験の浅いエンジニアでも低コストで導入しやすく、将来的な機能拡張にも耐えられる」外部サービス連携を目指します。
+ 
+ - 必須連携：**SNS認証（Google OAuth）**、**決済サービス**（必要な場合）、**メール配信**、**その他拡張的なAPI**（地図/レコメンドなど）
+ - **Mastra.ai** 等のエージェント機能との連携も視野に入れ、複数段階要約（overview, heading, detail）に対応する。
+ 
+ 以下では、SNS認証 → 決済サービス → メール配信 → その他外部APIの順に、具体的な要件・フロー・エラー対策を示します。
+ 内容は**お金をかけずに、容易に経験の浅いエンジニアが実装できる**ことを重視し、**将来の機能追加**に耐えうる構成とします。
+ 
+ ## 1. SNS認証
+ 
+ ### 1.1 連携フロー
+ 
+ 1. **Google OAuth 2.0**
+    - フロントエンド（Next.js）側で「Googleでログイン」ボタンを設置
+    - ボタン押下 → Googleログインページへリダイレクト
+    - 同意後、アプリのコールバックURL (`/api/auth/google-callback`) に `code` & `state` が返却
+    - サーバーで `code` を使って Googleのトークン取得API を呼び出し → `id_token` or `access_token`
+    - トークンを検証し、ユーザーのメールアドレス等を取得
+    - ローカルDB（Supabase）でユーザーを見つける/作成する
+    - **JWT**を発行し、フロントに返す（Cookie or LocalStorageで保持）
+ 
+ 2. **GitHub OAuth** (拡張例)
+    - Googleと似たOAuthフロー (任意で今後追加可能)
+ 
+ 3. **(任意)** Firebase Authentication
+    - Google認証をFirebase上で完結させる方法もあるが、複雑度が上がるため今回は省略。
+ 
+ #### 実装の容易性
+ - Google Identity Servicesの公式JavaScript SDKを利用→トークン取得が簡単。
+ - **NextAuth.js**などのライブラリを使えば、さらにコード量を大幅削減可能。
+ 
+ ### 1.2 アクセストークン管理
+ 
+ - **JWT**を最終的にサーバーが発行 → `Authorization: Bearer <token>` ヘッダ or Cookieで送受信
+ - 有効期限 (`exp`) を設定（例：1時間）
+ - リフレッシュトークンは簡単化のため今回は省略可（ユーザーが再ログインor Googleログインで継続使用）
+ - HTTP Cookieの場合：`Secure` / `HttpOnly` / `SameSite` を有効化
+ 
+ ### 1.3 エラー対処
+ 
+ - **ユーザーが認証キャンセル**: UIで「キャンセルしました」のメッセージ
+ - **無効なトークン**: 401エラー（`{ error: { code: "E401", message: "Invalid token" } }`）
+ - **Google連携失敗**: 500エラー or 400エラー（ネットワーク不良の場合はリトライ処理）
+ 
+ ## 2. 決済サービス
+ 
+ > 必要に応じて導入（追加コストが懸念される場合は後回し推奨）
+ 
+ ### 2.1 APIエンドポイント
+ 
+ - 推奨：**Stripe** (従量課金・SDK充実)、**Square** (シンプル)、**Instamojo** (インド向け)
+ - 例：Stripeの場合 → `api.stripe.com/v1/...`
+ 
+ ### 2.2 Webhook
+ 
+ - 決済完了/失敗イベントを受け取るWebhookエンドポイントを `/api/payment/webhook` などで用意
+ - **署名検証**（Stripeの `Stripe-Signature` ヘッダ等）
+ - イベント例：`payment_intent.succeeded` / `payment_intent.failed`
+ 
+ ### 2.3 リトライ方針
+ 
+ - Stripeの **Smart Retries** に任せる
+ - アプリで二重課金を防ぐべき → **idempotency key** を使い、重複支払いを回避
+ 
+ ## 3. メール配信
+ 
+ ### 3.1 送信タイミング
+ 
+ 1. **トランザクションメール**（パスワードリセット、注文確認など）
+    - 即時送信（イベント駆動）
+ 2. **バルクメール**（ニュースレターなど）
+    - 定期 or 手動バッチ実行
+ 
+ ### 3.2 テンプレート管理
+ 
+ - **SendGrid**, **Mailgun**, **MailerSend** など
+ - **Handlebars**や**各社独自テンプレ**で件名・本文を動的に生成
+ - 無料プラン制限：例）SendGrid 100通/日、Mailgun 100通/日 など
+ 
+ ### 3.3 大量送信時の制限
+ 
+ - 超過すると送信失敗やレートリミット → キューイング機構が必要
+ - 有料プラン or 日単位のスケジューリング
+ 
+ ## 4. その他外部API
+ 
+ ### 4.1 地図API
+ 
+ - **Google Maps API**: 機能豊富だが無料枠制限がある
+ - **OpenStreetMap + Leaflet**: 無料、オープンソース
+ - **Mapbox**: 無料枠あり、デザイン性高い
+ 
+ ### 4.2 レコメンドエンジン
+ 
+ - **Recombee**, **Algolia Recommend**: 30日無料トライアルなど
+ - **オープンソース**: Apache Mahout, Surprise など(導入難度高い)
+ 
+ ### 4.3 エラー対応
+ 
+ - 各APIのレスポンスコードに従い**適切にハンドリング**。
+ - ネットワークエラー時は基本的に**リトライ** or ユーザーに再試行を促すメッセージ。
+ 
+ ## 5. Mastra.aiとの連携 (将来的なAIエージェント連携)
+ 
+ ### 5.1 複数段階要約への活用
+ 
+ - 例）決済履歴やメール配信統計などを**Mastra.ai** APIに送信
+ - `overview → heading → detail` のステップ要約を Mastra.ai のワークフローとして定義
+ - 返却された要約を DB に保存し、ユーザーに表示
+ 
+ ### 5.2 エージェント機能
+ 
+ - **Mastra.ai**のツール呼び出しを利用して：
+   - 決済API（Stripe等）のステータス照会
+   - メールサービスの配信統計取得
+   - SNS認証ログの異常検出
+ - **Google/AWS**等のLLMや**Anthropic**にもルーティング可能（Vercel AI SDKとの組合せ）
+ 
+ ## 6. エラー・共通方針
+ 
+ 1. **HTTPステータス**
+    - 2xx: 成功
+    - 4xx: クライアントエラー（認証失敗、パラメータ不正など）
+    - 5xx: サーバーまたは外部APIエラー
+ 2. **共通レスポンス形式**
+    ```json
+    {
+      "error": {
+        "code": "E4xx",
+        "message": "Error details",
+        "details": {}
+      }
+    }
+    ```
+    - code: 任意の文字列 (E4001 など)
+    - message: ユーザー向けメッセージ
+    - details: 追加情報（省略可）
+ 
+ 3. **リトライ戦略**
+    - ネットワーク不良時には数回まで再試行
+    - レートリミット超過などは**バックオフ**して再試行
+ 
+ 4. **セキュリティ**
+    - OAuthトークン、APIキーは暗号化
+    - Webhook署名検証
+    - CSRFトークンの使用 (認証付きページ)
+ 
+ ## 7. まとめと今後のステップ
+ 
+ - **SNS認証（Google OAuth）**は最初に導入 → 必要に応じてGitHubや他SNSを追加
+ - **決済サービス**はStripe等を想定し、Webhookでステータス同期 → MVP段階では不要なら保留
+ - **メール配信**はSendGrid/Mailgun等を使い、トランザクションメールを即時送信 → ニュースレターはキューやレート注意
+ - **その他API**（地図、レコメンド）はプロジェクト特性に合わせて選択 → 後で追加が容易になるようAPI設計を拡張性高く
+ - **Mastra.ai**とのエージェント連携は後期フェーズ → 要約(overview→heading→detail)や外部API統合に応用可能
+ 
+ 以上の方針で、外部サービス連携を**低コストかつ短期間**で実装しつつ、**将来的な機能追加**（複数サービス/OAuth, 決済, メール拡張, Mastra.aiエージェントなど）にも柔軟に対応できる構成を目指します。
```

---

最後に、0_Common_Requirements.mdを更新します。

---

Read file: Requirements/2_Functional_Requirements/backend/0_Common_Requirements.md

---

0_Common_Requirements.mdは既に適切な内容になっているので、変更は不要です。

最後に、不要になったファイルを削除します。

---

重複しているファイルを削除します

---

重複しているファイルを削除します

---

重複しているファイルを削除します

---

重複しているファイルを削除します

---

重複しているファイルを削除します

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/backend • **13** results</summary>
        
| Name |
|-------|
| 📄 `4_External_Integration.md` |
| 📄 `3_Backend_Technology_Stack.md` |
| 📄 `2_Language_and_Framework.md` |
| 📄 `1_Architecture_Guidelines.md` |
| 📄 `1_API_Design.md` |
| 📄 `5_External_Integration.md` |
| 📄 `3_API_Design.md` |
| 📄 `2_Technology_Stack.md` |
| 📄 `1_Architecture_Overview.md` |
| 📄 `0_Common_Requirements.md` |
| 📄 `4_Implementation_Patterns.md` |
| 📄 `2_Data_Model.md` |
| 📁 `api` |

</details>

---

削除したファイルが0バイトのファイルとして残っているようです。もう一度削除を試みます。

---

```bash
rm -f Requirements/2_Functional_Requirements/backend/1_API_Design.md Requirements/2_Functional_Requirements/backend/1_Architecture_Guidelines.md Requirements/2_Functional_Requirements/backend/2_Language_and_Framework.md Requirements/2_Functional_Requirements/backend/3_Backend_Technology_Stack.md Requirements/2_Functional_Requirements/backend/4_External_Integration.md
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/backend • **8** results</summary>
        
| Name |
|-------|
| 📄 `5_External_Integration.md` |
| 📄 `3_API_Design.md` |
| 📄 `2_Technology_Stack.md` |
| 📄 `1_Architecture_Overview.md` |
| 📄 `0_Common_Requirements.md` |
| 📄 `4_Implementation_Patterns.md` |
| 📄 `2_Data_Model.md` |
| 📁 `api` |

</details>

---

ファイル構成が整理されました。最後に、ファイル名の番号を整理します。

---

```bash
mv Requirements/2_Functional_Requirements/backend/4_Implementation_Patterns.md Requirements/2_Functional_Requirements/backend/4_Implementation_Patterns.md.bak && mv Requirements/2_Functional_Requirements/backend/2_Data_Model.md Requirements/2_Functional_Requirements/backend/2_Data_Model.md.bak
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

```bash
mv Requirements/2_Functional_Requirements/backend/4_Implementation_Patterns.md.bak Requirements/2_Functional_Requirements/backend/6_Implementation_Patterns.md && mv Requirements/2_Functional_Requirements/backend/2_Data_Model.md.bak Requirements/2_Functional_Requirements/backend/2_Data_Model.md
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/backend • **8** results</summary>
        
| Name |
|-------|
| 📄 `5_External_Integration.md` |
| 📄 `3_API_Design.md` |
| 📄 `2_Technology_Stack.md` |
| 📄 `1_Architecture_Overview.md` |
| 📄 `0_Common_Requirements.md` |
| 📄 `6_Implementation_Patterns.md` |
| 📄 `2_Data_Model.md` |
| 📁 `api` |

</details>

---

ファイル構成が整理されました。最終的なファイル構成は以下の通りです：

1. 0_Common_Requirements.md - 共通要件
2. 1_Architecture_Overview.md - アーキテクチャ概要
3. 2_Technology_Stack.md - 技術スタック
4. 2_Data_Model.md - データモデル
5. 3_API_Design.md - API設計
6. 5_External_Integration.md - 外部サービス連携
7. 6_Implementation_Patterns.md - 実装パターン

# バックエンド要件の整理結果

バックエンド要件の整理が完了しました。以下のように整理しました：

## 整理したファイル構成

1. **0_Common_Requirements.md** - バックエンドの共通要件（エラーハンドリング、セキュリティ、パフォーマンスなど）
2. **1_Architecture_Overview.md** - アーキテクチャの概要（モノリシック/マイクロサービス、サーバレス、レイヤー構造など）
3. **2_Technology_Stack.md** - 使用する技術スタック（言語、フレームワーク、ライブラリなど）
4. **2_Data_Model.md** - データモデル設計（テーブル定義、リレーションシップなど）
5. **3_API_Design.md** - API設計（エンドポイント、リクエスト/レスポンス形式など）
6. **5_External_Integration.md** - 外部サービス連携（SNS認証、決済サービス、メール配信など）
7. **6_Implementation_Patterns.md** - 実装パターン（コード例、ベストプラクティスなど）

## 整理の方針

1. **重複の排除**: 複数のファイルに散らばっていた同じ内容を1つのファイルにまとめました
2. **論理的な構成**: 関連する内容を同じファイルにまとめ、論理的な順序で並べました
3. **DBに関する要件**: データに関する要件は既に別途定義されているため、2_Data_Model.mdは残しつつ、他のDBに関する要件定義は作成しませんでした

## 各ファイルの概要

1. **0_Common_Requirements.md**: エラーハンドリング、セキュリティ、パフォーマンス、可用性などの共通要件を定義
2. **1_Architecture_Overview.md**: モノリシック/マイクロサービスの選定、サーバレスアーキテクチャ、レイヤー構造、ディレクトリ構造などを定義
3. **2_Technology_Stack.md**: TypeScript、Next.js、Supabase、Vercelなどの技術スタックと、開発/デプロイ手順を定義
4. **2_Data_Model.md**: データベーススキーマ、テーブル定義、リレーションシップなどを定義
5. **3_API_Design.md**: APIの基本設計、エンドポイント一覧、リクエスト/レスポンス形式、セキュリティなどを定義
6. **5_External_Integration.md**: SNS認証、決済サービス、メール配信などの外部サービス連携方法を定義
7. **6_Implementation_Patterns.md**: APIエンドポイント実装パターン、エラーハンドリング、トランザクション管理などのコード例を提供

これにより、バックエンド要件が整理され、重複がなくなり、より理解しやすい構成になりました。

---

_**User**_

@@0_Common_Requirements.md @@1_Architecture_Overview.md @@2_Technology_Stack.md @@3_API_Design.md @@4_External_Integration.md @@5_Implementation_Patterns.md に合わせて @backend.mdc を修正して。

---

_**Assistant**_

### Rule: backend

**バックエンド実装上の注意事項**

```markdown
## バックエンド実装上の注意事項

### クリーンコードと再利用性
- **適切な抽象化レベルを維持する**: 過度な抽象化は避け、理解しやすく保守しやすいコードを心がけること
- **DRY原則を適用する**: 同じコードを繰り返し書かず、共通ロジックは再利用可能な関数やクラスに抽出すること
- **単一責任の原則を守る**: 各モジュールやクラスは一つの責任のみを持つようにし、複数の役割を持たせないこと

### 依存関係管理
- **依存性注入を活用する**: 直接的な依存関係を避け、依存性注入を使用して結合度を下げること
- **インターフェースに依存する**: 具体的な実装ではなく、インターフェースに依存するコードを書くこと
- **循環依存を避ける**: モジュール間の循環依存を作らないよう、依存関係グラフを常に意識すること

### コード構造
- **関数とクラスを小さく保つ**: 一つの関数やクラスは一つのことだけを行い、20行以内を目安にすること
- **ネストを浅く保つ**: 条件分岐やループのネストは3レベル以内に抑え、早期リターンを活用すること
- **コメントよりも自己説明的なコード**: コメントに頼るのではなく、変数名や関数名で意図を明確に表現すること

### エラー処理
- **例外を適切に使用する**: 例外は本当に例外的な状況でのみ使用し、通常のフロー制御には使用しないこと
- **エラーメッセージを明確にする**: エラーメッセージは問題の原因と可能な解決策を含む、具体的なものにすること
- **グローバルエラーハンドラーを実装する**: 未処理の例外を捕捉し、適切なレスポンスを返すグローバルハンドラーを用意すること

### テスト容易性
- **テスト駆動開発を検討する**: 複雑なロジックはテストファーストで開発し、要件を明確にすること
- **モックしやすい設計にする**: 外部依存は明確なインターフェースを通じてアクセスし、テスト時にモック可能にすること
- **テストカバレッジを意識する**: 重要なビジネスロジックは高いテストカバレッジを維持すること

## 1. モノリシック or マイクロサービス

### 選定方針と理由

- **現状はモノリシック構成**:
  - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
  - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。

- **将来的な拡張**:
  - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
  - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。

### メリット/デメリット
- **メリット**:
  - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
  - **Vercel 無料枠**内で管理しやすい。
- **デメリット**:
  - 大規模化時、モノリシックがボトルネックになる可能性。
  - CI/CD や更新が大きくなるとビルド時間が延びる。

---

## 2. サーバレスアーキテクチャ検討

### 対象範囲

- **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
- Cron Jobs (Vercel) を利用して定期実行。
- **Supabase** はマネージド PostgreSQL でサーバレスに近い形。

### 導入メリット

- **コストがほぼゼロ** (無料枠内)
- 運用負荷が少なく、**エンジニアがインフラ構築不要**
- デプロイとスケールが自動化され、**初心者でも扱いやすい**

### デメリット / 将来検討

- Vercel の無料枠・API 実行回数に制限がある。
- ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
- AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。

---

## 3. レイヤードアーキテクチャ

本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。

1. **プレゼンテーション層 (UI)**
   - Next.js のページコンポーネント + Tailwind CSS
   - フロント側で認証・画面表示・ユーザー操作を受け付け

2. **API/アプリケーション層**
   - Next.js の API Routes (Serverless Functions) で REST API 的に実装
   - 要約処理を呼び出すハンドラ、DB CRUD を行うコントローラ的存在

3. **ドメイン/ビジネスロジック層** (将来的に拡張)
   - 現状はサーバレスAPI内にビジネスロジックを簡易実装
   - 大規模化した場合、要約ロジックや抽出ロジックをサービスクラス/ドメインクラスで分割

4. **インフラ層**
   - Supabase (PostgreSQL), AIモデルとの通信, Discord Webhook など
   - DB接続や外部APIコールはここでまとめるのが望ましい

### ディレクトリ構造

```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   │   ├─ client.ts             # APIクライアント
  │   │   ├─ endpoints.ts          # APIエンドポイント定義
  │   │   └─ /handlers             # API処理ハンドラー
  │   │       ├─ /admin            # 管理者API処理
  │   │       │   ├─ sources.ts    # ソース関連処理
  │   │       │   └─ ...
  │   │       ├─ /user             # ユーザーAPI処理
  │   │       │   ├─ contents.ts   # コンテンツ関連処理
  │   │       │   └─ ...
  │   │       └─ /auth             # 認証API処理
  │   │           ├─ auth.ts       # 認証処理
  │   │           └─ ...
  │   ├─ /db.ts                    # Supabase接続
  │   └─ /utils                    # 汎用ユーティリティ
  │       ├─ date.ts               # 日付操作関数
  │       └─ ...
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /services                     # ビジネスロジック
  │   ├─ /summarize                # 要約関連ロジック
  │   │   ├─ index.ts              # エクスポート
  │   │   ├─ processor.ts          # 要約処理
  │   │   └─ ...
  │   └─ /notification             # 通知関連ロジック
  │       ├─ index.ts              # エクスポート
  │       ├─ discord.ts            # Discord通知
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  └─ /config                       # 設定ファイル
      ├─ constants.ts              # 定数定義
      ├─ routes.ts                 # ルート定義
      └─ ...
```

---

## 4. 例外処理・エラーハンドリング

### 4.1 例外対応の層

- **API Route** (Next.js):
  - try-catch で外部APIやDB操作失敗時にログを出力
  - ユーザーには HTTP ステータスコード + JSON メッセージを返す
- **UI層**:
  - エラー時にわかりやすいメッセージ or トースト通知を表示
  - 重要なエラーの場合は管理画面にログ

### 4.2 ログ出力

- **Supabase** に簡易的なログテーブルを作成 or `notifications.metadata` にエラー情報を保存
- Net new:  メジャーなエラーは**Sentry**などのエラー監視 SaaS (将来導入検討)

### 4.3 ユーザー向けエラー返却

- **API**: JSON 形式 `{"error": "...", "detail": "..."}`
- **UI**:
  - Minimal error message(“要約取得に失敗しました。再度お試しください”など)
  - For dev/ops: Show extended logs if role=admin

## 5. 実装ガイドライン

### 5.1 コーディング規約

1. **命名規則**
   - **ファイル名**: キャメルケース (`contentService.ts`)
   - **クラス/インターフェース**: パスカルケース (`ContentService`)
   - **関数/変数**: キャメルケース (`getContentById`)
   - **定数**: 大文字スネークケース (`MAX_RETRY_COUNT`)

2. **コメント**
   - 複雑なロジックには必ずコメントを付ける
   - JSDoc形式でAPI関数にはドキュメントコメントを記述

3. **型定義**
   - 必ず型定義を行い、`any`型の使用は最小限に抑える
   - 共通の型は`/types`ディレクトリに定義

### 5.2 エラー処理

1. **例外処理**
   - 非同期関数では必ず`try-catch`で例外をキャッチする
   - エラーは適切なレベルで処理し、ユーザーに分かりやすいメッセージを返す

2. **バリデーション**
   - ユーザー入力は必ずバリデーションを行う
   - Zodなどのスキーマバリデーションライブラリを使用

### 5.3 テスト

1. **単体テスト**
   - サービスとリポジトリの主要関数には単体テストを書く
   - モックを活用して外部依存を分離

2. **統合テスト**
   - APIエンドポイントの主要フローをテスト
   - テスト用DBを使用してE2Eテストを実施

# API実装パターン集

> **前提**
> - このドキュメントは、DigeClipのバックエンドAPI実装における共通パターンを定義します。
> - 目的は「**同じようなコードを何度も書かなくて済む**」ようにすることです。
> - 「**どんなエンジニアでも間違うことなく実装できる**」ことを重視しつつ、「**実装が複雑すぎず時間がかからない**」方法を採用します。

---

## 1. 基本的なAPIエンドポイント実装パターン

### 1.1 一覧取得 (GET /api/[role]/[resource])

```typescript
// /api/user/contents/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.contentSearch, req.query);

  // サービス呼び出し
  const { items, total } = await contentService.searchContents(query);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: query.page,
      limit: query.limit,
      pages: Math.ceil(total / query.limit)
    }
  });
};

// ミドルウェア適用（認証＋エラーハンドリング）
export default withApiHandler(handler, { role: 'user' });
```

### 1.2 詳細取得 (GET /api/[role]/[resource]/[id])

```typescript
// /api/user/contents/[id].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { contentService } from '../../../lib/services/content/contentService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // サービス呼び出し
  const content = await contentService.getContentById(id);

  // 存在チェック
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // レスポンス
  return res.status(200).json({ data: content });
};

export default withApiHandler(handler, { role: 'user' });
```

### 1.3 新規作成 (POST /api/[role]/[resource])

```typescript
// /api/admin/sources/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceCreate, req.body);

  // サービス呼び出し
  const source = await sourceService.createSource(data);

  // レスポンス
  return res.status(201).json({ data: source });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 1.4 更新 (PUT /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (PUT部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'PUT') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceUpdate, req.body);

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  const updatedSource = await sourceService.updateSource(id, data);

  // レスポンス
  return res.status(200).json({ data: updatedSource });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 1.5 削除 (DELETE /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (DELETE部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  await sourceService.deleteSource(id);

  // レスポンス (204 No Content)
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'admin' });
```

---

## 2. 複合リソース操作パターン

### 2.1 リレーション取得 (GET /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/summaries.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.summarySearch, req.query);

  // サービス呼び出し
  const summaries = await contentService.getContentSummaries(id, query);

  // レスポンス
  return res.status(200).json({ data: summaries });
};

export default withApiHandler(handler, { role: 'user' });
```

### 2.2 リレーション追加 (POST /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/tags.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.tagAdd, req.body);

  // サービス呼び出し
  const updatedContent = await contentService.addTagToContent(id, data.tagId);

  // レスポンス
  return res.status(200).json({ data: updatedContent });
};

export default withApiHandler(handler, { role: 'user' });
```

### 2.3 リレーション削除 (DELETE /api/[role]/[resource]/[id]/[relation]/[relationId])

```typescript
// /api/user/contents/[id]/tags/[tagId].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../../lib/utils/middleware';
import { contentService } from '../../../../../lib/services/content/contentService';
import { errors } from '../../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id, tagId } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string' || !tagId || typeof tagId !== 'string') {
    throw errors.validation({
      id: !id || typeof id !== 'string' ? 'コンテンツIDが不正です' : undefined,
      tagId: !tagId || typeof tagId !== 'string' ? 'タグIDが不正です' : undefined
    });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // サービス呼び出し
  await contentService.removeTagFromContent(id, tagId);

  // レスポンス
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'user' });
```

---

## 3. 特殊操作パターン

### 3.1 一括操作 (POST /api/[role]/[resource]/batch)

```typescript
// /api/admin/contents/batch.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.contentBatchOperation, req.body);

  // 操作タイプに応じた処理
  let result;

  switch (data.operation) {
    case 'delete':
      result = await contentService.batchDelete(data.ids);
      break;
    case 'tag':
      result = await contentService.batchAddTag(data.ids, data.tagId);
      break;
    case 'untag':
      result = await contentService.batchRemoveTag(data.ids, data.tagId);
      break;
    default:
      throw errors.validation({ operation: '不明な操作タイプです' });
  }

  // レスポンス
  return res.status(200).json({ data: result });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 3.2 アクション実行 (POST /api/[role]/[resource]/[id]/[action])

```typescript
// /api/admin/contents/[id]/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { aiService } from '../../../../lib/services/ai/aiService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.summarizeOptions, req.body);

  // サービス呼び出し
  const summary = await aiService.summarizeContent(id, data.modelId, data.type);

  // レスポンス
  return res.status(200).json({ data: summary });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 3.3 検索 (POST /api/[role]/[resource]/search)

```typescript
// /api/user/contents/search.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const searchParams = await validate(schemas.contentAdvancedSearch, req.body);

  // サービス呼び出し
  const { items, total } = await contentService.advancedSearch(searchParams);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: searchParams.page,
      limit: searchParams.limit,
      pages: Math.ceil(total / searchParams.limit)
    }
  });
};

export default withApiHandler(handler, { role: 'user' });
```

---

## 4. 認証関連パターン

### 4.1 ログイン (POST /api/auth/login)

```typescript
// /api/auth/login.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const credentials = await validate(schemas.login, req.body);

  // 認証
  try {
    const { user, token } = await authService.login(credentials.email, credentials.password);

    // JWTをCookieにセット
    res.setHeader('Set-Cookie', `auth-token=${token}; Path=/; HttpOnly; SameSite=Strict; ${process.env.NODE_ENV === 'production' ? 'Secure;' : ''} Max-Age=86400`);

    // レスポンス
    return res.status(200).json({
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      }
    });
  } catch (error) {
    // 認証エラー
    return res.status(401).json({
      error: {
        code: 'E401',
        message: 'メールアドレスまたはパスワードが正しくありません'
      }
    });
  }
};

export default withErrorHandling(handler);
```

### 4.2 ログアウト (POST /api/auth/logout)

```typescript
// /api/auth/logout.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // Cookieを削除
  res.setHeader('Set-Cookie', 'auth-token=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0');

  // レスポンス
  return res.status(200).json({ data: { message: 'ログアウトしました' } });
};

export default withApiHandler(handler);
```

### 4.3 ユーザー登録 (POST /api/auth/register)

```typescript
// /api/auth/register.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const userData = await validate(schemas.register, req.body);

  // メールアドレスの重複チェック
  const existingUser = await authService.getUserByEmail(userData.email);
  if (existingUser) {
    return res.status(400).json({
      error: {
        code: 'E400',
        message: 'このメールアドレスは既に登録されています'
      }
    });
  }

  // ユーザー登録
  const user = await authService.register(userData);

  // レスポンス
  return res.status(201).json({
    data: {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    }
  });
};

export default withErrorHandling(handler);
```

---

## 5. 定期実行ジョブパターン

### 5.1 コンテンツ取得ジョブ (GET /api/cron/fetch-contents)

```typescript
// /api/cron/fetch-contents.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { sourceService } from '../../lib/services/source/sourceService';
import { contentService } from '../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // アクティブなソース一覧を取得
  const sources = await sourceService.getActiveSources();

  // 各ソースから新しいコンテンツを取得
  const results = await Promise.allSettled(
    sources.map(async (source) => {
      try {
        const newContents = await sourceService.fetchNewContents(source.id);

        // 新しいコンテンツごとに処理
        for (const content of newContents) {
          // コンテンツを保存
          await contentService.createContent({
            title: content.title,
            sourceId: source.id,
            originalUrl: content.url,
            publishedAt: content.publishedAt,
            // その他の必要なデータ
          });
        }

        return { sourceId: source.id, count: newContents.length };
      } catch (error) {
        console.error(`Error fetching contents from source ${source.id}:`, error);
        return { sourceId: source.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: 'コンテンツ取得ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

### 5.2 要約ジョブ (GET /api/cron/summarize)

```typescript
// /api/cron/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { contentService } from '../../lib/services/content/contentService';
import { aiService } from '../../lib/services/ai/aiService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // 要約が必要なコンテンツを取得
  const contents = await contentService.getContentsNeedingSummary();

  // 各コンテンツを要約
  const results = await Promise.allSettled(
    contents.map(async (content) => {
      try {
        // デフォルトAIモデルを取得
        const defaultModel = await aiService.getDefaultModel();

        // 要約を実行
        const summary = await aiService.summarizeContent(content.id, defaultModel.id);

        return { contentId: content.id, success: true };
      } catch (error) {
        console.error(`Error summarizing content ${content.id}:`, error);
        return { contentId: content.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: '要約ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

---

## 6. まとめ

このドキュメントで紹介した実装パターンを活用することで、以下のメリットが得られます：

1. **コードの一貫性**: 同じパターンで実装することで、コードの可読性と保守性が向上します。

2. **開発効率の向上**: 既存のパターンを再利用することで、新しいAPIエンドポイントを迅速に実装できます。

3. **エラー削減**: 共通のバリデーションやエラーハンドリングを使用することで、バグの発生を減らせます。

4. **学習コスト削減**: 明確なパターンがあることで、新しいエンジニアの学習コストが下がります。

これらのパターンは、DigeClipのバックエンド開発において「**機能追加しやすく、何度も同じようなコードを書かなくていい**」アーキテクチャを実現するための基盤となります。```

---

Read file: Requirements/2_Functional_Requirements/backend/0_Common_Requirements.md

---

```diff
- 
+ ## バックエンド実装上の注意事項
+ 
+ ### クリーンコードと再利用性
+ - **適切な抽象化レベルを維持する**: 過度な抽象化は避け、理解しやすく保守しやすいコードを心がけること
+ - **DRY原則を適用する**: 同じコードを繰り返し書かず、共通ロジックは再利用可能な関数やクラスに抽出すること
+ - **単一責任の原則を守る**: 各モジュールやクラスは一つの責任のみを持つようにし、複数の役割を持たせないこと
+ 
+ ### 依存関係管理
+ - **依存性注入を活用する**: 直接的な依存関係を避け、依存性注入を使用して結合度を下げること
+ - **インターフェースに依存する**: 具体的な実装ではなく、インターフェースに依存するコードを書くこと
+ - **循環依存を避ける**: モジュール間の循環依存を作らないよう、依存関係グラフを常に意識すること
+ 
+ ### コード構造
+ - **関数とクラスを小さく保つ**: 一つの関数やクラスは一つのことだけを行い、20行以内を目安にすること
+ - **ネストを浅く保つ**: 条件分岐やループのネストは3レベル以内に抑え、早期リターンを活用すること
+ - **コメントよりも自己説明的なコード**: コメントに頼るのではなく、変数名や関数名で意図を明確に表現すること
+ 
+ ### エラー処理
+ - **例外を適切に使用する**: 例外は本当に例外的な状況でのみ使用し、通常のフロー制御には使用しないこと
+ - **エラーメッセージを明確にする**: エラーメッセージは問題の原因と可能な解決策を含む、具体的なものにすること
+ - **グローバルエラーハンドラーを実装する**: 未処理の例外を捕捉し、適切なレスポンスを返すグローバルハンドラーを用意すること
+ 
+ ### テスト容易性
+ - **テスト駆動開発を検討する**: 複雑なロジックはテストファーストで開発し、要件を明確にすること
+ - **モックしやすい設計にする**: 外部依存は明確なインターフェースを通じてアクセスし、テスト時にモック可能にすること
+ - **テストカバレッジを意識する**: 重要なビジネスロジックは高いテストカバレッジを維持すること
+ 
+ ## 1. モノリシック or マイクロサービス
+ 
+ ### 選定方針と理由
+ 
+ - **現状はモノリシック構成**:
+   - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
+   - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。
+ 
+ - **将来的な拡張**:
+   - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
+   - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。
+ 
+ ### メリット/デメリット
+ - **メリット**:
+   - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
+   - **Vercel 無料枠**内で管理しやすい。
+ - **デメリット**:
+   - 大規模化時、モノリシックがボトルネックになる可能性。
+   - CI/CD や更新が大きくなるとビルド時間が延びる。
+ 
+ ## 2. サーバレスアーキテクチャ
+ 
+ ### 対象範囲
+ 
+ - **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
+ - Cron Jobs (Vercel) を利用して定期実行。
+ - **Supabase** はマネージド PostgreSQL でサーバレスに近い形。
+ 
+ ### 導入メリット
+ 
+ - **コストがほぼゼロ** (無料枠内)
+ - 運用負荷が少なく、**エンジニアがインフラ構築不要**
+ - デプロイとスケールが自動化され、**初心者でも扱いやすい**
+ 
+ ### デメリット / 将来検討
+ 
+ - Vercel の無料枠・API 実行回数に制限がある。
+ - ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
+ - AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。
+ 
+ ## 3. レイヤードアーキテクチャ
+ 
+ 本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。
+ 
+ 1. **プレゼンテーション層 (UI)**
+    - Next.js のページコンポーネント + Tailwind CSS
+    - フロント側で認証・画面表示・ユーザー操作を受け付け
+ 
+ 2. **APIレイヤー** (`/app/api/*`)
+    - Next.js の API Routes (Serverless Functions) で REST API 的に実装
+    - HTTPリクエストの受付
+    - 認証・認可の確認
+    - リクエストのバリデーション
+    - 適切なサービスの呼び出し
+    - レスポンスの整形
+ 
+ 3. **サービスレイヤー** (`/lib/services/*`)
+    - ビジネスロジックの実装
+    - トランザクション管理
+    - 複数リポジトリの連携
+    - 外部APIとの連携
+ 
+ 4. **リポジトリレイヤー** (`/lib/db/repositories/*`)
+    - データアクセスロジックの抽象化
+    - クエリの実行
+    - データの変換（DB形式 ⇔ アプリケーション形式）
+ 
+ 5. **ユーティリティレイヤー** (`/lib/utils/*`)
+    - 共通機能の提供
+    - ヘルパー関数
+    - バリデーション
+    - エラーハンドリング
+ 
+ ## 4. 技術スタック
+ 
+ ### 言語
+ - **TypeScript 5.x**
+   - 静的型付けによりコンパイル時のエラー検出が可能
+   - JavaScriptとの高い互換性
+   - 広範なコミュニティと学習資源
+ 
+ ### フレームワーク
+ - **Next.js 14 (React)**
+   - SSR, SSG, ISRなど柔軟なレンダリング方式
+   - Vercelとの組み合わせが非常にスムーズ
+   - TypeScriptとの相性が良い
+ 
+ ### データベース
+ - **Supabase (PostgreSQL)**
+   - マネージドPostgreSQLサービス
+   - 認証機能も統合
+   - 無料枠が利用可能
+ 
+ ### ORマッパー
+ - **Prisma ORM**
+   - 型安全なクエリクライアント
+   - スキーマ定義から型を自動生成
+   - Supabaseとの連携が容易
+ 
+ ### キャッシュ
+ - **Redis (Upstash)**
+   - 高速なインメモリキャッシュ
+   - サーバレス運用が可能
+   - 無料枠や低料金プランが存在
+ 
+ ### AI/ML関連
+ - **OpenAI API**
+ - **Anthropic API**
+ - **langchain** (オプション)
+ 
+ ### テスト
+ - **Jest** - ユニットテスト、統合テスト
+ - **supertest** - APIテスト
+ - **@testing-library/react** - Reactコンポーネントテスト
+ 
+ ## 5. API設計
+ 
+ ### ベースURL
+ ```
+ https://api.digeclip.com/api
+ ```
+ 
+ ### リソース命名規則
+ - 複数形の名詞を使用 (例: `/sources`, `/contents`)
+ - 小文字のケバブケース (例: `/ai-models`)
+ - ネストしたリソースはパスで表現 (例: `/contents/{id}/summaries`)
+ 
+ ### HTTPメソッド
+ - GET: リソースの取得
+ - POST: リソースの作成
+ - PUT: リソースの更新（全体）
+ - PATCH: リソースの部分更新
+ - DELETE: リソースの削除
+ 
+ ### レスポンス形式
+ #### 成功時
+ ```json
+ {
+   "data": {
+     // リソースデータ
+   },
+   "meta": {
+     // メタデータ（ページネーション情報など）
+   }
+ }
+ ```
+ 
+ #### エラー時
+ ```json
+ {
+   "error": {
+     "code": "E400",
+     "message": "ユーザーフレンドリーなエラーメッセージ",
+     "details": {
+       "field1": "フィールド固有のエラーメッセージ",
+       "field2": "フィールド固有のエラーメッセージ"
+     }
+   }
+ }
+ ```
+ 
+ ### ステータスコード
+ - 200: 成功
+ - 201: 作成成功
+ - 204: 削除成功
+ - 400: バリデーションエラー
+ - 401: 認証エラー
+ - 403: 権限エラー
+ - 404: リソース未発見
+ - 409: リソース競合
+ - 429: リクエスト数制限超過
+ - 500: 内部サーバーエラー
+ - 503: サービス利用不可
+ 
+ ### クエリパラメータ
+ - ページネーション: `/api/contents?page=1&limit=10`
+ - フィルタリング: `/api/contents?status=published&source_id=123`
+ - ソート: `/api/contents?sort=published_at:desc`
+ - 検索: `/api/contents?search=keyword`
+ 
+ ## 6. 外部サービス連携
+ 
+ ### SNS認証
+ - **Google OAuth 2.0**
+   - フロントエンドで「Googleでログイン」ボタンを設置
+   - コールバックURLでcodeを受け取り、トークンを取得
+   - ユーザー情報を取得してローカルDBに保存
+   - JWTを発行してフロントに返す
+ 
+ ### 決済サービス
+ - **Stripe**
+   - 従量課金・SDK充実
+   - Webhookで決済完了/失敗イベントを受け取る
+   - idempotency keyを使い、重複支払いを回避
+ 
+ ### メール配信
+ - **SendGrid**, **Mailgun**, **MailerSend**
+   - トランザクションメール（即時送信）
+   - バルクメール（定期/手動バッチ実行）
+   - テンプレートを使用して動的に生成
+ 
+ ### その他外部API
+ - **地図API**: Google Maps, OpenStreetMap + Leaflet, Mapbox
+ - **レコメンドエンジン**: Recombee, Algolia Recommend
+ 
+ ## 7. API実装パターン
+ 
+ ### 基本的なAPIエンドポイント実装パターン
+ 
+ #### 一覧取得 (GET /api/[role]/[resource])
+ ```typescript
+ // /api/user/contents/index.ts
+ import { NextApiRequest, NextApiResponse } from 'next';
+ import { withApiHandler } from '../../../lib/utils/middleware';
+ import { validate, schemas } from '../../../lib/utils/validation';
+ import { contentService } from '../../../lib/services/content/contentService';
+ 
+ const handler = async (req: NextApiRequest, res: NextApiResponse) => {
+   // メソッドチェック
+   if (req.method !== 'GET') {
+     return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
+   }
+ 
+   // クエリパラメータのバリデーション
+   const query = await validate(schemas.contentSearch, req.query);
+ 
+   // サービス呼び出し
+   const { items, total } = await contentService.searchContents(query);
+ 
+   // レスポンス
+   return res.status(200).json({
+     data: items,
+     meta: {
+       total,
+       page: query.page,
+       limit: query.limit,
+       pages: Math.ceil(total / query.limit)
+     }
+   });
+ };
+ 
+ // ミドルウェア適用（認証＋エラーハンドリング）
+ export default withApiHandler(handler, { role: 'user' });
+ ```
+ 
+ #### 詳細取得 (GET /api/[role]/[resource]/[id])
+ ```typescript
+ // /api/user/contents/[id].ts
+ import { NextApiRequest, NextApiResponse } from 'next';
+ import { withApiHandler } from '../../../lib/utils/middleware';
+ import { contentService } from '../../../lib/services/content/contentService';
+ import { errors } from '../../../lib/utils/error';
+ 
+ const handler = async (req: NextApiRequest, res: NextApiResponse) => {
+   const { id } = req.query;
+ 
+   // IDのバリデーション
+   if (!id || typeof id !== 'string') {
+     throw errors.validation({ id: 'IDが不正です' });
+   }
+ 
+   // メソッドチェック
+   if (req.method !== 'GET') {
+     return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
+   }
+ 
+   // サービス呼び出し
+   const content = await contentService.getContentById(id);
+ 
+   // 存在チェック
+   if (!content) {
+     throw errors.notFound('コンテンツ');
+   }
+ 
+   // レスポンス
+   return res.status(200).json({ data: content });
+ };
+ 
+ export default withApiHandler(handler, { role: 'user' });
+ ```
+ 
+ ### 特殊操作パターン
+ 
+ #### アクション実行 (POST /api/[role]/[resource]/[id]/[action])
+ ```typescript
+ // /api/admin/contents/[id]/summarize.ts
+ import { NextApiRequest, NextApiResponse } from 'next';
+ import { withApiHandler } from '../../../../lib/utils/middleware';
+ import { validate, schemas } from '../../../../lib/utils/validation';
+ import { contentService } from '../../../../lib/services/content/contentService';
+ import { aiService } from '../../../../lib/services/ai/aiService';
+ import { errors } from '../../../../lib/utils/error';
+ 
+ const handler = async (req: NextApiRequest, res: NextApiResponse) => {
+   const { id } = req.query;
+ 
+   // IDのバリデーション
+   if (!id || typeof id !== 'string') {
+     throw errors.validation({ id: 'IDが不正です' });
+   }
+ 
+   // メソッドチェック
+   if (req.method !== 'POST') {
+     return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
+   }
+ 
+   // 存在チェック
+   const content = await contentService.getContentById(id);
+   if (!content) {
+     throw errors.notFound('コンテンツ');
+   }
+ 
+   // リクエストボディのバリデーション
+   const data = await validate(schemas.summarizeOptions, req.body);
+ 
+   // サービス呼び出し
+   const summary = await aiService.summarizeContent(id, data.modelId, data.type);
+ 
+   // レスポンス
+   return res.status(200).json({ data: summary });
+ };
+ 
+ export default withApiHandler(handler, { role: 'admin' });
+ ```
+ 
+ ### 定期実行ジョブパターン
+ 
+ #### 要約ジョブ (GET /api/cron/summarize)
+ ```typescript
+ // /api/cron/summarize.ts
+ import { NextApiRequest, NextApiResponse } from 'next';
+ import { withApiHandler } from '../../lib/utils/middleware';
+ import { contentService } from '../../lib/services/content/contentService';
+ import { aiService } from '../../lib/services/ai/aiService';
+ 
+ const handler = async (req: NextApiRequest, res: NextApiResponse) => {
+   // Vercel Cronからの呼び出しのみ許可
+   const authHeader = req.headers.authorization;
+   if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
+     return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
+   }
+ 
+   // 要約が必要なコンテンツを取得
+   const contents = await contentService.getContentsNeedingSummary();
+ 
+   // 各コンテンツを要約
+   const results = await Promise.allSettled(
+     contents.map(async (content) => {
+       try {
+         // デフォルトAIモデルを取得
+         const defaultModel = await aiService.getDefaultModel();
+ 
+         // 要約を実行
+         const summary = await aiService.summarizeContent(content.id, defaultModel.id);
+ 
+         return { contentId: content.id, success: true };
+       } catch (error) {
+         console.error(`Error summarizing content ${content.id}:`, error);
+         return { contentId: content.id, error: error.message };
+       }
+     })
+   );
+ 
+   return res.status(200).json({
+     message: '要約ジョブが完了しました',
+     results
+   });
+ };
+ 
+ // 認証不要（Cronからの呼び出し）
+ export default withApiHandler(handler);
+ ```
+ 
+ ## 8. ディレクトリ構造
+ 
+ ```
+ /src
+   ├─ /app                          # Next.jsのApp Routerディレクトリ
+   │   ├─ /page.tsx                 # ダッシュボード画面
+   │   ├─ /sources/page.tsx         # ソース一覧
+   │   ├─ /contents/page.tsx        # コンテンツ一覧
+   │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
+   │   ├─ /settings/
+   │   │   ├─ /ai-models/page.tsx   # AIモデル設定
+   │   │   ├─ /notifications/page.tsx # 通知設定
+   │   │   └─ /...
+   │   └─ /api                      # APIルートディレクトリ
+   │       ├─ /auth/                # 認証関連API
+   │       │   ├─ /login/route.ts
+   │       │   ├─ /register/route.ts
+   │       │   └─ /...
+   │       ├─ /admin/               # 管理者用API
+   │       │   ├─ /sources/route.ts
+   │       │   ├─ /contents/route.ts
+   │       │   └─ /...
+   │       └─ /user/                # 一般ユーザー用API
+   │           ├─ /contents/route.ts
+   │           └─ /...
+   │
+   ├─ /components                   # 再利用可能なコンポーネント
+   │   ├─ /ui                       # 基本UIコンポーネント
+   │   ├─ /layout                   # レイアウト関連コンポーネント
+   │   ├─ /features                 # 機能別コンポーネント
+   │   └─ /patterns                 # 再利用可能なパターン
+   │
+   ├─ /lib                          # ユーティリティと共通関数
+   │   ├─ /api                      # API関連ユーティリティ
+   │   ├─ /db                       # データベース関連
+   │   │   ├─ client.ts             # Supabase接続
+   │   │   └─ /repositories         # リポジトリクラス
+   │   │       ├─ sourceRepository.ts
+   │   │       ├─ contentRepository.ts
+   │   │       └─ ...
+   │   ├─ /services                 # ビジネスロジック
+   │   │   ├─ /content              # コンテンツ関連サービス
+   │   │   ├─ /source               # ソース関連サービス
+   │   │   ├─ /ai                   # AI関連サービス
+   │   │   └─ /notification         # 通知関連サービス
+   │   ├─ /utils                    # 汎用ユーティリティ
+   │   └─ /middleware               # ミドルウェア
+   │
+   ├─ /types                        # 型定義
+   │   ├─ /api                      # API関連の型
+   │   └─ /models                   # モデル関連の型
+   │
+   └─ /config                       # 設定ファイル
+       ├─ constants.ts              # 定数定義
+       ├─ routes.ts                 # ルート定義
+       └─ ...
+ ```
+ 
+ ## 9. 実装ガイドライン
+ 
+ ### コーディング規約
+ - **ファイル名**: キャメルケース (`contentService.ts`)
+ - **クラス/インターフェース**: パスカルケース (`ContentService`)
+ - **関数/変数**: キャメルケース (`getContentById`)
+ - **定数**: 大文字スネークケース (`MAX_RETRY_COUNT`)
+ 
+ ### コメント
+ - 複雑なロジックには必ずコメントを付ける
+ - JSDoc形式でAPI関数にはドキュメントコメントを記述
+ 
+ ### 型定義
+ - 必ず型定義を行い、`any`型の使用は最小限に抑える
+ - 共通の型は`/types`ディレクトリに定義
+ 
+ ### エラー処理
+ - 非同期関数では必ず`try-catch`で例外をキャッチする
+ - エラーは適切なレベルで処理し、ユーザーに分かりやすいメッセージを返す
+ 
+ ### バリデーション
+ - ユーザー入力は必ずバリデーションを行う
+ - Zodなどのスキーマバリデーションライブラリを使用
+ 
+ ### テスト
+ - サービスとリポジトリの主要関数には単体テストを書く
+ - APIエンドポイントの主要フローをテスト
+ - テスト用DBを使用してE2Eテストを実施
```

---

バックエンド実装上の注意事項ファイルを、要件ドキュメントに合わせて更新しました。以下の内容が含まれています：

1. **クリーンコードと再利用性**
   - 適切な抽象化レベルの維持
   - DRY原則の適用
   - 単一責任の原則

2. **アーキテクチャ選定**
   - モノリシック構成（Next.js + Supabase）
   - サーバレスアーキテクチャの採用
   - レイヤードアーキテクチャの実装

3. **技術スタック**
   - TypeScript 5.x
   - Next.js 14
   - Supabase (PostgreSQL)
   - Prisma ORM
   - Redis (Upstash)
   - AI/ML関連ライブラリ

4. **API設計**
   - RESTful設計原則
   - 統一されたレスポンス形式
   - 適切なステータスコード
   - クエリパラメータの活用

5. **外部サービス連携**
   - Google OAuth認証
   - Stripe決済
   - SendGrid/Mailgunメール配信
   - その他外部API

6. **API実装パターン**
   - 基本的なCRUD操作
   - 特殊操作（アクション実行）
   - 定期実行ジョブ

7. **ディレクトリ構造**
   - 整理されたフォルダ構成
   - 責任分離に基づく構造

8. **実装ガイドライン**
   - コーディング規約
   - コメント方針
   - 型定義の重要性
   - エラー処理とバリデーション
   - テスト戦略

これらの内容は、バックエンド開発において一貫性のあるコードベースを構築し、将来的な拡張性を確保するための指針となります。

---

_**User**_

次のAuto Attachのファイル形式を選定して
"""
## バックエンド実装上の注意事項

### クリーンコードと再利用性
- **適切な抽象化レベルを維持する**: 過度な抽象化は避け、理解しやすく保守しやすいコードを心がけること
- **DRY原則を適用する**: 同じコードを繰り返し書かず、共通ロジックは再利用可能な関数やクラスに抽出すること
- **単一責任の原則を守る**: 各モジュールやクラスは一つの責任のみを持つようにし、複数の役割を持たせないこと

### 依存関係管理
- **依存性注入を活用する**: 直接的な依存関係を避け、依存性注入を使用して結合度を下げること
- **インターフェースに依存する**: 具体的な実装ではなく、インターフェースに依存するコードを書くこと
- **循環依存を避ける**: モジュール間の循環依存を作らないよう、依存関係グラフを常に意識すること

### コード構造
- **関数とクラスを小さく保つ**: 一つの関数やクラスは一つのことだけを行い、20行以内を目安にすること
- **ネストを浅く保つ**: 条件分岐やループのネストは3レベル以内に抑え、早期リターンを活用すること
- **コメントよりも自己説明的なコード**: コメントに頼るのではなく、変数名や関数名で意図を明確に表現すること

### エラー処理
- **例外を適切に使用する**: 例外は本当に例外的な状況でのみ使用し、通常のフロー制御には使用しないこと
- **エラーメッセージを明確にする**: エラーメッセージは問題の原因と可能な解決策を含む、具体的なものにすること
- **グローバルエラーハンドラーを実装する**: 未処理の例外を捕捉し、適切なレスポンスを返すグローバルハンドラーを用意すること

### テスト容易性
- **テスト駆動開発を検討する**: 複雑なロジックはテストファーストで開発し、要件を明確にすること
- **モックしやすい設計にする**: 外部依存は明確なインターフェースを通じてアクセスし、テスト時にモック可能にすること
- **テストカバレッジを意識する**: 重要なビジネスロジックは高いテストカバレッジを維持すること

## 1. モノリシック or マイクロサービス

### 選定方針と理由

- **現状はモノリシック構成**:
  - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
  - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。

- **将来的な拡張**:
  - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
  - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。

### メリット/デメリット
- **メリット**:
  - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
  - **Vercel 無料枠**内で管理しやすい。
- **デメリット**:
  - 大規模化時、モノリシックがボトルネックになる可能性。
  - CI/CD や更新が大きくなるとビルド時間が延びる。

## 2. サーバレスアーキテクチャ

### 対象範囲

- **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
- Cron Jobs (Vercel) を利用して定期実行。
- **Supabase** はマネージド PostgreSQL でサーバレスに近い形。

### 導入メリット

- **コストがほぼゼロ** (無料枠内)
- 運用負荷が少なく、**エンジニアがインフラ構築不要**
- デプロイとスケールが自動化され、**初心者でも扱いやすい**

### デメリット / 将来検討

- Vercel の無料枠・API 実行回数に制限がある。
- ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
- AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。

## 3. レイヤードアーキテクチャ

本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。

1. **プレゼンテーション層 (UI)**
   - Next.js のページコンポーネント + Tailwind CSS
   - フロント側で認証・画面表示・ユーザー操作を受け付け

2. **APIレイヤー** (`/app/api/*`)
   - Next.js の API Routes (Serverless Functions) で REST API 的に実装
   - HTTPリクエストの受付
   - 認証・認可の確認
   - リクエストのバリデーション
   - 適切なサービスの呼び出し
   - レスポンスの整形

3. **サービスレイヤー** (`/lib/services/*`)
   - ビジネスロジックの実装
   - トランザクション管理
   - 複数リポジトリの連携
   - 外部APIとの連携

4. **リポジトリレイヤー** (`/lib/db/repositories/*`)
   - データアクセスロジックの抽象化
   - クエリの実行
   - データの変換（DB形式 ⇔ アプリケーション形式）

5. **ユーティリティレイヤー** (`/lib/utils/*`)
   - 共通機能の提供
   - ヘルパー関数
   - バリデーション
   - エラーハンドリング

## 4. 技術スタック

### 言語
- **TypeScript 5.x**
  - 静的型付けによりコンパイル時のエラー検出が可能
  - JavaScriptとの高い互換性
  - 広範なコミュニティと学習資源

### フレームワーク
- **Next.js 14 (React)**
  - SSR, SSG, ISRなど柔軟なレンダリング方式
  - Vercelとの組み合わせが非常にスムーズ
  - TypeScriptとの相性が良い

### データベース
- **Supabase (PostgreSQL)**
  - マネージドPostgreSQLサービス
  - 認証機能も統合
  - 無料枠が利用可能

### ORマッパー
- **Prisma ORM**
  - 型安全なクエリクライアント
  - スキーマ定義から型を自動生成
  - Supabaseとの連携が容易

### キャッシュ
- **Redis (Upstash)**
  - 高速なインメモリキャッシュ
  - サーバレス運用が可能
  - 無料枠や低料金プランが存在

### AI/ML関連
- **OpenAI API**
- **Anthropic API**
- **langchain** (オプション)

### テスト
- **Jest** - ユニットテスト、統合テスト
- **supertest** - APIテスト
- **@testing-library/react** - Reactコンポーネントテスト

## 5. API設計

### ベースURL
```
https://api.digeclip.com/api
```

### リソース命名規則
- 複数形の名詞を使用 (例: `/sources`, `/contents`)
- 小文字のケバブケース (例: `/ai-models`)
- ネストしたリソースはパスで表現 (例: `/contents/{id}/summaries`)

### HTTPメソッド
- GET: リソースの取得
- POST: リソースの作成
- PUT: リソースの更新（全体）
- PATCH: リソースの部分更新
- DELETE: リソースの削除

### レスポンス形式
#### 成功時
```json
{
  "data": {
    // リソースデータ
  },
  "meta": {
    // メタデータ（ページネーション情報など）
  }
}
```

#### エラー時
```json
{
  "error": {
    "code": "E400",
    "message": "ユーザーフレンドリーなエラーメッセージ",
    "details": {
      "field1": "フィールド固有のエラーメッセージ",
      "field2": "フィールド固有のエラーメッセージ"
    }
  }
}
```

### ステータスコード
- 200: 成功
- 201: 作成成功
- 204: 削除成功
- 400: バリデーションエラー
- 401: 認証エラー
- 403: 権限エラー
- 404: リソース未発見
- 409: リソース競合
- 429: リクエスト数制限超過
- 500: 内部サーバーエラー
- 503: サービス利用不可

### クエリパラメータ
- ページネーション: `/api/contents?page=1&limit=10`
- フィルタリング: `/api/contents?status=published&source_id=123`
- ソート: `/api/contents?sort=published_at:desc`
- 検索: `/api/contents?search=keyword`

## 6. 外部サービス連携

### SNS認証
- **Google OAuth 2.0**
  - フロントエンドで「Googleでログイン」ボタンを設置
  - コールバックURLでcodeを受け取り、トークンを取得
  - ユーザー情報を取得してローカルDBに保存
  - JWTを発行してフロントに返す

### 決済サービス
- **Stripe**
  - 従量課金・SDK充実
  - Webhookで決済完了/失敗イベントを受け取る
  - idempotency keyを使い、重複支払いを回避

### メール配信
- **SendGrid**, **Mailgun**, **MailerSend**
  - トランザクションメール（即時送信）
  - バルクメール（定期/手動バッチ実行）
  - テンプレートを使用して動的に生成

### その他外部API
- **地図API**: Google Maps, OpenStreetMap + Leaflet, Mapbox
- **レコメンドエンジン**: Recombee, Algolia Recommend

## 7. API実装パターン

### 基本的なAPIエンドポイント実装パターン

#### 一覧取得 (GET /api/[role]/[resource])
```typescript
// /api/user/contents/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.contentSearch, req.query);

  // サービス呼び出し
  const { items, total } = await contentService.searchContents(query);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: query.page,
      limit: query.limit,
      pages: Math.ceil(total / query.limit)
    }
  });
};

// ミドルウェア適用（認証＋エラーハンドリング）
export default withApiHandler(handler, { role: 'user' });
```

#### 詳細取得 (GET /api/[role]/[resource]/[id])
```typescript
// /api/user/contents/[id].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { contentService } from '../../../lib/services/content/contentService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // サービス呼び出し
  const content = await contentService.getContentById(id);

  // 存在チェック
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // レスポンス
  return res.status(200).json({ data: content });
};

export default withApiHandler(handler, { role: 'user' });
```

#### 新規作成 (POST /api/[role]/[resource])

```typescript
// /api/admin/sources/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceCreate, req.body);

  // サービス呼び出し
  const source = await sourceService.createSource(data);

  // レスポンス
  return res.status(201).json({ data: source });
};

export default withApiHandler(handler, { role: 'admin' });
```

#### 更新 (PUT /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (PUT部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'PUT') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceUpdate, req.body);

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  const updatedSource = await sourceService.updateSource(id, data);

  // レスポンス
  return res.status(200).json({ data: updatedSource });
};

export default withApiHandler(handler, { role: 'admin' });
```

#### 削除 (DELETE /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (DELETE部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  await sourceService.deleteSource(id);

  // レスポンス (204 No Content)
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'admin' });
```

### 複合リソース操作パターン

#### リレーション取得 (GET /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/summaries.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.summarySearch, req.query);

  // サービス呼び出し
  const summaries = await contentService.getContentSummaries(id, query);

  // レスポンス
  return res.status(200).json({ data: summaries });
};

export default withApiHandler(handler, { role: 'user' });
```

#### リレーション追加 (POST /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/tags.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.tagAdd, req.body);

  // サービス呼び出し
  const updatedContent = await contentService.addTagToContent(id, data.tagId);

  // レスポンス
  return res.status(200).json({ data: updatedContent });
};

export default withApiHandler(handler, { role: 'user' });
```

#### リレーション削除 (DELETE /api/[role]/[resource]/[id]/[relation]/[relationId])

```typescript
// /api/user/contents/[id]/tags/[tagId].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../../lib/utils/middleware';
import { contentService } from '../../../../../lib/services/content/contentService';
import { errors } from '../../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id, tagId } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string' || !tagId || typeof tagId !== 'string') {
    throw errors.validation({
      id: !id || typeof id !== 'string' ? 'コンテンツIDが不正です' : undefined,
      tagId: !tagId || typeof tagId !== 'string' ? 'タグIDが不正です' : undefined
    });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // サービス呼び出し
  await contentService.removeTagFromContent(id, tagId);

  // レスポンス
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'user' });
```

### 特殊操作パターン

#### 一括操作 (POST /api/[role]/[resource]/batch)

```typescript
// /api/admin/contents/batch.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.contentBatchOperation, req.body);

  // 操作タイプに応じた処理
  let result;

  switch (data.operation) {
    case 'delete':
      result = await contentService.batchDelete(data.ids);
      break;
    case 'tag':
      result = await contentService.batchAddTag(data.ids, data.tagId);
      break;
    case 'untag':
      result = await contentService.batchRemoveTag(data.ids, data.tagId);
      break;
    default:
      throw errors.validation({ operation: '不明な操作タイプです' });
  }

  // レスポンス
  return res.status(200).json({ data: result });
};

export default withApiHandler(handler, { role: 'admin' });
```

#### アクション実行 (POST /api/[role]/[resource]/[id]/[action])
```typescript
// /api/admin/contents/[id]/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { aiService } from '../../../../lib/services/ai/aiService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.summarizeOptions, req.body);

  // サービス呼び出し
  const summary = await aiService.summarizeContent(id, data.modelId, data.type);

  // レスポンス
  return res.status(200).json({ data: summary });
};

export default withApiHandler(handler, { role: 'admin' });
```

#### 検索 (POST /api/[role]/[resource]/search)

```typescript
// /api/user/contents/search.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const searchParams = await validate(schemas.contentAdvancedSearch, req.body);

  // サービス呼び出し
  const { items, total } = await contentService.advancedSearch(searchParams);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: searchParams.page,
      limit: searchParams.limit,
      pages: Math.ceil(total / searchParams.limit)
    }
  });
};

export default withApiHandler(handler, { role: 'user' });
```

### 認証関連パターン

#### ログイン (POST /api/auth/login)

```typescript
// /api/auth/login.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const credentials = await validate(schemas.login, req.body);

  // 認証
  try {
    const { user, token } = await authService.login(credentials.email, credentials.password);

    // JWTをCookieにセット
    res.setHeader('Set-Cookie', `auth-token=${token}; Path=/; HttpOnly; SameSite=Strict; ${process.env.NODE_ENV === 'production' ? 'Secure;' : ''} Max-Age=86400`);

    // レスポンス
    return res.status(200).json({
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      }
    });
  } catch (error) {
    // 認証エラー
    return res.status(401).json({
      error: {
        code: 'E401',
        message: 'メールアドレスまたはパスワードが正しくありません'
      }
    });
  }
};

export default withErrorHandling(handler);
```

#### ログアウト (POST /api/auth/logout)

```typescript
// /api/auth/logout.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // Cookieを削除
  res.setHeader('Set-Cookie', 'auth-token=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0');

  // レスポンス
  return res.status(200).json({ data: { message: 'ログアウトしました' } });
};

export default withApiHandler(handler);
```

#### ユーザー登録 (POST /api/auth/register)

```typescript
// /api/auth/register.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const userData = await validate(schemas.register, req.body);

  // メールアドレスの重複チェック
  const existingUser = await authService.getUserByEmail(userData.email);
  if (existingUser) {
    return res.status(400).json({
      error: {
        code: 'E400',
        message: 'このメールアドレスは既に登録されています'
      }
    });
  }

  // ユーザー登録
  const user = await authService.register(userData);

  // レスポンス
  return res.status(201).json({
    data: {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    }
  });
};

export default withErrorHandling(handler);
```

### 定期実行ジョブパターン

#### コンテンツ取得ジョブ (GET /api/cron/fetch-contents)

```typescript
// /api/cron/fetch-contents.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { sourceService } from '../../lib/services/source/sourceService';
import { contentService } from '../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // アクティブなソース一覧を取得
  const sources = await sourceService.getActiveSources();

  // 各ソースから新しいコンテンツを取得
  const results = await Promise.allSettled(
    sources.map(async (source) => {
      try {
        const newContents = await sourceService.fetchNewContents(source.id);

        // 新しいコンテンツごとに処理
        for (const content of newContents) {
          // コンテンツを保存
          await contentService.createContent({
            title: content.title,
            sourceId: source.id,
            originalUrl: content.url,
            publishedAt: content.publishedAt,
            // その他の必要なデータ
          });
        }

        return { sourceId: source.id, count: newContents.length };
      } catch (error) {
        console.error(`Error fetching contents from source ${source.id}:`, error);
        return { sourceId: source.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: 'コンテンツ取得ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

#### 要約ジョブ (GET /api/cron/summarize)
```typescript
// /api/cron/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { contentService } from '../../lib/services/content/contentService';
import { aiService } from '../../lib/services/ai/aiService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // 要約が必要なコンテンツを取得
  const contents = await contentService.getContentsNeedingSummary();

  // 各コンテンツを要約
  const results = await Promise.allSettled(
    contents.map(async (content) => {
      try {
        // デフォルトAIモデルを取得
        const defaultModel = await aiService.getDefaultModel();

        // 要約を実行
        const summary = await aiService.summarizeContent(content.id, defaultModel.id);

        return { contentId: content.id, success: true };
      } catch (error) {
        console.error(`Error summarizing content ${content.id}:`, error);
        return { contentId: content.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: '要約ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

## 8. ディレクトリ構造

```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  └─ /config                       # 設定ファイル
      ├─ constants.ts              # 定数定義
      ├─ routes.ts                 # ルート定義
      └─ ...
```

## 9. 実装ガイドライン

### コーディング規約
- **ファイル名**: キャメルケース (`contentService.ts`)
- **クラス/インターフェース**: パスカルケース (`ContentService`)
- **関数/変数**: キャメルケース (`getContentById`)
- **定数**: 大文字スネークケース (`MAX_RETRY_COUNT`)

### コメント
- 複雑なロジックには必ずコメントを付ける
- JSDoc形式でAPI関数にはドキュメントコメントを記述

### 型定義
- 必ず型定義を行い、`any`型の使用は最小限に抑える
- 共通の型は`/types`ディレクトリに定義

### エラー処理
- 非同期関数では必ず`try-catch`で例外をキャッチする
- エラーは適切なレベルで処理し、ユーザーに分かりやすいメッセージを返す

### バリデーション
- ユーザー入力は必ずバリデーションを行う
- Zodなどのスキーマバリデーションライブラリを使用

### テスト
- サービスとリポジトリの主要関数には単体テストを書く
- APIエンドポイントの主要フローをテスト
- テスト用DBを使用してE2Eテストを実施
"""

---

_**Assistant**_

提供されたファイルは、バックエンド実装の詳細なガイドラインを含む技術文書です。このファイルに最適な形式は以下のとおりです：

1. **ファイル形式**: Markdown (.md)
   - コードブロックや見出し、箇条書きなどの書式が多用されており、Markdownが最適です

2. **ファイル名**: `backend_implementation_guidelines.md`
   - 内容がバックエンド実装のガイドラインであることを明確に示す名前です

3. **保存場所**: `docs/development/` または `guidelines/backend/` ディレクトリ
   - 開発ドキュメントとして整理するのに適した場所です

このファイルは、アーキテクチャ設計、コーディング規約、API実装パターン、ディレクトリ構造など、バックエンド開発の包括的なガイドラインを提供しています。Markdown形式で保存することで、GitHubやGitLabなどのリポジトリでも適切に表示され、開発者が参照しやすくなります。

---

_**User**_

@backend.mdc を対象とするAuto Attachのファイル形式やファイルを選定して。

---

_**Assistant**_

Auto Attachの設定として、`backend.mdc`ファイルに対して以下の設定が適切です：

1. **ファイル形式**: Markdown Document (`.mdc`)
   - Markdownの拡張形式で、コードブロックや見出し、箇条書きなどの書式が適切に表示されます
   - `.mdc`拡張子はMarkdown Contentを示し、特別な処理やスタイリングが適用できます

2. **Auto Attach設定**:
   - **パターン**: `**/*.mdc`
   - **説明**: "バックエンド実装上の注意事項"
   - **グロブ**: `backend.mdc`

3. **適用範囲**:
   - バックエンド関連のコードファイル（特にAPI実装、サービス層、リポジトリ層など）を編集する際に自動的に添付されるようにします

この設定により、バックエンド関連のコードを編集する際に、`backend.mdc`ファイルが自動的に参照され、実装ガイドラインに従ったコーディングが促進されます。特にAPI実装パターンやエラー処理、レイヤー構造などの重要な規約が常に参照可能になります。

---

_**User**_

バックエンドの実装に @backend.mdc を適用したい。ファイルと選定して。

---

_**Assistant**_

バックエンド実装に`@backend.mdc`を適用するために、以下のファイルを選定します：

### 主要なバックエンドファイル

1. **API Routes**
   - `/app/api/user/contents/route.ts` - ユーザーコンテンツAPI
   - `/app/api/admin/sources/route.ts` - 管理者ソースAPI
   - `/app/api/auth/login/route.ts` - 認証API

2. **サービス層**
   - `/lib/services/content/contentService.ts` - コンテンツサービス
   - `/lib/services/source/sourceService.ts` - ソースサービス
   - `/lib/services/ai/aiService.ts` - AI要約サービス

3. **リポジトリ層**
   - `/lib/db/repositories/contentRepository.ts` - コンテンツリポジトリ
   - `/lib/db/repositories/sourceRepository.ts` - ソースリポジトリ

4. **ミドルウェア**
   - `/lib/middleware/apiHandler.ts` - API共通ハンドラー
   - `/lib/middleware/errorHandler.ts` - エラーハンドリング

5. **ユーティリティ**
   - `/lib/utils/validation.ts` - バリデーション
   - `/lib/utils/error.ts` - エラーユーティリティ

### Auto Attach設定

```json
{
  "pattern": "**/{app/api/**,lib/{services,db,middleware,utils}/**}/*.{ts,tsx}",
  "description": "バックエンド実装上の注意事項",
  "rule": "backend.mdc"
}
```

この設定により、バックエンドの実装に関わるファイルを編集する際に、`backend.mdc`のガイドラインが自動的に参照され、一貫性のあるコーディングスタイルとアーキテクチャパターンの適用が促進されます。特にAPI実装、サービス層、リポジトリ層など、バックエンドの中核となる部分に適用されます。

---

_**User**_

同様に @frontend.mdc の選定もして。

---

_**Assistant**_

フロントエンド実装に`@frontend.mdc`を適用するために、以下のファイルを選定します：

### 主要なフロントエンドファイル

1. **ページコンポーネント**
   - `/app/page.tsx` - ダッシュボード画面
   - `/app/sources/page.tsx` - ソース一覧ページ
   - `/app/contents/page.tsx` - コンテンツ一覧ページ
   - `/app/contents/[id]/page.tsx` - コンテンツ詳細ページ
   - `/app/settings/ai-models/page.tsx` - AIモデル設定ページ

2. **UIコンポーネント**
   - `/components/ui/Button/Button.tsx` - ボタンコンポーネント
   - `/components/ui/Card/Card.tsx` - カードコンポーネント
   - `/components/ui/Modal/Modal.tsx` - モーダルコンポーネント
   - `/components/ui/Form/Form.tsx` - フォームコンポーネント

3. **機能コンポーネント**
   - `/components/features/sources/SourceList.tsx` - ソース一覧
   - `/components/features/contents/ContentCard.tsx` - コンテンツカード
   - `/components/features/summaries/SummaryView.tsx` - 要約表示

4. **カスタムフック**
   - `/hooks/api/user/useContents.ts` - コンテンツ取得フック
   - `/hooks/api/admin/useSources.ts` - ソース管理フック
   - `/hooks/ui/useModal.ts` - モーダル制御フック

5. **コンテキスト**
   - `/context/AuthContext.tsx` - 認証コンテキスト
   - `/context/ThemeContext.tsx` - テーマコンテキスト

### Auto Attach設定

```json
{
  "pattern": "**/{app/**,components/**,hooks/**,context/**}/*.{ts,tsx,js,jsx}",
  "description": "フロントエンド実装上の注意事項",
  "rule": "frontend.mdc"
}
```

この設定により、フロントエンドの実装に関わるファイルを編集する際に、`frontend.mdc`のガイドラインが自動的に参照され、一貫性のあるコンポーネント設計、状態管理、パフォーマンス最適化、アクセシビリティなどの実践が促進されます。特にページコンポーネント、UIコンポーネント、機能コンポーネント、カスタムフック、コンテキストなど、フロントエンドの中核となる部分に適用されます。

---

_**User**_

次のファイル構造のときに変更がっても対応できるようにフロント・バックのAuto Attachの設定をして。
"""
```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  └─ /config                       # 設定ファイル
      ├─ constants.ts              # 定数定義
      ├─ routes.ts                 # ルート定義
      └─ ...
```
"""

---

_**Assistant**_

提供されたファイル構造に基づき、将来の変更にも柔軟に対応できるAuto Attach設定を作成します。

### フロントエンド（frontend.mdc）の設定

```json
{
  "name": "frontend",
  "description": "フロントエンド実装上の注意事項",
  "pattern": [
    "src/app/**/*.{tsx,jsx,ts,js}",
    "!src/app/api/**/*",
    "src/components/**/*.{tsx,jsx,ts,js}",
    "src/hooks/**/*.{tsx,jsx,ts,js}",
    "src/context/**/*.{tsx,jsx,ts,js}",
    "src/config/**/*.{tsx,jsx,ts,js}",
    "src/types/models/**/*.{ts,js}"
  ],
  "rule": "frontend.mdc"
}
```

この設定の特徴：
- `app`ディレクトリ内のファイルを対象としますが、`app/api`は除外（バックエンド担当）
- UIコンポーネント、レイアウト、機能コンポーネント、パターンを含む
- フロントエンド関連のフック、コンテキスト、設定ファイルをカバー
- モデル関連の型定義も含める（フロントエンドでの表示に関連）
- 将来追加される可能性のあるディレクトリ構造にも対応できるよう、ワイルドカードを使用

### バックエンド（backend.mdc）の設定

```json
{
  "name": "backend",
  "description": "バックエンド実装上の注意事項",
  "pattern": [
    "src/app/api/**/*.{tsx,jsx,ts,js}",
    "src/lib/**/*.{tsx,jsx,ts,js}",
    "src/types/api/**/*.{ts,js}",
    "src/middleware/**/*.{ts,js}",
    "prisma/**/*.{ts,js,prisma}"
  ],
  "rule": "backend.mdc"
}
```

この設定の特徴：
- `app/api`ディレクトリ内のすべてのファイルを対象（API Routes）
- `lib`ディレクトリ内のファイル（サービス、リポジトリ、ユーティリティなど）
- API関連の型定義
- ミドルウェア関連のファイル
- Prismaスキーマやマイグレーションファイル（将来追加される可能性あり）
- 将来的なバックエンド関連の拡張にも対応できるよう、広めのパターンを設定

### 共通設定（両方に適用）

特定のファイルが両方のルールの対象になる可能性がある場合（例：共通ユーティリティなど）、以下のような追加設定も検討できます：

```json
{
  "name": "common",
  "description": "フロントエンドとバックエンド共通の実装注意事項",
  "pattern": [
    "src/utils/**/*.{tsx,jsx,ts,js}",
    "src/config/constants.ts",
    "src/types/common/**/*.{ts,js}"
  ],
  "rule": ["frontend.mdc", "backend.mdc"]
}
```

これにより、共通のユーティリティや定数、型定義には両方のルールが適用され、フロントエンドとバックエンドの両方の観点から実装を検討できます。

これらの設定は、将来的なディレクトリ構造の変更や新しいファイルの追加にも柔軟に対応できるよう、包括的なパターンを使用しています。必要に応じて、特定のディレクトリやファイルを除外（`!pattern`）することも可能です。

---



---

