<!-- Generated by SpecStory -->

# frontend.mdc コード記述の方針とサンプル (2025-03-17 05:41:49)

_**User**_

frontend.mdc コードの記述の仕方で100人中100人が同じような実装を出来るように、記述方法の方針やサンプルを追記して。

---

_**Assistant**_

まず、frontend.mdcファイルの内容を確認して、現在の記述方法の方針やサンプルを把握しましょう。

---

<details>
            <summary>Searched codebase "frontend.mdc" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: /Users/dm/dev/dev/DigeClip/.cursor/rules/frontend.mdc

---

ファイルの内容を確認したところ、frontend.mdcには既に多くの情報が含まれていますが、記述方法の方針やサンプルをより具体的に追記して、100人中100人が同じような実装ができるようにしましょう。

---

```diff
    - axe-coreやWAVE等のツールで自動チェック
    - キーボード操作のみでの全機能検証
+ 
+ ## コード記述の統一ガイドライン
+ 
+ このセクションでは、コードの記述方法を統一し、100人中100人が同じような実装ができるようにするための具体的なガイドラインとサンプルを提供します。
+ 
+ ### コンポーネントの記述方法
+ 
+ #### 基本構造
+ 
+ すべてのReactコンポーネントは以下の構造に従って記述してください：
+ 
+ ```tsx
+ // 1. インポート（アルファベット順に整理）
+ import { useState, useEffect } from 'react';
+ import { useRouter } from 'next/router';
+ import { Button } from '@/components/ui/Button';
+ 
+ // 2. 型定義
+ type ComponentProps = {
+   title: string;
+   description?: string;
+   onAction: (id: string) => void;
+ };
+ 
+ // 3. コンポーネント定義（アロー関数を使用）
+ const Component = ({ title, description = '', onAction }: ComponentProps) => {
+   // 3.1 フック（useState, useEffectなど）
+   const [isOpen, setIsOpen] = useState(false);
+   const router = useRouter();
+   
+   // 3.2 副作用
+   useEffect(() => {
+     // 副作用の処理
+     return () => {
+       // クリーンアップ処理
+     };
+   }, []);
+   
+   // 3.3 イベントハンドラー
+   const handleClick = () => {
+     setIsOpen(!isOpen);
+     onAction('example-id');
+   };
+   
+   // 3.4 条件付きレンダリングのための変数
+   const displayDescription = description.length > 0;
+   
+   // 3.5 JSX返却
+   return (
+     <div className="p-4 bg-white rounded shadow">
+       <h2 className="text-xl font-bold">{title}</h2>
+       {displayDescription && <p className="mt-2 text-gray-600">{description}</p>}
+       <Button onClick={handleClick} className="mt-4">
+         {isOpen ? '閉じる' : '開く'}
+       </Button>
+     </div>
+   );
+ };
+ 
+ // 4. エクスポート
+ export default Component;
+ ```
+ 
+ #### コンポーネントファイルの構成
+ 
+ コンポーネントファイルは以下の構成に従ってください：
+ 
+ 1. 単一責任の原則に従い、1ファイルにつき1コンポーネント
+ 2. 関連する小さなヘルパーコンポーネントは同じファイル内に定義可能
+ 3. ファイル名はコンポーネント名と一致させる（例：`Button.tsx`）
+ 
+ ### カスタムフックの記述方法
+ 
+ カスタムフックは以下の構造に従って記述してください：
+ 
+ ```tsx
+ // 1. インポート
+ import { useState, useEffect } from 'react';
+ import { fetchData } from '@/lib/api';
+ 
+ // 2. 型定義
+ type UseDataResult = {
+   data: any[] | null;
+   loading: boolean;
+   error: Error | null;
+   refetch: () => Promise<void>;
+ };
+ 
+ type UseDataParams = {
+   initialQuery?: string;
+   limit?: number;
+ };
+ 
+ // 3. フック定義（use接頭辞を使用）
+ export const useData = ({ initialQuery = '', limit = 10 }: UseDataParams = {}): UseDataResult => {
+   // 3.1 状態管理
+   const [data, setData] = useState<any[] | null>(null);
+   const [loading, setLoading] = useState<boolean>(true);
+   const [error, setError] = useState<Error | null>(null);
+   const [query, setQuery] = useState<string>(initialQuery);
+   
+   // 3.2 データ取得関数
+   const fetchDataFromApi = async () => {
+     try {
+       setLoading(true);
+       setError(null);
+       const result = await fetchData(query, limit);
+       setData(result);
+     } catch (err) {
+       setError(err instanceof Error ? err : new Error('Unknown error occurred'));
+     } finally {
+       setLoading(false);
+     }
+   };
+   
+   // 3.3 副作用
+   useEffect(() => {
+     fetchDataFromApi();
+   }, [query, limit]);
+   
+   // 3.4 公開関数
+   const refetch = async () => {
+     await fetchDataFromApi();
+   };
+   
+   // 3.5 返却値（オブジェクト形式）
+   return {
+     data,
+     loading,
+     error,
+     refetch
+   };
+ };
+ ```
+ 
+ ### ユーティリティ関数の記述方法
+ 
+ ユーティリティ関数は以下の構造に従って記述してください：
+ 
+ ```ts
+ // 1. 型定義（必要な場合）
+ type FormatOptions = {
+   locale?: string;
+   currency?: string;
+ };
+ 
+ /**
+  * 2. JSDoc形式のコメント
+  * 金額をフォーマットする関数
+  * @param amount - フォーマットする金額
+  * @param options - フォーマットオプション
+  * @returns フォーマットされた金額文字列
+  */
+ export const formatCurrency = (
+   amount: number,
+   { locale = 'ja-JP', currency = 'JPY' }: FormatOptions = {}
+ ): string => {
+   return new Intl.NumberFormat(locale, {
+     style: 'currency',
+     currency,
+   }).format(amount);
+ };
+ 
+ /**
+  * 日付をフォーマットする関数
+  * @param date - フォーマットする日付
+  * @param format - 日付フォーマット（省略時はYYYY-MM-DD）
+  * @returns フォーマットされた日付文字列
+  */
+ export const formatDate = (date: Date, format = 'YYYY-MM-DD'): string => {
+   // 実装...
+   return '2023-01-01'; // 例
+ };
+ ```
+ 
+ ### API呼び出しの記述方法
+ 
+ API呼び出しは以下の構造に従って記述してください：
+ 
+ ```ts
+ // 1. インポート
+ import axios from 'axios';
+ import { API_BASE_URL } from '@/config/constants';
+ 
+ // 2. 型定義
+ type User = {
+   id: string;
+   name: string;
+   email: string;
+ };
+ 
+ type CreateUserParams = {
+   name: string;
+   email: string;
+   password: string;
+ };
+ 
+ // 3. API関数
+ /**
+  * ユーザー一覧を取得する
+  * @returns ユーザー一覧
+  */
+ export const getUsers = async (): Promise<User[]> => {
+   try {
+     const response = await axios.get(`${API_BASE_URL}/users`);
+     return response.data;
+   } catch (error) {
+     console.error('Failed to fetch users:', error);
+     throw error;
+   }
+ };
+ 
+ /**
+  * ユーザーを作成する
+  * @param params - ユーザー作成パラメータ
+  * @returns 作成されたユーザー
+  */
+ export const createUser = async (params: CreateUserParams): Promise<User> => {
+   try {
+     const response = await axios.post(`${API_BASE_URL}/users`, params);
+     return response.data;
+   } catch (error) {
+     console.error('Failed to create user:', error);
+     throw error;
+   }
+ };
+ ```
+ 
+ ### 状態管理の記述方法
+ 
+ 状態管理（Zustandなど）は以下の構造に従って記述してください：
+ 
+ ```ts
+ // 1. インポート
+ import { create } from 'zustand';
+ 
+ // 2. 型定義
+ type TodoItem = {
+   id: string;
+   text: string;
+   completed: boolean;
+ };
+ 
+ type TodoState = {
+   todos: TodoItem[];
+   loading: boolean;
+   error: string | null;
+ };
+ 
+ type TodoActions = {
+   addTodo: (text: string) => void;
+   toggleTodo: (id: string) => void;
+   removeTodo: (id: string) => void;
+   fetchTodos: () => Promise<void>;
+ };
+ 
+ // 3. ストア定義
+ export const useTodoStore = create<TodoState & TodoActions>((set, get) => ({
+   // 3.1 初期状態
+   todos: [],
+   loading: false,
+   error: null,
+   
+   // 3.2 アクション
+   addTodo: (text: string) => {
+     const newTodo: TodoItem = {
+       id: Date.now().toString(),
+       text,
+       completed: false,
+     };
+     set((state) => ({
+       todos: [...state.todos, newTodo],
+     }));
+   },
+   
+   toggleTodo: (id: string) => {
+     set((state) => ({
+       todos: state.todos.map((todo) =>
+         todo.id === id ? { ...todo, completed: !todo.completed } : todo
+       ),
+     }));
+   },
+   
+   removeTodo: (id: string) => {
+     set((state) => ({
+       todos: state.todos.filter((todo) => todo.id !== id),
+     }));
+   },
+   
+   fetchTodos: async () => {
+     try {
+       set({ loading: true, error: null });
+       // API呼び出しなど
+       const response = await fetch('/api/todos');
+       const data = await response.json();
+       set({ todos: data, loading: false });
+     } catch (error) {
+       set({
+         error: error instanceof Error ? error.message : '不明なエラーが発生しました',
+         loading: false,
+       });
+     }
+   },
+ }));
+ ```
+ 
+ ### テストの記述方法
+ 
+ テストは以下の構造に従って記述してください：
+ 
+ ```tsx
+ // 1. インポート
+ import { render, screen, fireEvent } from '@testing-library/react';
+ import userEvent from '@testing-library/user-event';
+ import Button from './Button';
+ 
+ // 2. テストスイート
+ describe('Button Component', () => {
+   // 2.1 個別テスト
+   it('renders correctly with default props', () => {
+     // 準備
+     render(<Button>Click me</Button>);
+     
+     // 実行
+     const button = screen.getByRole('button', { name: /click me/i });
+     
+     // 検証
+     expect(button).toBeInTheDocument();
+     expect(button).not.toBeDisabled();
+   });
+   
+   it('calls onClick handler when clicked', async () => {
+     // 準備
+     const handleClick = jest.fn();
+     render(<Button onClick={handleClick}>Click me</Button>);
+     
+     // 実行
+     const button = screen.getByRole('button', { name: /click me/i });
+     await userEvent.click(button);
+     
+     // 検証
+     expect(handleClick).toHaveBeenCalledTimes(1);
+   });
+   
+   it('renders as disabled when disabled prop is true', () => {
+     // 準備
+     render(<Button disabled>Click me</Button>);
+     
+     // 実行
+     const button = screen.getByRole('button', { name: /click me/i });
+     
+     // 検証
+     expect(button).toBeDisabled();
+   });
+ });
+ ```
+ 
+ ### コードレビューチェックリスト
+ 
+ コードレビュー時には以下の点を確認してください：
+ 
+ 1. **命名規則の遵守**
+    - コンポーネント: PascalCase
+    - 変数/関数: camelCase
+    - 定数: UPPER_SNAKE_CASE
+ 
+ 2. **コードの構造**
+    - インポートは適切に整理されているか
+    - 型定義は明確か
+    - 関数の責務は単一か
+ 
+ 3. **パフォーマンス**
+    - 不要な再レンダリングはないか
+    - メモ化は適切に使用されているか
+    - 大きなリストにはバーチャライゼーションが適用されているか
+ 
+ 4. **エラーハンドリング**
+    - try/catchが適切に使用されているか
+    - エラーメッセージはユーザーフレンドリーか
+ 
+ 5. **アクセシビリティ**
+    - セマンティックなHTML要素が使用されているか
+    - ARIA属性は適切に設定されているか
+    - キーボード操作に対応しているか
+ 
+ これらのガイドラインに従うことで、チーム全体で一貫性のあるコードを作成し、メンテナンス性と可読性を向上させることができます。
```

---

frontend.mdcファイルに「コード記述の統一ガイドライン」セクションを追加しました。このセクションでは、100人中100人が同じような実装ができるように、具体的なコード記述の方針とサンプルを提供しています。

追加した内容の概要：

1. **コンポーネントの記述方法**
   - 基本構造（インポート、型定義、コンポーネント定義、エクスポート）
   - ファイル構成のルール

2. **カスタムフックの記述方法**
   - 構造化されたフックの実装例
   - 状態管理、データ取得、副作用の扱い方

3. **ユーティリティ関数の記述方法**
   - JSDoc形式のコメント
   - 型定義と関数実装の例

4. **API呼び出しの記述方法**
   - 一貫した構造でのAPI関数実装
   - エラーハンドリングの統一

5. **状態管理の記述方法**
   - Zustandを使った状態管理の例
   - アクションと状態の分離

6. **テストの記述方法**
   - テストスイートの構造
   - 準備・実行・検証の3ステップ

7. **コードレビューチェックリスト**
   - 命名規則
   - コード構造
   - パフォーマンス
   - エラーハンドリング
   - アクセシビリティ

これらのガイドラインに従うことで、チーム全体で一貫性のあるコードを作成し、メンテナンス性と可読性を向上させることができます。各開発者が同じ方針でコードを書くことで、コードベースの統一性が保たれ、新しいメンバーの参加時にも素早く適応できるようになります。

---



---

