<!-- Generated by SpecStory -->

# GitHub Issues Retrieval and Modification (2025-03-16 15:36:05)

_**User**_

githubのissuesをすべて取得して。すべての要件定義の内容を満たすための内容に修正したい。


---

_**Assistant**_

GitHub Issuesを取得するために、まずプロジェクトの構造を確認しましょう。

---

<details>
            <summary>Listed current directory • **6** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📁 `Requirements_Format` |
| 📁 `Requirements` |
| 📁 `.cursor` |
| 📄 `changes.diff` |
| 📄 `README.md` |

</details>

---

要件定義の内容を確認するために、Requirementsディレクトリの内容を見てみましょう。

---

<details>
            <summary>Listed directory Requirements • **10** results</summary>
        
| Name |
|-------|
| 📁 `2_Functional_Requirements` |
| 📄 `requirements-overview.md` |
| 📄 `README.md` |
| 📄 `Requirements_Index.md` |
| 📄 `System_Development_Requirements.md` |
| 📁 `5_Risk_and_Release_Plan` |
| 📁 `6_Summary` |
| 📁 `4_Development_Process` |
| 📁 `3_NonFunctional_Requirements` |
| 📁 `1_Business_Requirements` |

</details>

---

まず、要件の概要を確認しましょう。

---

Read file: Requirements/requirements-overview.md

---

次に、機能要件を確認しましょう。

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements • **3** results</summary>
        
| Name |
|-------|
| 📁 `backend` |
| 📁 `frontend` |
| 📁 `data` |

</details>

---

バックエンドとフロントエンドの要件を確認しましょう。

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/backend • **7** results</summary>
        
| Name |
|-------|
| 📄 `3_API_Design.md` |
| 📄 `4_External_Integration.md` |
| 📄 `2_Technology_Stack.md` |
| 📄 `1_Architecture_Overview.md` |
| 📄 `0_Common_Requirements.md` |
| 📄 `5_Implementation_Patterns.md` |
| 📁 `api` |

</details>

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements/frontend • **8** results</summary>
        
| Name |
|-------|
| 📄 `1_Screen_List_and_Transitions.md` |
| 📄 `2_Feature_Details.md` |
| 📄 `3_Frontend_Technology_Stack.md` |
| 📁 `components` |
| 📄 `0_Common_Requirements.md` |
| 📁 `pages` |
| 📁 `types` |
| 📁 `screens` |

</details>

---

次に、現在のプロジェクトコードを確認しましょう。まず、プロジェクトのルートディレクトリにあるファイルを確認します。

---

Read file: README.md

---

GitHub Issuesを取得するためのコードを作成する必要があります。まず、必要なディレクトリ構造を作成しましょう。

---

```bash
mkdir -p src/github
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

次に、GitHub APIを使用してIssuesを取得するためのスクリプトを作成します。

---

```diff
- 
+ #!/usr/bin/env python3
+ # -*- coding: utf-8 -*-
+ 
+ import os
+ import requests
+ import json
+ from datetime import datetime
+ import argparse
+ 
+ class GitHubIssuesFetcher:
+     """GitHubのIssuesを取得するクラス"""
+ 
+     def __init__(self, owner, repo, token=None):
+         """
+         初期化
+ 
+         Args:
+             owner (str): リポジトリのオーナー名
+             repo (str): リポジトリ名
+             token (str, optional): GitHub Personal Access Token
+         """
+         self.owner = owner
+         self.repo = repo
+         self.token = token or os.environ.get('GITHUB_TOKEN')
+         self.base_url = f"https://api.github.com/repos/{owner}/{repo}"
+         self.headers = {
+             'Accept': 'application/vnd.github.v3+json'
+         }
+         if self.token:
+             self.headers['Authorization'] = f'token {self.token}'
+ 
+     def fetch_all_issues(self, state='all', per_page=100):
+         """
+         すべてのIssuesを取得
+ 
+         Args:
+             state (str): 'open', 'closed', 'all'のいずれか
+             per_page (int): 1ページあたりの取得数
+ 
+         Returns:
+             list: Issuesのリスト
+         """
+         issues = []
+         page = 1
+ 
+         while True:
+             url = f"{self.base_url}/issues"
+             params = {
+                 'state': state,
+                 'per_page': per_page,
+                 'page': page,
+                 'sort': 'created',
+                 'direction': 'desc'
+             }
+ 
+             response = requests.get(url, headers=self.headers, params=params)
+ 
+             if response.status_code != 200:
+                 print(f"エラー: {response.status_code}")
+                 print(response.text)
+                 break
+ 
+             page_issues = response.json()
+ 
+             if not page_issues:
+                 break
+ 
+             # Pull Requestsを除外
+             page_issues = [issue for issue in page_issues if 'pull_request' not in issue]
+ 
+             issues.extend(page_issues)
+             page += 1
+ 
+             # レート制限の確認
+             if int(response.headers.get('X-RateLimit-Remaining', 1)) < 1:
+                 reset_time = int(response.headers.get('X-RateLimit-Reset', 0))
+                 reset_datetime = datetime.fromtimestamp(reset_time)
+                 print(f"API制限に達しました。リセット時間: {reset_datetime}")
+                 break
+ 
+         return issues
+ 
+     def save_issues_to_file(self, issues, output_file='github_issues.json'):
+         """
+         取得したIssuesをJSONファイルに保存
+ 
+         Args:
+             issues (list): Issuesのリスト
+             output_file (str): 出力ファイル名
+         """
+         with open(output_file, 'w', encoding='utf-8') as f:
+             json.dump(issues, f, ensure_ascii=False, indent=2)
+ 
+         print(f"{len(issues)}件のIssuesを{output_file}に保存しました。")
+ 
+     def print_issues_summary(self, issues):
+         """
+         Issuesの概要を表示
+ 
+         Args:
+             issues (list): Issuesのリスト
+         """
+         print(f"\n合計 {len(issues)} 件のIssuesが見つかりました。\n")
+ 
+         for i, issue in enumerate(issues, 1):
+             created_at = datetime.strptime(issue['created_at'], '%Y-%m-%dT%H:%M:%SZ')
+             formatted_date = created_at.strftime('%Y-%m-%d %H:%M:%S')
+ 
+             print(f"{i}. #{issue['number']} {issue['title']}")
+             print(f"   作成日: {formatted_date}")
+             print(f"   状態: {issue['state']}")
+             print(f"   URL: {issue['html_url']}")
+             print()
+ 
+ 
+ def main():
+     """メイン関数"""
+     parser = argparse.ArgumentParser(description='GitHubのIssuesを取得するスクリプト')
+     parser.add_argument('--owner', required=True, help='リポジトリのオーナー名')
+     parser.add_argument('--repo', required=True, help='リポジトリ名')
+     parser.add_argument('--token', help='GitHub Personal Access Token')
+     parser.add_argument('--state', default='all', choices=['open', 'closed', 'all'],
+                         help='取得するIssuesの状態 (デフォルト: all)')
+     parser.add_argument('--output', default='github_issues.json',
+                         help='出力ファイル名 (デフォルト: github_issues.json)')
+ 
+     args = parser.parse_args()
+ 
+     fetcher = GitHubIssuesFetcher(args.owner, args.repo, args.token)
+     issues = fetcher.fetch_all_issues(state=args.state)
+ 
+     if issues:
+         fetcher.print_issues_summary(issues)
+         fetcher.save_issues_to_file(issues, args.output)
+     else:
+         print("Issuesが見つかりませんでした。")
+ 
+ 
+ if __name__ == "__main__":
+     main()
```

---

次に、取得したIssuesを要件定義に合わせて分析するためのスクリプトを作成します。

---

```diff
- 
+ #!/usr/bin/env python3
+ # -*- coding: utf-8 -*-
+ 
+ import json
+ import argparse
+ import os
+ from datetime import datetime
+ import re
+ import csv
+ 
+ class IssueAnalyzer:
+     """GitHubのIssuesを分析するクラス"""
+ 
+     def __init__(self, issues_file):
+         """
+         初期化
+ 
+         Args:
+             issues_file (str): Issuesが保存されたJSONファイルのパス
+         """
+         self.issues_file = issues_file
+         self.issues = self._load_issues()
+         self.categories = {
+             'business': '1_Business_Requirements',
+             'functional': '2_Functional_Requirements',
+             'nonfunctional': '3_NonFunctional_Requirements',
+             'process': '4_Development_Process',
+             'risk': '5_Risk_and_Release_Plan',
+             'summary': '6_Summary'
+         }
+ 
+     def _load_issues(self):
+         """
+         Issuesをロード
+ 
+         Returns:
+             list: Issuesのリスト
+         """
+         try:
+             with open(self.issues_file, 'r', encoding='utf-8') as f:
+                 return json.load(f)
+         except FileNotFoundError:
+             print(f"エラー: ファイル '{self.issues_file}' が見つかりません。")
+             return []
+         except json.JSONDecodeError:
+             print(f"エラー: ファイル '{self.issues_file}' の形式が不正です。")
+             return []
+ 
+     def categorize_issues(self):
+         """
+         Issuesをカテゴリ別に分類
+ 
+         Returns:
+             dict: カテゴリ別のIssuesリスト
+         """
+         categorized = {category: [] for category in self.categories.keys()}
+         uncategorized = []
+ 
+         for issue in self.issues:
+             category_found = False
+ 
+             # ラベルからカテゴリを判断
+             for label in issue.get('labels', []):
+                 label_name = label['name'].lower()
+ 
+                 for category in self.categories.keys():
+                     if category in label_name:
+                         categorized[category].append(issue)
+                         category_found = True
+                         break
+ 
+                 if category_found:
+                     break
+ 
+             # タイトルからカテゴリを判断（ラベルで見つからなかった場合）
+             if not category_found:
+                 title = issue['title'].lower()
+ 
+                 for category in self.categories.keys():
+                     if category in title or self.categories[category].lower() in title:
+                         categorized[category].append(issue)
+                         category_found = True
+                         break
+ 
+             # カテゴリが見つからなかった場合
+             if not category_found:
+                 uncategorized.append(issue)
+ 
+         # 未分類のIssuesを「機能要件」に分類
+         if uncategorized:
+             categorized['functional'].extend(uncategorized)
+ 
+         return categorized
+ 
+     def generate_requirements_markdown(self, output_dir='Requirements'):
+         """
+         要件定義のマークダウンファイルを生成
+ 
+         Args:
+             output_dir (str): 出力ディレクトリ
+         """
+         categorized_issues = self.categorize_issues()
+ 
+         for category, issues in categorized_issues.items():
+             if not issues:
+                 continue
+ 
+             category_dir = os.path.join(output_dir, self.categories[category])
+             os.makedirs(category_dir, exist_ok=True)
+ 
+             # カテゴリ別のファイル名を決定
+             filename = f"{category}_requirements.md"
+             filepath = os.path.join(category_dir, filename)
+ 
+             with open(filepath, 'w', encoding='utf-8') as f:
+                 # ヘッダー
+                 f.write(f"# {self.categories[category].replace('_', ' ')}\n\n")
+                 f.write(f"*生成日時: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n")
+                 f.write("*このドキュメントはGitHub Issuesから自動生成されました*\n\n")
+ 
+                 # 目次
+                 f.write("## 目次\n\n")
+                 for i, issue in enumerate(issues, 1):
+                     f.write(f"{i}. [{issue['title']}](#{self._create_anchor(issue['title'])})\n")
+                 f.write("\n")
+ 
+                 # 各Issueの詳細
+                 f.write("## 詳細\n\n")
+                 for issue in issues:
+                     f.write(f"### {issue['title']}\n\n")
+                     f.write(f"**Issue番号**: #{issue['number']}\n\n")
+                     f.write(f"**状態**: {issue['state']}\n\n")
+                     f.write(f"**作成日**: {datetime.strptime(issue['created_at'], '%Y-%m-%dT%H:%M:%SZ').strftime('%Y-%m-%d')}\n\n")
+ 
+                     # ラベル
+                     if issue.get('labels'):
+                         f.write("**ラベル**: ")
+                         labels = [label['name'] for label in issue['labels']]
+                         f.write(", ".join(labels))
+                         f.write("\n\n")
+ 
+                     # 本文
+                     if issue.get('body'):
+                         f.write("**詳細**:\n\n")
+                         f.write(issue['body'])
+                         f.write("\n\n")
+ 
+                     f.write(f"**URL**: {issue['html_url']}\n\n")
+                     f.write("---\n\n")
+ 
+             print(f"{filepath} を生成しました。")
+ 
+     def _create_anchor(self, text):
+         """
+         マークダウンのアンカーリンク用のテキストを生成
+ 
+         Args:
+             text (str): 元のテキスト
+ 
+         Returns:
+             str: アンカーリンク用のテキスト
+         """
+         # 小文字に変換し、スペースをハイフンに置き換え、英数字とハイフン以外を削除
+         anchor = text.lower().replace(' ', '-')
+         anchor = re.sub(r'[^a-z0-9\-]', '', anchor)
+         return anchor
+ 
+     def export_to_csv(self, output_file='github_issues.csv'):
+         """
+         Issuesをカテゴリ別にCSVファイルにエクスポート
+ 
+         Args:
+             output_file (str): 出力ファイル名
+         """
+         categorized_issues = self.categorize_issues()
+ 
+         with open(output_file, 'w', encoding='utf-8', newline='') as f:
+             writer = csv.writer(f)
+             writer.writerow(['カテゴリ', 'Issue番号', 'タイトル', '状態', '作成日', 'URL'])
+ 
+             for category, issues in categorized_issues.items():
+                 category_name = self.categories[category].replace('_', ' ')
+ 
+                 for issue in issues:
+                     created_at = datetime.strptime(issue['created_at'], '%Y-%m-%dT%H:%M:%SZ').strftime('%Y-%m-%d')
+                     writer.writerow([
+                         category_name,
+                         issue['number'],
+                         issue['title'],
+                         issue['state'],
+                         created_at,
+                         issue['html_url']
+                     ])
+ 
+         print(f"{output_file} を生成しました。")
+ 
+ 
+ def main():
+     """メイン関数"""
+     parser = argparse.ArgumentParser(description='GitHubのIssuesを分析するスクリプト')
+     parser.add_argument('--input', default='github_issues.json',
+                         help='入力ファイル名 (デフォルト: github_issues.json)')
+     parser.add_argument('--output-dir', default='Requirements',
+                         help='出力ディレクトリ (デフォルト: Requirements)')
+     parser.add_argument('--csv', default='github_issues.csv',
+                         help='CSVファイル名 (デフォルト: github_issues.csv)')
+ 
+     args = parser.parse_args()
+ 
+     analyzer = IssueAnalyzer(args.input)
+     analyzer.generate_requirements_markdown(args.output_dir)
+     analyzer.export_to_csv(args.csv)
+ 
+ 
+ if __name__ == "__main__":
+     main()
```

---

最後に、これらのスクリプトを実行するためのメインスクリプトを作成します。

---

```diff
- 
+ #!/usr/bin/env python3
+ # -*- coding: utf-8 -*-
+ 
+ import argparse
+ import os
+ from fetch_issues import GitHubIssuesFetcher
+ from analyze_issues import IssueAnalyzer
+ 
+ def main():
+     """
+     GitHubのIssuesを取得して分析するメイン関数
+     """
+     parser = argparse.ArgumentParser(description='GitHubのIssuesを取得して要件定義に変換するスクリプト')
+     parser.add_argument('--owner', required=True, help='リポジトリのオーナー名')
+     parser.add_argument('--repo', required=True, help='リポジトリ名')
+     parser.add_argument('--token', help='GitHub Personal Access Token')
+     parser.add_argument('--state', default='all', choices=['open', 'closed', 'all'],
+                         help='取得するIssuesの状態 (デフォルト: all)')
+     parser.add_argument('--output-json', default='github_issues.json',
+                         help='JSONファイル名 (デフォルト: github_issues.json)')
+     parser.add_argument('--output-csv', default='github_issues.csv',
+                         help='CSVファイル名 (デフォルト: github_issues.csv)')
+     parser.add_argument('--output-dir', default='Requirements',
+                         help='出力ディレクトリ (デフォルト: Requirements)')
+     parser.add_argument('--skip-fetch', action='store_true',
+                         help='Issuesの取得をスキップして分析のみ行う')
+ 
+     args = parser.parse_args()
+ 
+     # Issuesの取得
+     if not args.skip_fetch:
+         print("GitHubからIssuesを取得しています...")
+         fetcher = GitHubIssuesFetcher(args.owner, args.repo, args.token)
+         issues = fetcher.fetch_all_issues(state=args.state)
+ 
+         if issues:
+             fetcher.print_issues_summary(issues)
+             fetcher.save_issues_to_file(issues, args.output_json)
+         else:
+             print("Issuesが見つかりませんでした。")
+             return
+ 
+     # Issuesの分析
+     print("\nIssuesを分析しています...")
+     analyzer = IssueAnalyzer(args.output_json)
+     analyzer.generate_requirements_markdown(args.output_dir)
+     analyzer.export_to_csv(args.output_csv)
+ 
+     print("\n処理が完了しました。")
+     print(f"- JSONファイル: {args.output_json}")
+     print(f"- CSVファイル: {args.output_csv}")
+     print(f"- 要件定義ファイル: {args.output_dir}/<カテゴリ>/<ファイル名>")
+ 
+ 
+ if __name__ == "__main__":
+     main()
```

---

最後に、requirements.txtファイルを作成して必要なパッケージを記述します。

---

```diff
- 
+ requests>=2.28.0
+ argparse>=1.4.0
```

---

READMEファイルを更新して、使用方法を記述します。

---

```diff
  # DigeClip
+ 
+ ## GitHub Issuesを要件定義に変換するツール
+ 
+ このツールは、GitHubのIssuesを取得して要件定義ドキュメントに変換するためのものです。
+ 
+ ### 機能
+ 
+ - GitHubのIssuesをAPIを使用して取得
+ - Issuesをカテゴリ別に分類
+ - 要件定義のマークダウンファイルを生成
+ - CSVファイルにエクスポート
+ 
+ ### 必要条件
+ 
+ - Python 3.6以上
+ - 必要なパッケージ（requirements.txtに記載）
+ 
+ ### インストール方法
+ 
+ ```bash
+ # リポジトリをクローン
+ git clone https://github.com/yourusername/DigeClip.git
+ cd DigeClip
+ 
+ # 依存パッケージをインストール
+ pip install -r requirements.txt
+ ```
+ 
+ ### 使用方法
+ 
+ ```bash
+ # GitHubのIssuesを取得して要件定義に変換
+ python src/github/main.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]
+ 
+ # 詳細なオプション
+ python src/github/main.py --help
+ ```
+ 
+ #### オプション
+ 
+ - `--owner`: リポジトリのオーナー名（必須）
+ - `--repo`: リポジトリ名（必須）
+ - `--token`: GitHub Personal Access Token（オプション、環境変数 `GITHUB_TOKEN` でも設定可能）
+ - `--state`: 取得するIssuesの状態（'open', 'closed', 'all'、デフォルト: 'all'）
+ - `--output-json`: JSONファイル名（デフォルト: 'github_issues.json'）
+ - `--output-csv`: CSVファイル名（デフォルト: 'github_issues.csv'）
+ - `--output-dir`: 出力ディレクトリ（デフォルト: 'Requirements'）
+ - `--skip-fetch`: Issuesの取得をスキップして分析のみ行う
+ 
+ ### 出力ファイル
+ 
+ - `github_issues.json`: 取得したIssuesのJSONファイル
+ - `github_issues.csv`: Issuesをカテゴリ別にまとめたCSVファイル
+ - `Requirements/<カテゴリ>/<ファイル名>`: 要件定義のマークダウンファイル
+ 
+ ### カテゴリ
+ 
+ Issuesは以下のカテゴリに分類されます：
+ 
+ 1. ビジネス要件（1_Business_Requirements）
+ 2. 機能要件（2_Functional_Requirements）
+ 3. 非機能要件（3_NonFunctional_Requirements）
+ 4. 開発プロセス（4_Development_Process）
+ 5. リスクとリリース計画（5_Risk_and_Release_Plan）
+ 6. 要約（6_Summary）
+ 
+ ### 注意事項
+ 
+ - GitHub APIの利用制限に注意してください
+ - 大量のIssuesを取得する場合は、時間がかかる場合があります
+ - 認証トークンを使用することで、API制限を緩和できます
  
```

---

最後に、スクリプトを実行可能にします。

---

```bash
chmod +x src/github/fetch_issues.py src/github/analyze_issues.py src/github/main.py
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

これで、GitHubのIssuesを取得して要件定義に変換するためのツールが完成しました。以下に使用方法をまとめます。

---

```bash
python src/github/main.py --help
```

```
dify-api-py3.11ommp2021:DigeClip dm$ python src/github/main.py --help
usage: main.py [-h] --owner OWNER --repo REPO [--token TOKEN] [--state {open,closed,all}]
               [--output-json OUTPUT_JSON] [--output-csv OUTPUT_CSV] [--output-dir OUTPUT_DIR] [--skip-fetch]

GitHubのIssuesを取得して要件定義に変換するスクリプト

options:
  -h, --help            show this help message and exit
  --owner OWNER         リポジトリのオーナー名
  --repo REPO           リポジトリ名
  --token TOKEN         GitHub Personal Access Token
  --state {open,closed,all}
                        取得するIssuesの状態 (デフォルト: all)
  --output-json OUTPUT_JSON
                        JSONファイル名 (デフォルト: github_issues.json)
  --output-csv OUTPUT_CSV
                        CSVファイル名 (デフォルト: github_issues.csv)
  --output-dir OUTPUT_DIR
                        出力ディレクトリ (デフォルト: Requirements)
  --skip-fetch          Issuesの取得をスキップして分析のみ行う
dify-api-py3.11ommp2021:DigeClip dm$
```

---

## 完成したツールの概要

GitHubのIssuesを取得して要件定義に変換するツールが完成しました。このツールは以下の機能を提供します：

1. **GitHub Issuesの取得**
   - GitHub APIを使用して指定したリポジトリのIssuesを取得
   - 認証トークンを使用して制限を緩和可能
   - オープン、クローズド、またはすべてのIssuesを取得可能

2. **Issuesの分析と分類**
   - Issuesをカテゴリ別に分類（ビジネス要件、機能要件、非機能要件など）
   - ラベルやタイトルからカテゴリを自動判定

3. **要件定義ドキュメントの生成**
   - カテゴリ別にマークダウン形式の要件定義ドキュメントを生成
   - 目次と詳細情報を含む構造化されたドキュメント
   - CSVファイルへのエクスポート機能

### 使用方法

```bash
# 基本的な使用方法
python src/github/main.py --owner <オーナー名> --repo <リポジトリ名>

# 認証トークンを使用する場合
python src/github/main.py --owner <オーナー名> --repo <リポジトリ名> --token <GitHubトークン>

# オープンなIssuesのみを取得
python src/github/main.py --owner <オーナー名> --repo <リポジトリ名> --state open

# 出力先を指定
python src/github/main.py --owner <オーナー名> --repo <リポジトリ名> --output-dir my_requirements
```

### 出力ファイル

1. **JSONファイル** (github_issues.json)
   - 取得したIssuesの生データ

2. **CSVファイル** (github_issues.csv)
   - カテゴリ、Issue番号、タイトル、状態、作成日、URLを含む

3. **マークダウンファイル** (Requirements/<カテゴリ>/<ファイル名>)
   - カテゴリ別の要件定義ドキュメント
   - 目次と詳細情報を含む

このツールを使用することで、GitHubのIssuesから要件定義ドキュメントを自動生成し、プロジェクトの要件を効率的に管理することができます。

---

_**User**_

@src という構造にすると、本来のDigeClipのNext.jsのコードと干渉してしまいます。DigeClipと干渉しないように変更して。

---

_**Assistant**_

GitHubのIssuesを取得するコードが既存のNext.jsプロジェクトと干渉しないように構造を変更します。

---

```bash
mkdir -p tools/github
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

次に、既存のファイルを新しいディレクトリ構造に移動します。

---

```bash
cp src/github/fetch_issues.py tools/github/ && cp src/github/analyze_issues.py tools/github/ && cp src/github/main.py tools/github/
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

main.pyファイルのインポートパスを修正します。

---

```diff
  import argparse
  import os
+ import sys
+ 
+ # 現在のディレクトリをパスに追加
+ sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+ 
  from fetch_issues import GitHubIssuesFetcher
  from analyze_issues import IssueAnalyzer
```

---

READMEファイルを更新して、新しいディレクトリ構造を反映させます。

---

```diff
  ```bash
  # GitHubのIssuesを取得して要件定義に変換
- python src/github/main.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]
+ python tools/github/main.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]
  
  # 詳細なオプション
- python src/github/main.py --help
+ python tools/github/main.py --help
  ```
  
```

---

スクリプトを実行可能にします。

---

```bash
chmod +x tools/github/fetch_issues.py tools/github/analyze_issues.py tools/github/main.py
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

最後に、古いディレクトリを削除します。

---

```bash
rm -rf src
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

新しいディレクトリ構造が正しく設定されているか確認します。

---

```bash
ls -la tools/github/
```

```
dify-api-py3.11ommp2021:DigeClip dm$ ls -la tools/github/
total 40
drwxr-xr-x  5 dm  staff   160  3 16 15:43 .
drwxr-xr-x  3 dm  staff    96  3 16 15:43 ..
-rwxr-xr-x  1 dm  staff  7847  3 16 15:43 analyze_issues.py
-rwxr-xr-x  1 dm  staff  4654  3 16 15:43 fetch_issues.py
-rwxr-xr-x  1 dm  staff  2542  3 16 15:43 main.py
dify-api-py3.11ommp2021:DigeClip dm$
```

---

ヘルプを表示して、新しいスクリプトが正しく動作するか確認します。

---

```bash
python tools/github/main.py --help
```

```
dify-api-py3.11ommp2021:DigeClip dm$ python tools/github/main.py --help
usage: main.py [-h] --owner OWNER --repo REPO [--token TOKEN] [--state {open,closed,all}]
               [--output-json OUTPUT_JSON] [--output-csv OUTPUT_CSV] [--output-dir OUTPUT_DIR] [--skip-fetch]

GitHubのIssuesを取得して要件定義に変換するスクリプト

options:
  -h, --help            show this help message and exit
  --owner OWNER         リポジトリのオーナー名
  --repo REPO           リポジトリ名
  --token TOKEN         GitHub Personal Access Token
  --state {open,closed,all}
                        取得するIssuesの状態 (デフォルト: all)
  --output-json OUTPUT_JSON
                        JSONファイル名 (デフォルト: github_issues.json)
  --output-csv OUTPUT_CSV
                        CSVファイル名 (デフォルト: github_issues.csv)
  --output-dir OUTPUT_DIR
                        出力ディレクトリ (デフォルト: Requirements)
  --skip-fetch          Issuesの取得をスキップして分析のみ行う
dify-api-py3.11ommp2021:DigeClip dm$
```

---

## 変更内容のまとめ

GitHubのIssuesを取得するコードを既存のNext.jsプロジェクトと干渉しないように、以下の変更を行いました：

1. **ディレクトリ構造の変更**
   - `src/github/` から `tools/github/` に変更
   - Next.jsプロジェクトでは通常 `src` ディレクトリを使用するため、`tools` ディレクトリに移動することで干渉を防止

2. **インポートパスの修正**
   - `main.py` ファイルのインポートパスを修正
   - `sys.path.append` を使用して、現在のディレクトリをパスに追加

3. **READMEの更新**
   - 使用方法の説明を新しいディレクトリ構造に合わせて更新
   - `python src/github/main.py` から `python tools/github/main.py` に変更

4. **実行権限の設定**
   - 新しい場所のスクリプトに実行権限を付与

5. **古いディレクトリの削除**
   - `src` ディレクトリを削除して、Next.jsプロジェクトとの干渉を完全に防止

これらの変更により、GitHubのIssuesを取得するコードが既存のNext.jsプロジェクトと干渉することなく、独立して動作するようになりました。

### 使用方法

```bash
# GitHubのIssuesを取得して要件定義に変換
python tools/github/main.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]

# 詳細なオプション
python tools/github/main.py --help
```

これで、DigeClipのNext.jsプロジェクトと干渉することなく、GitHubのIssuesを取得して要件定義に変換することができます。

---

_**User**_

現在のissuesのタスクを取得して、要件定義が変更したので、変更した要件定義にに合わせてissuesのタスクを変更するということです。内容を理解していないですね。toolsのディレクトリ構造はOKです。

---

_**Assistant**_

すみません、誤解していました。要件定義が変更されたので、GitHubのIssuesを取得して要件定義に合わせて更新するという内容ですね。

---

<details>
            <summary>Listed directory Requirements • **10** results</summary>
        
| Name |
|-------|
| 📁 `2_Functional_Requirements` |
| 📄 `requirements-overview.md` |
| 📄 `README.md` |
| 📄 `Requirements_Index.md` |
| 📄 `System_Development_Requirements.md` |
| 📁 `5_Risk_and_Release_Plan` |
| 📁 `6_Summary` |
| 📁 `4_Development_Process` |
| 📁 `3_NonFunctional_Requirements` |
| 📁 `1_Business_Requirements` |

</details>

---

<details>
            <summary>Listed directory Requirements/2_Functional_Requirements • **3** results</summary>
        
| Name |
|-------|
| 📁 `backend` |
| 📁 `frontend` |
| 📁 `data` |

</details>

---

Read file: Requirements/requirements-overview.md

---

Read file: Requirements/2_Functional_Requirements/backend/1_Architecture_Overview.md

---

Read file: Requirements/2_Functional_Requirements/frontend/1_Screen_List_and_Transitions.md

---

現在のGitHubのIssuesを取得して、更新された要件定義に合わせてIssuesを更新するスクリプトを作成します。まず、GitHubのIssuesを取得するスクリプトを実行できるようにします。

---

```diff
- 
+ #!/usr/bin/env python3
+ # -*- coding: utf-8 -*-
+ 
+ import argparse
+ import os
+ import sys
+ import json
+ import re
+ from datetime import datetime
+ 
+ # 現在のディレクトリをパスに追加
+ sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+ 
+ from fetch_issues import GitHubIssuesFetcher
+ 
+ class IssueUpdater:
+     """GitHubのIssuesを要件定義に合わせて更新するクラス"""
+ 
+     def __init__(self, owner, repo, token=None, requirements_dir='Requirements'):
+         """
+         初期化
+ 
+         Args:
+             owner (str): リポジトリのオーナー名
+             repo (str): リポジトリ名
+             token (str, optional): GitHub Personal Access Token
+             requirements_dir (str): 要件定義ディレクトリ
+         """
+         self.owner = owner
+         self.repo = repo
+         self.token = token
+         self.requirements_dir = requirements_dir
+         self.fetcher = GitHubIssuesFetcher(owner, repo, token)
+         self.issues = []
+         self.requirements = {
+             'business': [],
+             'functional': [],
+             'nonfunctional': [],
+             'process': [],
+             'risk': [],
+             'summary': []
+         }
+ 
+     def fetch_issues(self):
+         """GitHubのIssuesを取得"""
+         print("GitHubからIssuesを取得しています...")
+         self.issues = self.fetcher.fetch_all_issues()
+         if self.issues:
+             self.fetcher.print_issues_summary(self.issues)
+         else:
+             print("Issuesが見つかりませんでした。")
+         return self.issues
+ 
+     def parse_requirements(self):
+         """要件定義ファイルを解析"""
+         print("\n要件定義ファイルを解析しています...")
+ 
+         # ビジネス要件
+         self._parse_business_requirements()
+ 
+         # 機能要件
+         self._parse_functional_requirements()
+ 
+         # 非機能要件
+         self._parse_nonfunctional_requirements()
+ 
+         # 開発プロセス
+         self._parse_process_requirements()
+ 
+         # リスクとリリース計画
+         self._parse_risk_requirements()
+ 
+         # 要約
+         self._parse_summary_requirements()
+ 
+         return self.requirements
+ 
+     def _parse_business_requirements(self):
+         """ビジネス要件を解析"""
+         business_dir = os.path.join(self.requirements_dir, '1_Business_Requirements')
+         if os.path.exists(business_dir):
+             for filename in os.listdir(business_dir):
+                 if filename.endswith('.md'):
+                     filepath = os.path.join(business_dir, filename)
+                     self._parse_markdown_file(filepath, 'business')
+ 
+     def _parse_functional_requirements(self):
+         """機能要件を解析"""
+         functional_dir = os.path.join(self.requirements_dir, '2_Functional_Requirements')
+         if os.path.exists(functional_dir):
+             # バックエンド要件
+             backend_dir = os.path.join(functional_dir, 'backend')
+             if os.path.exists(backend_dir):
+                 for filename in os.listdir(backend_dir):
+                     if filename.endswith('.md'):
+                         filepath = os.path.join(backend_dir, filename)
+                         self._parse_markdown_file(filepath, 'functional', prefix='Backend: ')
+ 
+             # フロントエンド要件
+             frontend_dir = os.path.join(functional_dir, 'frontend')
+             if os.path.exists(frontend_dir):
+                 for filename in os.listdir(frontend_dir):
+                     if filename.endswith('.md'):
+                         filepath = os.path.join(frontend_dir, filename)
+                         self._parse_markdown_file(filepath, 'functional', prefix='Frontend: ')
+ 
+             # データ要件
+             data_dir = os.path.join(functional_dir, 'data')
+             if os.path.exists(data_dir):
+                 for filename in os.listdir(data_dir):
+                     if filename.endswith('.md'):
+                         filepath = os.path.join(data_dir, filename)
+                         self._parse_markdown_file(filepath, 'functional', prefix='Data: ')
+ 
+     def _parse_nonfunctional_requirements(self):
+         """非機能要件を解析"""
+         nonfunctional_dir = os.path.join(self.requirements_dir, '3_NonFunctional_Requirements')
+         if os.path.exists(nonfunctional_dir):
+             for filename in os.listdir(nonfunctional_dir):
+                 if filename.endswith('.md'):
+                     filepath = os.path.join(nonfunctional_dir, filename)
+                     self._parse_markdown_file(filepath, 'nonfunctional')
+ 
+     def _parse_process_requirements(self):
+         """開発プロセス要件を解析"""
+         process_dir = os.path.join(self.requirements_dir, '4_Development_Process')
+         if os.path.exists(process_dir):
+             for filename in os.listdir(process_dir):
+                 if filename.endswith('.md'):
+                     filepath = os.path.join(process_dir, filename)
+                     self._parse_markdown_file(filepath, 'process')
+ 
+     def _parse_risk_requirements(self):
+         """リスクとリリース計画を解析"""
+         risk_dir = os.path.join(self.requirements_dir, '5_Risk_and_Release_Plan')
+         if os.path.exists(risk_dir):
+             for filename in os.listdir(risk_dir):
+                 if filename.endswith('.md'):
+                     filepath = os.path.join(risk_dir, filename)
+                     self._parse_markdown_file(filepath, 'risk')
+ 
+     def _parse_summary_requirements(self):
+         """要約を解析"""
+         summary_dir = os.path.join(self.requirements_dir, '6_Summary')
+         if os.path.exists(summary_dir):
+             for filename in os.listdir(summary_dir):
+                 if filename.endswith('.md'):
+                     filepath = os.path.join(summary_dir, filename)
+                     self._parse_markdown_file(filepath, 'summary')
+ 
+     def _parse_markdown_file(self, filepath, category, prefix=''):
+         """マークダウンファイルを解析して要件を抽出"""
+         try:
+             with open(filepath, 'r', encoding='utf-8') as f:
+                 content = f.read()
+ 
+                 # ファイル名から要件タイプを取得
+                 filename = os.path.basename(filepath)
+                 req_type = os.path.splitext(filename)[0].replace('_', ' ')
+ 
+                 # 見出しを抽出
+                 headings = re.findall(r'^##\s+(.+)$', content, re.MULTILINE)
+ 
+                 for heading in headings:
+                     # 見出しの下のテキストを抽出
+                     pattern = r'##\s+' + re.escape(heading) + r'\s*\n(.*?)(?=^##|\Z)'
+                     matches = re.findall(pattern, content, re.MULTILINE | re.DOTALL)
+ 
+                     if matches:
+                         description = matches[0].strip()
+ 
+                         # リスト項目を抽出
+                         list_items = re.findall(r'^\s*[-*]\s+(.+)$', description, re.MULTILINE)
+ 
+                         if list_items:
+                             for item in list_items:
+                                 self.requirements[category].append({
+                                     'title': f"{prefix}{req_type}: {heading}",
+                                     'description': item,
+                                     'source_file': filepath
+                                 })
+                         else:
+                             self.requirements[category].append({
+                                 'title': f"{prefix}{req_type}: {heading}",
+                                 'description': description,
+                                 'source_file': filepath
+                             })
+         except Exception as e:
+             print(f"エラー: {filepath} の解析中にエラーが発生しました: {e}")
+ 
+     def generate_issue_updates(self):
+         """Issuesの更新内容を生成"""
+         print("\nIssuesの更新内容を生成しています...")
+ 
+         updates = []
+ 
+         # 既存のIssueをタイトルでマッピング
+         existing_issues = {issue['title']: issue for issue in self.issues}
+ 
+         # 各カテゴリの要件に対して更新を生成
+         for category, requirements in self.requirements.items():
+             for req in requirements:
+                 title = req['title']
+                 description = req['description']
+                 source_file = req['source_file']
+ 
+                 if title in existing_issues:
+                     # 既存のIssueを更新
+                     issue = existing_issues[title]
+ 
+                     # 説明が変更されている場合のみ更新
+                     if description not in issue.get('body', ''):
+                         updates.append({
+                             'action': 'update',
+                             'issue_number': issue['number'],
+                             'title': title,
+                             'body': f"{description}\n\n---\n\n**Source:** {source_file}\n**Updated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
+                             'labels': [f"category:{category}"]
+                         })
+                 else:
+                     # 新規Issueを作成
+                     updates.append({
+                         'action': 'create',
+                         'title': title,
+                         'body': f"{description}\n\n---\n\n**Source:** {source_file}\n**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
+                         'labels': [f"category:{category}"]
+                     })
+ 
+         # 要件定義に存在しないIssueをクローズ
+         all_req_titles = set()
+         for category, requirements in self.requirements.items():
+             for req in requirements:
+                 all_req_titles.add(req['title'])
+ 
+         for issue in self.issues:
+             if issue['title'] not in all_req_titles and issue['state'] == 'open':
+                 updates.append({
+                     'action': 'close',
+                     'issue_number': issue['number'],
+                     'title': issue['title'],
+                     'body': f"この要件は最新の要件定義に含まれていないため、クローズします。\n\n**Closed:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
+                     'labels': ['obsolete']
+                 })
+ 
+         return updates
+ 
+     def save_updates(self, updates, output_file='issue_updates.json'):
+         """更新内容をJSONファイルに保存"""
+         with open(output_file, 'w', encoding='utf-8') as f:
+             json.dump(updates, f, ensure_ascii=False, indent=2)
+ 
+         print(f"{len(updates)}件の更新内容を{output_file}に保存しました。")
+ 
+     def apply_updates(self, updates, dry_run=True):
+         """更新内容をGitHubに適用"""
+         if dry_run:
+             print("\n[ドライラン] 以下の更新を適用します:")
+         else:
+             print("\n以下の更新を適用します:")
+ 
+         for update in updates:
+             action = update['action']
+             title = update['title']
+ 
+             if action == 'create':
+                 print(f"新規作成: {title}")
+                 if not dry_run:
+                     # GitHubのIssue作成APIを呼び出す
+                     pass
+             elif action == 'update':
+                 issue_number = update['issue_number']
+                 print(f"更新: #{issue_number} {title}")
+                 if not dry_run:
+                     # GitHubのIssue更新APIを呼び出す
+                     pass
+             elif action == 'close':
+                 issue_number = update['issue_number']
+                 print(f"クローズ: #{issue_number} {title}")
+                 if not dry_run:
+                     # GitHubのIssueクローズAPIを呼び出す
+                     pass
+ 
+         if dry_run:
+             print("\nドライランが完了しました。実際に適用するには --apply オプションを指定してください。")
+         else:
+             print("\n更新が完了しました。")
+ 
+ 
+ def main():
+     """メイン関数"""
+     parser = argparse.ArgumentParser(description='GitHubのIssuesを要件定義に合わせて更新するスクリプト')
+     parser.add_argument('--owner', required=True, help='リポジトリのオーナー名')
+     parser.add_argument('--repo', required=True, help='リポジトリ名')
+     parser.add_argument('--token', help='GitHub Personal Access Token')
+     parser.add_argument('--requirements-dir', default='Requirements', help='要件定義ディレクトリ (デフォルト: Requirements)')
+     parser.add_argument('--output', default='issue_updates.json', help='更新内容の出力ファイル (デフォルト: issue_updates.json)')
+     parser.add_argument('--apply', action='store_true', help='更新を実際に適用する (デフォルト: ドライラン)')
+ 
+     args = parser.parse_args()
+ 
+     updater = IssueUpdater(args.owner, args.repo, args.token, args.requirements_dir)
+ 
+     # GitHubのIssuesを取得
+     updater.fetch_issues()
+ 
+     # 要件定義ファイルを解析
+     updater.parse_requirements()
+ 
+     # Issuesの更新内容を生成
+     updates = updater.generate_issue_updates()
+ 
+     # 更新内容をJSONファイルに保存
+     updater.save_updates(updates, args.output)
+ 
+     # 更新内容を適用
+     updater.apply_updates(updates, not args.apply)
+ 
+ 
+ if __name__ == "__main__":
+     main()
```

---

次に、GitHubのIssueを実際に更新するための機能を追加します。

---

```diff
  import json
  import re
+ import requests
  from datetime import datetime
  
          self.owner = owner
          self.repo = repo
-         self.token = token
+         self.token = token or os.environ.get('GITHUB_TOKEN')
          self.requirements_dir = requirements_dir
          self.fetcher = GitHubIssuesFetcher(owner, repo, token)
              'summary': []
          }
+         self.base_url = f"https://api.github.com/repos/{owner}/{repo}"
+         self.headers = {
+             'Accept': 'application/vnd.github.v3+json'
+         }
+         if self.token:
+             self.headers['Authorization'] = f'token {self.token}'
  
      def fetch_issues(self):
              print("\n以下の更新を適用します:")
  
+         success_count = 0
+         error_count = 0
+ 
          for update in updates:
              action = update['action']
              title = update['title']
  
+             try:
                  if action == 'create':
                      print(f"新規作成: {title}")
                      if not dry_run:
-                     # GitHubのIssue作成APIを呼び出す
-                     pass
+                         self._create_issue(update)
+                         success_count += 1
                  elif action == 'update':
                      issue_number = update['issue_number']
                      print(f"更新: #{issue_number} {title}")
                      if not dry_run:
-                     # GitHubのIssue更新APIを呼び出す
-                     pass
+                         self._update_issue(update)
+                         success_count += 1
                  elif action == 'close':
                      issue_number = update['issue_number']
                      print(f"クローズ: #{issue_number} {title}")
                      if not dry_run:
-                     # GitHubのIssueクローズAPIを呼び出す
-                     pass
+                         self._close_issue(update)
+                         success_count += 1
+             except Exception as e:
+                 print(f"エラー: {title} の更新中にエラーが発生しました: {e}")
+                 error_count += 1
  
          if dry_run:
              print("\nドライランが完了しました。実際に適用するには --apply オプションを指定してください。")
          else:
-             print("\n更新が完了しました。")
+             print(f"\n更新が完了しました。成功: {success_count}件, エラー: {error_count}件")
+ 
+     def _create_issue(self, update):
+         """新規Issueを作成"""
+         url = f"{self.base_url}/issues"
+         data = {
+             'title': update['title'],
+             'body': update['body'],
+             'labels': update['labels']
+         }
+ 
+         response = requests.post(url, headers=self.headers, json=data)
+ 
+         if response.status_code != 201:
+             raise Exception(f"APIエラー: {response.status_code} - {response.text}")
+ 
+         return response.json()
+ 
+     def _update_issue(self, update):
+         """既存のIssueを更新"""
+         url = f"{self.base_url}/issues/{update['issue_number']}"
+         data = {
+             'title': update['title'],
+             'body': update['body'],
+             'labels': update['labels']
+         }
+ 
+         response = requests.patch(url, headers=self.headers, json=data)
+ 
+         if response.status_code != 200:
+             raise Exception(f"APIエラー: {response.status_code} - {response.text}")
+ 
+         return response.json()
+ 
+     def _close_issue(self, update):
+         """Issueをクローズ"""
+         url = f"{self.base_url}/issues/{update['issue_number']}"
+         data = {
+             'state': 'closed',
+             'body': update['body'],
+             'labels': update['labels']
+         }
+ 
+         response = requests.patch(url, headers=self.headers, json=data)
+ 
+         if response.status_code != 200:
+             raise Exception(f"APIエラー: {response.status_code} - {response.text}")
+ 
+         return response.json()
  
  
```

---

スクリプトを実行可能にします。

---

```bash
chmod +x tools/github/update_issues.py
```

```
dify-api-py3.11ommp2021:DigeClip dm$ 

```

---

READMEファイルを更新して、新しいスクリプトの使用方法を追加します。

---

```diff
  - 要件定義のマークダウンファイルを生成
  - CSVファイルにエクスポート
+ - 要件定義に合わせてIssuesを更新
  
  ### 必要条件
  
  ### 使用方法
+ 
+ #### Issuesの取得と要件定義への変換
  
  ```bash
  # 詳細なオプション
  python tools/github/main.py --help
+ ```
+ 
+ #### 要件定義に合わせたIssuesの更新
+ 
+ ```bash
+ # 要件定義に合わせてGitHubのIssuesを更新（ドライラン）
+ python tools/github/update_issues.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]
+ 
+ # 実際に更新を適用
+ python tools/github/update_issues.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>] --apply
+ 
+ # 詳細なオプション
+ python tools/github/update_issues.py --help
  ```
  
  - `--output-dir`: 出力ディレクトリ（デフォルト: 'Requirements'）
  - `--skip-fetch`: Issuesの取得をスキップして分析のみ行う
+ - `--requirements-dir`: 要件定義ディレクトリ（デフォルト: 'Requirements'）
+ - `--apply`: 更新を実際に適用する（デフォルト: ドライラン）
  
  ### 出力ファイル
  - `github_issues.csv`: Issuesをカテゴリ別にまとめたCSVファイル
  - `Requirements/<カテゴリ>/<ファイル名>`: 要件定義のマークダウンファイル
+ - `issue_updates.json`: 更新内容のJSONファイル
  
  ### カテゴリ
  - 大量のIssuesを取得する場合は、時間がかかる場合があります
  - 認証トークンを使用することで、API制限を緩和できます
+ - 要件定義ファイルの見出し（##）がIssueのタイトルになります
+ - 要件定義ファイルの更新後に `update_issues.py` を実行することで、Issuesを最新の要件定義に合わせて更新できます
  
```

---

ヘルプを表示して、新しいスクリプトが正しく動作するか確認します。

---

```bash
python tools/github/update_issues.py --help
```

```
dify-api-py3.11ommp2021:DigeClip dm$ python tools/github/update_issues.py --help
usage: update_issues.py [-h] --owner OWNER --repo REPO [--token TOKEN] [--requirements-dir REQUIREMENTS_DIR]
                        [--output OUTPUT] [--apply]

GitHubのIssuesを要件定義に合わせて更新するスクリプト

options:
  -h, --help            show this help message and exit
  --owner OWNER         リポジトリのオーナー名
  --repo REPO           リポジトリ名
  --token TOKEN         GitHub Personal Access Token
  --requirements-dir REQUIREMENTS_DIR
                        要件定義ディレクトリ (デフォルト: Requirements)
  --output OUTPUT       更新内容の出力ファイル (デフォルト: issue_updates.json)
  --apply               更新を実際に適用する (デフォルト: ドライラン)
dify-api-py3.11ommp2021:DigeClip dm$
```

---

## 完成したツールの概要

GitHubのIssuesを要件定義に合わせて更新するツールが完成しました。このツールは以下の機能を提供します：

1. **要件定義ファイルの解析**
   - Requirementsディレクトリ内のマークダウンファイルを解析
   - 見出し（##）をIssueのタイトルとして抽出
   - カテゴリ別に要件を分類（ビジネス要件、機能要件、非機能要件など）

2. **GitHubのIssuesの取得**
   - GitHub APIを使用して指定したリポジトリのIssuesを取得
   - 認証トークンを使用して制限を緩和可能

3. **Issuesの更新内容の生成**
   - 新規作成が必要なIssueの特定
   - 更新が必要な既存Issueの特定
   - 不要になったIssueのクローズ

4. **更新内容の適用**
   - ドライラン機能（実際に適用せずに更新内容を確認）
   - 実際にGitHubのIssuesを更新

### 使用方法

```bash
# 要件定義に合わせてGitHubのIssuesを更新（ドライラン）
python tools/github/update_issues.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>]

# 実際に更新を適用
python tools/github/update_issues.py --owner <オーナー名> --repo <リポジトリ名> [--token <GitHubトークン>] --apply
```

### 更新の流れ

1. 要件定義ファイル（マークダウン）を更新
2. `update_issues.py` を実行してドライランで更新内容を確認
3. `--apply` オプションを付けて実行し、実際にIssuesを更新

これにより、要件定義ファイルの変更に合わせて、GitHubのIssuesを自動的に更新することができます。新しい要件が追加された場合は新規Issueが作成され、既存の要件が変更された場合は対応するIssueが更新され、不要になった要件に対応するIssueはクローズされます。

---



---

