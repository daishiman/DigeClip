---
description: 非機能要件
globs: ["**/config/**/*.ts", "**/lib/middleware/**/*.ts", "**/lib/db/**/*.ts", "**/lib/utils/**/*.ts", "**/prisma/schema.prisma"]
alwaysApply: false
---
# 非機能要件

## 4_nonFunctional_requirements/1_Infrastructure.md

# インフラ構成 (最新版)

> **目的**:
> - **簡単に始められ**, **無料枠を活用**, かつ **将来拡張が容易**な構成を第一優先とする
> - **経験の浅いエンジニア**でも導入しやすいクラウド/ホスティングを選定
> - 本番環境・開発環境を分けやすく、**CI/CDパイプライン**も最小の手間で構築

---

## 1. 選定クラウド / ホスティング

1. **Cloudflare Pages** (メイン)
   - **Next.js**対応のホスティングサービス
   - 無料プランで**Edge Functions + ワーカー**が利用可能
   - **GitHub連携**でプルリクごとにプレビュー環境を自動生成
   - グローバルCDNによる高速配信
   - アプリのフロントエンド+バックエンド(API Routes)を一体化できる

2. **Supabase** (BaaS, DB)
   - **PostgreSQL (無料枠)** + 認証(メール・Googleアカウント)/ストレージ/リアルタイム
   - シンプルな**マネージドDB**として利用
   - 後々、有料プランにアップグレード可

3. （将来オプション）
   - **Vercel**: Next.jsの公式ホスティングとして利用可能
   - **Railway**: コンテナデプロイやマネージドPostgreSQL/Redisで無料枠あり
   - **AWS Amplify**: AWSに統合したい場合に検討。無料枠だがやや学習コスト高
   - **Fly.io**: Dockerイメージでデプロイ。低レイテンシ要件が必要になった場合に選択可

**方針**: MVP段階では **Cloudflare Pages + Supabase** だけで十分運用可能。必要に応じて他サービスを組み込む。

---

## 2. ネットワーク構成

> 低コスト＆構成簡単化を最優先し、大規模なVPC/サブネット設計は現時点で行わない。

1. **VPC**
   - Cloudflare PagesのEdge環境＋SupabaseのデフォルトVPCを使用（隠蔽された形でマネージド）
   - 特別なVPNやDirect Connectは当面不要

2. **インターネット通信**
   - すべてHTTPS通信（Cloudflare Pagesが自動的にSSL対応）
   - SupabaseへのDB接続も**TLS/SSL**で暗号化

3. **プライベートネットワーク**
   - Supabaseは基本的にパブリックエンドポイント。IP制限やリファラ制限を実施できる
   - アプリ（Cloudflare Pages）→DB（Supabase）間を**サービスキー**＋**暗号化**で保護

4. **ローカル開発環境**
   - **ngrok**を使用して、ローカル開発環境を一時的に外部公開可能
   - 認証フローのテストや外部サービス連携のテストに活用

**メリット**:
- 複雑なネットワーク設定不要 → **経験の浅いエンジニアでも扱いやすい**
- 料金発生しがちなAWS VPC等を回避し、**完全無料からスタート**可能

---

## 3. サーバ構成

1. **Webサーバ / アプリサーバ**
   - Cloudflare Pages + Edge Functions
   - **Next.js** の API Routes で最小限のビジネスロジックを実装
   - Edge Functions（Cloudflare Workers）を活用

2. **DBサーバ**
   - **Supabase**(PostgreSQL)
   - 初期無料枠：500MBストレージ、最大50行リクエスト/秒程度

3. **ロードバランサ**
   - Cloudflareが内蔵のCDN基盤でスケール
   - 手動でLBを構築する必要はない

4. **その他**
   - **Cron処理**: Cloudflare Workersでスケジュール実行 (毎時でYouTube/RSS監視)
   - **AIモデル**: OpenAI/Anthropic/Google APIに直接リクエスト → レート制限のみ考慮

**想定規模**:
- 月間数千〜数万リクエスト程度ならこの構成で余裕
- 必要ならSupabaseを有料プランにアップグレード、または外部RDSを検討

---

## 4. 開発・本番環境

1. **環境分離**
   - **開発環境**: `development`ブランチをデフォルトとし、開発環境にデプロイ
   - **本番環境**: `production`ブランチへのマージで本番環境にデプロイ
   - 機能開発は開発環境をベースに行い、安定した機能を本番環境にマージする

2. **ドメイン**
   - 開発環境: `dev-yourapp.pages.dev` (Cloudflare Pagesの自動ドメイン)
   - 本番環境: `yourapp.com` or `www.yourapp.com`(独自ドメイン、Cloudflare DNSで管理)

3. **SSL証明書**
   - Cloudflareが自動的に**SSL証明書**を提供
   - 追加費用不要

4. **デプロイフロー**
   - 基本的に機能開発は**開発環境**がデフォルト
   - ブランチ作成 → 開発 → PRを`development`ブランチに対して作成 → マージで開発環境に自動デプロイ
   - 開発環境で安定した機能を確認後、`production`ブランチに対してPRを作成 → マージで本番環境に自動デプロイ
   - DBマイグレーションは**Supabase CLI**または**DBダッシュボード**で実施

**将来拡張例**:
- 必要なら**CI/CD**(GitHub Actions)でテスト→ Cloudflare Pagesデプロイ
- ステージング環境の追加: `staging`ブランチを作成し、本番前の最終確認用環境として活用

## 5. データベース環境分離

安全性と独立した開発を実現するため、開発環境と本番環境ではSupabaseのプロジェクト（データベース）を完全に分離する。

1. **Supabaseプロジェクト分離**
   - **開発環境**: `digeclip-dev` プロジェクト（開発専用のデータベース環境）
   - **本番環境**: `digeclip-prod` プロジェクト（本番専用のデータベース環境）
   - 開発環境でのデータ変更や実験が本番環境に影響を与えない構成

2. **スキーマ管理**
   - 開発環境でスキーマ変更をテストし、安定したスキーマのみを本番環境に適用
   - SQLマイグレーションスクリプトもしくはSupabase管理インターフェースでスキーマ変更を管理
   - スキーマバージョン管理を徹底し、開発環境と本番環境で同期を維持

3. **認証情報とAPI接続**
   - 環境ごとに異なるAPI URL、APIキー（anon key, service_role key）を使用
   - 環境変数を使い分け（`.env.development`、`.env.production`）
   - Cloudflare Pagesの環境変数設定で、開発/本番環境ごとに適切なSupabase接続情報を設定

4. **テストデータ**
   - 開発環境には、アプリケーションテスト用のサンプルデータを投入可能
   - 本番環境のデータは実際のユーザーデータのみを含み、テストデータは混入させない
   - 必要に応じて、本番データのサニタイズ版を開発環境にインポート（個人情報は除去）

5. **セキュリティ対策**
   - 本番環境のデータベースアクセスは特に厳格に管理（限定された管理者のみアクセス可能）
   - 開発環境も基本的にはチーム内のみアクセス可能とし、外部公開しない

この環境分離により、開発者は安全に機能開発・実験ができ、本番環境のデータやサービス提供に影響を与えることなく迅速な開発サイクルを実現する。

---

## まとめ

- **Cloudflare Pages (Edge) + Supabase (DB)**でシンプルなインフラ → **ほぼ無料**スタート
- **ネットワーク設定を意識せず**、HTTPSのみで外部アクセス
- **グローバルCDN**によりオートスケール、LB不要
- **開発環境/本番環境**を明確に分離し、スムーズな開発とデプロイを実現
- **ngrok**を活用してローカル開発環境での連携テストを容易に
- 当面はこれで十分運用可能＆**経験の浅いエンジニア**でも管理しやすい
- 必要に応じて**Vercel, Railway, AWS**などに移行できる拡張性は確保

この構成により、初期費用や管理コストを最小化しつつ、開発と本番環境を適切に分離。将来的に**大規模アクセス**や**高度なネットワーク構成**が必要になった際にも比較的スムーズに移行可能である。
```

## 4_nonFunctional_requirements/2_Security.md

```markdown
# セキュリティ要件 (最新版)

> **方針**:
> - **お金をかけず、容易に**経験の浅いエンジニアでも実装できる
> - 将来的に**機能追加や大規模化**に対応しやすい構成
> - **Next.js**(バックエンド含む) + **Supabase** というシンプルな構成でも、最低限のセキュリティ水準を確保

---

## 1. アクセス制御

### 1.1 認証方式

1. **Googleアカウント認証 (OAuth2.0)**
   - **NextAuth.js**などのライブラリを用いて、Google OAuthフローを実装
   - ユーザーがGoogleログインを選択した場合、コールバックURLでアクセストークンを取得 → DBにユーザー情報を登録 → JWTを発行する流れがベストプラクティス
   - 無料で始められ、Google Developers Console からOAuthクライアントIDを取得

2. **JWT認証 (Email + パスワード)**
   - 新規ユーザー登録（サインアップ）時にメール＋パスワードをDBに保存（パスワードは**ハッシュ化**）
   - ログイン（サインイン）成功時に、JWTを発行し、**HTTP-only Cookie**など安全な手段でクライアントに返す
   - JWTには**有効期限 (例: 1日)** を付与し、長期セッションを回避
   - リフレッシュトークンや定期的な再ログインでセキュリティを強化

### 1.2 ロール/権限設計

- **admin（管理者）**
  - 監視対象（sources）CRUD、AIモデル管理、タグ管理、ユーザー管理など**すべての機能**にフルアクセス
- **user（一般ユーザー）**
  - コンテンツの閲覧、タグの追加/削除など**一般利用**が可能
  - ソース管理やAIモデル管理などの管理系操作は不可
- **guest（未ログイン）**
  - 限定的な機能のみ（例えばトップページや認証画面へのアクセス程度）
  - コンテンツ一覧の閲覧を許可するかは運用方針次第

#### 実装イメージ

- 各API Route で **JWTを検証** し、`role` を確認
  - `/api/admin/...` は `role === 'admin'` 以外は403 Forbidden
  - `/api/user/...` は `role === 'user' or 'admin'` のみ許可
  - 一般公開APIがあれば認証不要でもOK

---

## 2. 通信暗号化

### 2.1 HTTPS / TLS

- **Vercel** でホスティングする場合、**自動的にHTTPS証明書(Let's Encrypt)** が発行される
- **Supabase** との通信もTLSを利用し、アプリ側は `SUPABASE_URL (https://...)` で安全にAPI呼び出し
- 独自ドメイン設定する際も、VercelがLet's Encrypt で証明書を管理 → エンジニアは特別な設定不要

### 2.2 証明書管理

- Vercelの無料プランにおいて、SSL証明書は自動生成＆更新される
- 必要に応じて独自CA証明書を設定可能（Pro/Enterpriseプラン）だが、基本は不要

---

## 3. データ暗号化

### 3.1 保存データ（DB内）

1. **パスワード**:
   - **ハッシュ化**（bcrypt や argon2）して保存
   - **ソルト**も適切に設定し、レインボーテーブル攻撃を防止
2. **APIキー (AIモデルなど)**:
   - `ai_models.api_key_encrypted` カラムに**暗号化**または**Base64 + KMS（将来的）**
   - 復号する際はバックエンドのみ（ユーザーに表示しない）
3. **個人情報**
   - 必要最小限のみDBに保持
   - SupabaseのRow Level Security(RLS)を利用するか検討（将来）

### 3.2 Secretsの管理

- `.env.local` や **Vercel環境変数** に保管
- リポジトリには**絶対に含めない**
- Google OAuth クライアントID/Secret、JWT Secret key などは**必須で暗号化**した状態で保管

---

## 4. 脆弱性対策

### 4.1 OWASP対策

1. **SQLインジェクション**
   - ORM（Prisma/Drizzleなど）やSupabaseクライアントを使用 → プレースホルダで安全にクエリ
2. **XSS（クロスサイトスクリプティング）**
   - Next.js ではデフォルトで**Reactのエスケープ**が効く
   - 危険なHTMLを表示する際は `dangerouslySetInnerHTML` に注意
3. **CSRF（クロスサイトリクエストフォージェリ）**
   - APIを**JWT + HTTP-only Cookie**方式、または**CSRFトークン**を用いる
4. **その他**
   - 依存パッケージの自動アップデート、ESLint/Snykなどで脆弱性チェック

### 4.2 WAF/IDS/IPS

- 無料構成では**WAF未導入**が通常
- 必要に応じて**Cloudflare**などエッジサービスを導入検討
- 大規模化したら**AWS WAF**や**Vercel Proのセキュリティ機能**を検討

---

## 5. ログ・監査

### 5.1 アクセスログ / 操作ログ

1. **APIアクセスログ**
   - Vercelはデフォルトでリクエストログを保存しない → 代替としてSupabaseに**APILogテーブル**作成 or Sentry等を導入
2. **認証ログ**
   - ログイン/ログアウト時に`auth_logs`テーブルへ記録（ユーザーID, IP, timestamp等）
   - パスワード変更やリセット時もログ残す

### 5.2 保存期間・監査方法

- **保存期間**:
  - ベースは**無期限**（ストレージに問題がなければ）
  - ある程度古いログは手動削除orアーカイブ可能
- **監査方法**:
  - 管理画面でログ閲覧 or Supabaseダッシュボードでクエリ
  - 重要イベント（AIモデル設定変更など）は**Slack通知**などの拡張余地

---

## まとめ

- **HTTPS/TLS**はVercelが自動対応 → 証明書管理の手間不要
- **認証・認可**は **Google OAuth + JWT** でロールベース管理
- **DB・Secrets暗号化**を徹底し、パスワードはハッシュ化
- **OWASP対策**を最低限実施（SQLi/XSS/CSRF対策）
- **ログ収集**は Supabase or Sentry, 必要なら外部サービス連携
- 全体的に**経験の浅いエンジニアでも**無理なく導入可能で、将来的拡張も容易

これらにより、最小限のコスト・構成で**セキュリティ水準を確保**しつつ、運用負荷を低減できる見通しです。

## 4_nonFunctional_requirements/3_Performance.md

```markdown
# パフォーマンス要件 (最新版)

> **方針**
> - **お金をかけずに、経験の浅いエンジニアでも実装しやすい**技術を優先
> - **Vercel無料プラン + Supabase無料枠**でも最低限のパフォーマンスを確保できる構成
> - **将来的に拡張**（高負荷対応や追加キャッシュ導入など）しやすい設計

---

## 1. レスポンスタイム目標

1. **通常時**
   - **APIレスポンス**: 1秒以内
   - **ページ読み込み**: TTFB（Time to First Byte）を500ms以内
   - Next.js (SSR) ではサーバレス環境での初回実行（Cold Start）が発生するため、最初のリクエストで**1~2秒**程度許容（Vercel無料プランの場合）
2. **負荷時**
   - ユーザー同時アクセス数 50〜100 程度までであれば、1秒以内の応答を目指す
   - 負荷ピーク時（YouTubeなど新着大量発生時）は**2〜3秒程度**まで許容

---

## 2. スループット目標

1. **同時接続数**
   - 最初の運用では **50〜100** 同時接続を想定
   - 将来的に **1000 同時接続** へ拡張できるよう、Supabase有料プランやVercel Proへの移行を検討
2. **リクエスト数/秒 (RPS)**
   - 初期運用: **10〜20 RPS** を想定
   - ログインAPIや要約APIにアクセスが集中する場合も**30〜50 RPS**程度まで耐えられる構成を目安
   - 大幅増加が見込まれる時期があれば**レートリミット**や**有料プラン**への移行を検討

---

## 3. 負荷試験計画

1. **ツール**
   - **k6** や **Artillery** などのOSSでHTTP負荷試験
   - 簡易的には**Postman**のCollection Runnerでも可
2. **シナリオ**
   - **ログインAPI連続アクセス**: JWT発行処理のCPU負荷・DB書き込みを検証
   - **コンテンツ一覧取得**: 大量データ・ページネーションのパフォーマンス確認
   - **要約API呼び出し**: AIモデル要約処理の負荷（外部API依存だが、同時呼び出し数をチェック）
3. **テスト項目**
   - **スループット** (RPS)・**応答時間** (p95, p99)
   - **エラー率** (HTTP 5xx, タイムアウト率)
   - 1時間連続負荷 or 短期ピーク負荷 (ワークロードシミュレーション)

---

## 4. キャッシュ戦略

1. **CDN**
   - Vercel が自動で**静的ファイルをCDNキャッシュ**
   - SSG (静的生成) 可能なページは極力SSGし、CDNから配信
2. **アプリ/DBキャッシュ**
   - **Next.js** App Routerの**ISR(Incremental Static Regeneration)** で動的コンテンツを一定期間キャッシュ化
   - DBに頻繁にアクセスする箇所（タグ一覧など）は**Supabaseのキャッシュ**や**KVストア**を検討
3. **AI要約キャッシュ**
   - 同じ動画/論文への要約結果は**summaries**テーブルに保存し、再呼び出しを回避
   - Discord通知後は一定期間キャッシュして**無駄な再生成**を防ぐ

---

## 5. モニタリング指標

1. **CPU使用率 / メモリ**
   - Vercelサーバレスの場合は軽微だが、**Supabase** Postgres CPU/メモリ使用率を監視
   - DBクエリ数や慢性的な負荷をチェック
2. **レスポンスタイム**
   - p50, p95, p99 を記録 → p95 が **1秒**以内に収まることを目標
   - Vercel の [Logging/Analytics](https://vercel.com/docs/analytics) や Supabase モニタリング
3. **エラー率**
   - 5xx エラー (サーバエラー) が 1%未満
   - 4xx エラー (認証/権限/Bad Request) はリクエスト失敗ログで分析
4. **AI API呼び出し**
   - 外部AIモデルAPI のタイムアウト率, コスト計算 (トークン消費)
   - AI呼び出しが多いときのボトルネックやAPIの429エラー(レート制限)をチェック

---

### まとめ

- **1秒以内のレスポンス**を基本目標とし、YouTubeや論文の大規模データが増えた際は**キャッシュ強化**や**有料プラン**への移行
- 負荷試験には**k6/Artillery**を用い、**ログインAPI/コンテンツ取得/要約API**のボトルネックを検証
- モニタリングで**レスポンスタイム, エラー率, AI API呼び出し状況**を把握し、**サーバレス特有のCold Start**を考慮
- **小規模環境**でも最小コストで運用可能だが、拡張しやすい構成をあらかじめ確保する

以上により、初心者エンジニアが運用しつつも必要に応じて拡張できる**柔軟なパフォーマンス要件**を実現。

## 4_nonFunctional_requirements/4_Availability_and_Reliability.md

```markdown
# 可用性・信頼性要件 (最新版)

> **方針**
> - **最小コスト**での運用を重視（Vercel無料プラン＋Supabase無料枠）
> - **経験の浅いエンジニア**でも簡単に冗長化やバックアップを設定できるようにする
> - 将来的に**大規模スケール**やディザスタリカバリを行いやすい拡張性を確保

---

## 1. SLA (サービス稼働率目標)

1. **稼働率目標**
   - 現段階では **99.0%** を目標 (約月に 7時間ダウンまで許容)
   - Vercel Hobbyプランの稼働率は保証されていないが、実測では高い可用性を期待
   - Supabase無料枠も大規模障害が少なく、同程度の可用性を想定
2. **許容ダウンタイム**
   - **メンテナンスウィンドウ**: 毎月1回(数十分程度)
   - 予期せぬ障害発生時の**復旧目標**: 1〜2時間以内

---

## 2. 冗長化

1. **Vercel**
   - 無料プランでも**CDNエッジ**にホストされ、ビルド後コンテンツは自動的に冗長化
   - サーバレス関数はマルチリージョンではなく、指定リージョン単位（Hobbyプランでは基本US1など）
2. **Supabase**
   - 無料枠では**シングルAZ** (単一リージョン) のみ
   - 将来必要になれば**有料プラン**でMulti-AZや**レプリケーション**を検討
3. **ロードバランサ / オートスケール**
   - Vercelサーバレスの特性上、**リクエストごとに自動スケール**
   - ロードバランサはVercelの内部で抽象化されており、ユーザーが設定不要

---

## 3. バックアップ / リストア

1. **バックアップ取得頻度**
   - **Supabase**:
     - 無料プランでは**自動バックアップは無し** → 週1回程度の**手動Dump**を推奨
     - (有料プランで自動スナップショット対応)
   - **Vercel**:
     - ソースコードはGitHubで管理し、バージョン管理でバックアップ不要
     - サーバレス関数の状態はステートレス
2. **保存先**
   - SupabaseのDBダンプを**ローカル or Cloud Storage (例: Google Drive)** へ暗号化して保存
   - Dumpファイルを**最低3世代**保持
3. **復旧手順**
   - DB障害時:
     1. 最新のダンプファイルをダウンロード
     2. Supabaseの管理画面 or psqlでリストア
     3. アプリを再デプロイ or 再起動
   - VercelのGitHub連携を使用しており、ソースコードのロールバックは**Gitリポジトリ**のバージョンを戻すだけ

---

## 4. DR(ディザスタリカバリ)計画

1. **RTO (目標復旧時間) / RPO (目標復旧時点)**
   - **RTO**: 24時間以内 (無料プランでの手動復旧を想定)
   - **RPO**: 最後に取得したDump以降のデータは失われる可能性 → 数日〜1週間相当
2. **別リージョンへのレプリケーション**
   - 無料枠では不可 → 将来、有料プランで別リージョンへの**自動レプリケーション**を検討
   - 予算があればAWS/Azureへのバックアップ転送も検討
3. **手順概要**
   - **リージョン障害時**: Supabaseの有料プランに切り替え→別リージョンにDBを復元
   - **Vercel**: Hobbyプランにリージョン指定オプションあり(一部対応) → 必要ならProプランで複数リージョンデプロイを考慮

---

## 5. 監視とアラート

1. **監視項目**
   - Vercelの**デプロイ状況**、**関数エラー** (5xx)
   - Supabaseの**DBヘルス** (CPU/メモリ/ストレージ使用量)
   - 定期実行(Cron)の**成功/失敗**ログ
2. **通知方法**
   - Vercel → GitHub連携 or Slack/Discord連携でデプロイ成功/失敗アラート
   - Supabase → メールやWebhookでDB残容量アラート
   - Cron失敗 → Discord or Slackで通知
3. **障害時の対応フロー**
   1. 監視アラート受信 → 管理者が**ダッシュボード**確認
   2. エラーログやSupabaseコンソールのヘルス状況チェック
   3. 短時間で復旧しない場合 → 手動でデプロイ再試行 or DB復旧
   4. 場合によりユーザーに**アナウンス** (Discordチャンネルなど)

---

### まとめ

- **可用性**は無料プラン運用で**99%**程度を想定
- **冗長化**はVercelのサーバレス特性である程度カバー、DBは有料プランでMulti-AZに対応可能
- **バックアップ**はSupabase無料枠では手動Dump必須 → 週1回程度
- **DR計画**は最低限のDump復旧で **RTO=24時間, RPO=~1週間** まで
- **監視**はVercelとSupabaseのダッシュボード＋アラート連携、障害時は手動復旧を基本とし、将来の拡張も可能
```

## 4_nonFunctional_requirements/5_Operations.md

```markdown
# 保守運用要件 (最新版)

> **方針**
> - **経験の浅いエンジニア**が中心となっても **低コスト**で保守できる体制
> - **Vercel + Supabase 無料枠** を前提にしつつ、**将来的な拡張**も考慮
> - **運用体制やドキュメント整備**を最小限の手間で整え、段階的に強化

---

## 1. 運用体制

1. **オンコール対応**
   - 無料規模の運用を想定しているため、専任オンコールは設置しない
   - 軽度障害は、運用担当が Slack/Discord 等の通知を確認し、業務時間内に対応
   - 重大障害（致命的ダウンなど）のみ、チーム内で **24時間内** 対応を目指す

2. **運用担当者数**
   - 最小構成として**1名〜2名**が管理者 (admin ロール) として兼務
   - 担当者が複数名いる場合は、月単位でローテーション
   - リソース状況に応じて必要なら追加

3. **運用スケジュール**
   - 定期モニタリング：週1回(ダッシュボード確認)
   - バックアップ作業：DBダンプ等を週1回手動取得
   - 機能追加/アップデート：月1〜2回程度

---

## 2. 監視ツール

1. **利用ツール**
   - **Vercel Dashboard**: デプロイ状況、Serverless Functions のエラー確認
   - **Supabase Dashboard**: DBリソース(CPU/メモリ/ストレージ)の監視、ログ閲覧
   - **Discord / Slack**: 障害通知チャネルとして利用（Webhook連携）

2. **収集指標**
   - **Serverless関数のエラーレート** (Vercel)
   - **DB使用量** (Supabase 無料枠上限)
   - **Cron実行結果** (成功/失敗ログ)
   - **AI API呼び出し回数** (OpenAIなど)  → コスト管理

3. **分析方法**
   - 週次で主要メトリクス (APIエラー回数, Cron失敗回数 等) を簡単にレビュー
   - 問題や傾向があればスプレッドシート等で管理し、対策を検討

---

## 3. 障害対応フロー

1. **インシデント管理**
   - 問題発生時にDiscordやSlackでアラート受領 → 運用担当が内容確認
   - 事象を「軽度・中度・重大」に分類し、優先度を決定

2. **エスカレーション手順**
   - **軽度 (例: 一部機能が停止/遅延)**: 担当者が業務時間内に修正対応
   - **中度 (例: DB容量上限近い、Cron実行失敗が続く)**: 担当者が即日対応 or 有料プラン検討
   - **重大 (例: 全面ダウン、データ消失リスク)**: 24時間以内に緊急対応、チーム全員へ連絡

3. **復旧プロセス**
   - 原因調査 (Vercel/Supabase Dashboard, ログ解析)
   - 暫定対策 (再デプロイ, DB拡張, リトライ)
   - 必要に応じてバックアップからの復旧 or 有料プランへのアップグレード
   - 復旧後、問題原因をドキュメント化して再発防止策を検討

---

## 4. ドキュメント管理

1. **保管場所**
   - GitHubリポジトリの `/docs` フォルダ or Notion/Confluence 等で管理
   - バックアップ/リストア手順、認証設定、Cron設定、運用チェックリストなどをまとめる

2. **バージョン管理ルール**
   - ドキュメント変更は**Pull Request**ベースでレビュー
   - バージョンタグ or リリースノートを運用し、更新内容を履歴化

3. **更新フロー**
   - 機能追加/設定変更のたびに**対応手順を更新**
   - 運用担当が週1回確認し、最新状況を反映

---

## 5. 定期メンテナンス

1. **パッチ適用頻度**
   - **Node.js/Next.js/Tailwind** などは minor アップデートがある程度安定してから月1回程度更新
   - **Supabase** は自動更新（プラットフォーム側）かつ有償プランほどの大規模パッチは不要

2. **メンテナンス告知方法**
   - Discord のシステム通知チャンネル or Slack
   - 「メンテ時間 (30分程度)」「影響範囲」を事前案内

3. **Downtime想定**
   - 無料プランで**0ダウンタイム**難 → メンテナンス時に短時間の停止を許容
   - 事前に「メンテナンスページ」表示 or Discordでアナウンス

---

### まとめ

- **運用体制**は最小限（1〜2名の管理者が週次確認）で開始 → 障害対応はDiscord通知
- **監視ツール**はVercel/Supabaseダッシュボード、Discord/Slackでのアラート
- **障害対応フロー**は3段階(軽度・中度・重大)、24h以内の復旧が目標
- **ドキュメント管理**はGitHubリポジトリ or Notionで随時更新
- **定期メンテナンス**は月1回程度、影響範囲をDiscordで告知し、ダウンタイムを最小化
- 予算と規模が拡大した場合は有料プランや外部監視ツール導入等を検討する
```

