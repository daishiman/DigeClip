---
description: テスト戦略
globs: ["**/__tests__/**/*.{tsx,jsx,ts,js}", "**/*.test.{tsx,jsx,ts,js}"]
alwaysApply: false
---
# テスト戦略

## 4_test_strategy/1_strategy.md

# テスト戦略

このドキュメントでは、プロジェクト全体のテスト戦略を定義します。テスト戦略は、アプリケーションの品質を確保し、バグを早期に発見するために重要です。

## テストの種類

プロジェクトでは、以下の3種類のテストを実施します：

1. **単体テスト (Unit Tests)**
   - 個々の関数やコンポーネントが期待通りに動作することを確認する
   - 詳細: [単体テスト](mdc:1_test_types/1_unit_tests.md)

2. **統合テスト (Integration Tests)**
   - 複数のモジュールやコンポーネントが連携して正しく動作することを確認する
   - 詳細: [統合テスト](mdc:1_test_types/2_integration_tests.md)

3. **E2Eテスト (End-to-End Tests)**
   - アプリケーション全体が実際のユーザーシナリオに沿って正しく動作することを確認する
   - 詳細: [E2Eテスト](mdc:1_test_types/3_e2e_tests.md)

## テストピラミッド

テストの量と実行頻度は、テストピラミッドに従って設計します：

```
    /\
   /  \
  /E2E \
 /------\
/統合テスト\
/----------\
/  単体テスト \
/--------------\
```

- **単体テスト**: 最も多く、最も頻繁に実行する
- **統合テスト**: 中程度の量と頻度
- **E2Eテスト**: 最も少なく、最も頻度が低い

## テストツール

プロジェクトでは、以下のテストツールを使用します：

1. **Jest**
   - 単体テストと統合テストに使用
   - 詳細: [Jest](mdc:2_test_tools/1_jest.md)

2. **React Testing Library**
   - Reactコンポーネントのテストに使用
   - Jestと組み合わせて使用

3. **Cypress / Playwright**
   - E2Eテストに使用
   - 詳細: [Cypress と Playwright](mdc:2_test_tools/2_cypress_playwright.md)

## テストディレクトリ構造

テストコードは、以下のディレクトリ構造に従って配置します：

```
/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](mdc:2_test_structure.md)を参照してください。

## テスト実行

テストは、以下のコマンドで実行します：

```bash
# すべてのテストを実行
npm test

# 単体テストのみ実行
npm run test:unit

# 統合テストのみ実行
npm run test:integration

# E2Eテストのみ実行
npm run test:e2e

# テストカバレッジを計測
npm run test:coverage
```

## CI/CDとの統合

テストは、CI/CDパイプラインに統合します：

1. **プルリクエスト時**
   - 単体テストと統合テストを実行
   - テストカバレッジを計測

2. **メインブランチへのマージ時**
   - 単体テスト、統合テスト、E2Eテストを実行
   - テストカバレッジを計測

3. **デプロイ前**
   - すべてのテストが成功していることを確認

## テストカバレッジ

テストカバレッジは、以下の基準を目標とします：

- **単体テスト**
  - 関数/メソッド: 80%以上
  - 分岐カバレッジ: 70%以上
  - 行カバレッジ: 75%以上

- **統合テスト**
  - 主要な機能フロー: 90%以上

- **E2Eテスト**
  - 重要なユーザーフロー: 100%

## テスト環境

テストは、以下の環境で実行します：

1. **ローカル開発環境**
   - 開発者のマシン上で実行
   - 単体テストと統合テストを実行

2. **CI環境**
   - GitHub Actionsなどで実行
   - すべてのテストを実行

3. **ステージング環境**
   - 本番環境に近い環境で実行
   - E2Eテストを実行

## テストデータ

テストデータは、以下の方針で管理します：

1. **モックデータ**
   - 単体テストと統合テストで使用
   - `src/__tests__/utils/test-utils.ts` に定義

2. **テスト用データベース**
   - 統合テストとE2Eテストで使用
   - 本番環境とは別のデータベースを使用

3. **フィクスチャ**
   - E2Eテストで使用
   - `src/__tests__/e2e/fixtures/` に配置

## テスト作成のガイドライン

1. **テストファーストの原則**
   - 可能な限り、コードを書く前にテストを書く
   - TDD (Test-Driven Development) の考え方を取り入れる

2. **テストの独立性**
   - 各テストは独立して実行できるようにする
   - テスト間の依存関係を作らない

3. **テストの可読性**
   - テストは明確で理解しやすいものにする
   - テストケースは具体的な動作を検証する

4. **テストの保守性**
   - テストコードも本番コードと同様に保守する
   - リファクタリングの際はテストも更新する

## 1_test_types/1_unit_tests.md

# 単体テスト

単体テストは、個々の関数やコンポーネントが期待通りに動作することを確認するためのテストです。

## 目的

- 個々の関数やコンポーネントが仕様通りに動作することを確認する
- バグの早期発見と修正を容易にする
- リファクタリングの安全性を確保する
- コードの品質を維持する

## テスト対象

- ユーティリティ関数 (`src/lib/`)
- カスタムフック (`src/hooks/`)
- UIコンポーネント (`src/components/`)
- APIルート (`src/app/api/`)

## ディレクトリ構造

単体テストは、`src/__tests__/unit` ディレクトリに配置します。テストの構造はソースコードの構造を反映します。

```
/src
  └─ /__tests__                    # テストコード
      └─ /unit                     # 単体テスト
          ├─ /components           # コンポーネントの単体テスト
          │   ├─ /ui               # UIコンポーネント
          │   │   ├─ Button.test.tsx
          │   │   └─ ...
          │   ├─ /layout           # レイアウトコンポーネント
          │   └─ /features         # 機能別コンポーネント
          ├─ /hooks                # カスタムフックのテスト
          │   ├─ useAuth.test.ts
          │   └─ ...
          ├─ /lib                  # ユーティリティのテスト
          │   ├─ /services         # サービスのテスト
          │   ├─ /utils            # ユーティリティのテスト
          │   └─ ...
          └─ /context              # コンテキストのテスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](mdc:../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象ファイル名].test.ts` または `[対象ファイル名].test.tsx`
- テストスイート: `describe('[関数名/コンポーネント名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 各テストは独立して実行できるようにする
2. テストは明確で理解しやすいものにする
3. テストケースは具体的な動作を検証する
4. モックは必要最小限にする

### 関数のテスト

```typescript
// src/lib/__tests__/openai.test.ts
import { generateText } from '../openai';
import { mockEnv } from '../../__tests__/utils/test-utils';

// 環境変数のモック
mockEnv({
  OPENAI_API_KEY: 'test-api-key',
});

describe('generateText', () => {
  it('正常系: テキストを生成できること', async () => {
    // テストコード
    const result = await generateText('テストプロンプト');
    expect(result).toBeDefined();
    expect(typeof result).toBe('string');
  });

  it('異常系: APIキーがない場合はエラーをスローすること', async () => {
    // 環境変数を一時的に上書き
    const originalEnv = process.env.OPENAI_API_KEY;
    process.env.OPENAI_API_KEY = '';

    // テストコード
    await expect(generateText('テストプロンプト')).rejects.toThrow();

    // 環境変数を元に戻す
    process.env.OPENAI_API_KEY = originalEnv;
  });
});
```

### コンポーネントのテスト

```typescript
// src/components/__tests__/ui/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../../ui/Button';

describe('Button', () => {
  it('ボタンがレンダリングされること', () => {
    render(<Button>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeInTheDocument();
  });

  it('クリックイベントが発火すること', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>テスト</Button>);
    const button = screen.getByText('テスト');
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('disabled属性が適用されること', () => {
    render(<Button disabled>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeDisabled();
  });
});
```

## テストカバレッジ

単体テストは、以下の基準を目標とします：

- 関数/メソッド: 80%以上
- 分岐カバレッジ: 70%以上
- 行カバレッジ: 75%以上

ただし、これらの数値は目安であり、コードの重要度や複雑さに応じて調整します。

## 1_test_types/2_integration_tests.md

# 統合テスト

統合テストは、複数のモジュールやコンポーネントが連携して正しく動作することを確認するためのテストです。

## 目的

- 複数のモジュール間の連携が正しく機能することを確認する
- 単体テストでは検出できない、モジュール間のインターフェースの問題を発見する
- 実際の環境に近い状態でのテストを行う

## テスト対象

- APIエンドポイントとデータベースの連携
- フロントエンドコンポーネントとバックエンドAPIの連携
- 複数のサービス間の連携

## ディレクトリ構造

統合テストは、`src/__tests__/integration` ディレクトリに配置します。

```
/src
  └─ /__tests__
      └─ /integration              # 統合テスト
          ├─ /api                  # API統合テスト
          │   ├─ auth.test.ts
          │   └─ ...
          ├─ /services             # サービス統合テスト
          └─ /features             # 機能結合テスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](mdc:../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象機能].test.ts` または `[対象機能].integration.test.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 実際の依存関係を使用する（モックは最小限に）
2. テスト環境を適切に設定する
3. テストデータは自己完結的に用意する
4. テスト後は環境をクリーンアップする

### APIとデータベースの統合テスト

```typescript
// src/__tests__/integration/api/content.test.ts
import { createClient } from '@supabase/supabase-js';
import { createContent, getContent } from '../../../lib/content';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('Content API 統合テスト', () => {
  let supabase;
  let testContentId;

  beforeAll(async () => {
    // テスト用のSupabaseクライアントを作成
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );

    // テストデータをクリーンアップ
    await supabase.from('contents').delete().eq('title', 'テスト用コンテンツ');
  });

  afterAll(async () => {
    // テストデータをクリーンアップ
    if (testContentId) {
      await supabase.from('contents').delete().eq('id', testContentId);
    }
  });

  it('コンテンツを作成して取得できること', async () => {
    // コンテンツを作成
    const newContent = {
      title: 'テスト用コンテンツ',
      body: 'これはテスト用のコンテンツです。',
    };

    const { data: createdContent, error: createError } = await createContent(newContent);
    expect(createError).toBeNull();
    expect(createdContent).toBeDefined();
    expect(createdContent.title).toBe(newContent.title);

    testContentId = createdContent.id;

    // 作成したコンテンツを取得
    const { data: retrievedContent, error: getError } = await getContent(testContentId);
    expect(getError).toBeNull();
    expect(retrievedContent).toBeDefined();
    expect(retrievedContent.id).toBe(testContentId);
    expect(retrievedContent.title).toBe(newContent.title);
  });
});
```

### フロントエンドとバックエンドの統合テスト

```typescript
// src/__tests__/integration/services/content.test.ts
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ContentForm } from '../../../components/ContentForm';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('ContentForm 統合テスト', () => {
  it('フォーム送信時にコンテンツが作成されること', async () => {
    // モックサーバーのセットアップ（MSWなどを使用）
    // ...

    // コンポーネントをレンダリング
    render(<ContentForm />);

    // フォームに入力
    await userEvent.type(screen.getByLabelText('タイトル'), 'テスト用コンテンツ');
    await userEvent.type(screen.getByLabelText('本文'), 'これはテスト用のコンテンツです。');

    // フォームを送信
    await userEvent.click(screen.getByText('保存'));

    // 結果を確認
    await waitFor(() => {
      expect(screen.getByText('コンテンツが保存されました')).toBeInTheDocument();
    });
  });
});
```

## テスト環境

統合テストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **モックサーバー**
   - 外部APIとの通信をモック化（必要に応じて）
   - [MSW (Mock Service Worker)](mdc:https:/mswjs.io) などのツールを使用

3. **テスト用環境変数**
   - `.env.test` ファイルを用意
   - テスト用の認証情報を設定

## 1_test_types/3_e2e_tests.md

# E2Eテスト

E2Eテスト（エンドツーエンドテスト）は、アプリケーション全体が実際のユーザーシナリオに沿って正しく動作することを確認するためのテストです。

## 目的

- 実際のユーザーの操作シナリオを模倣し、アプリケーション全体が正しく機能することを確認する
- フロントエンドとバックエンドの統合、データベースとの連携など、システム全体の動作を検証する
- 本番環境に近い状態でのテストを行う

## テスト対象

- ユーザーフロー（ログイン、コンテンツ作成、検索など）
- 画面遷移
- データの永続化
- エラーハンドリング

## ディレクトリ構造

E2Eテストは、`src/__tests__/e2e` ディレクトリに配置します。

```
/src
  └─ /__tests__
      └─ /e2e                      # E2Eテスト
          ├─ /auth                 # 認証関連E2Eテスト
          │   ├─ login.test.ts
          │   └─ ...
          ├─ /contents             # コンテンツ関連E2Eテスト
          │   ├─ contentList.test.ts
          │   └─ ...
          └─ /settings             # 設定関連E2Eテスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](mdc:../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象機能].spec.ts` または `[対象機能].e2e.spec.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 重要なユーザーフローに焦点を当てる
2. テストは独立して実行できるようにする
3. テストデータは自己完結的に用意する
4. テスト環境をテスト前に適切に設定し、テスト後にクリーンアップする

### Cypressを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/login.spec.ts
describe('ログインフロー', () => {
  beforeEach(() => {
    // テスト前の準備
    cy.visit('/login');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインフォームに入力
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ログイン成功メッセージが表示されることを確認
    cy.contains('ログインに成功しました').should('be.visible');
  });

  it('無効な認証情報でログインできないこと', () => {
    // ログインフォームに無効な認証情報を入力
    cy.get('input[name="email"]').type('invalid@example.com');
    cy.get('input[name="password"]').type('wrongpassword');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ログインページに留まることを確認
    cy.url().should('include', '/login');

    // エラーメッセージが表示されることを確認
    cy.contains('メールアドレスまたはパスワードが正しくありません').should('be.visible');
  });
});
```

### Playwrightを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/content.spec.ts
import { test, expect } from '@playwright/test';

test.describe('コンテンツ作成フロー', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // ダッシュボードに移動したことを確認
    await expect(page).toHaveURL(/.*dashboard/);
  });

  test('新しいコンテンツを作成できること', async ({ page }) => {
    // 新規作成ページに移動
    await page.click('text=新規作成');
    await expect(page).toHaveURL(/.*create/);

    // フォームに入力
    await page.fill('input[name="title"]', 'テスト用コンテンツ');
    await page.fill('textarea[name="body"]', 'これはテスト用のコンテンツです。');

    // 保存ボタンをクリック
    await page.click('button:has-text("保存")');

    // 保存成功メッセージが表示されることを確認
    await expect(page.locator('text=コンテンツが保存されました')).toBeVisible();

    // コンテンツ一覧に作成したコンテンツが表示されることを確認
    await page.goto('/dashboard');
    await expect(page.locator('text=テスト用コンテンツ')).toBeVisible();
  });
});
```

## テスト環境

E2Eテストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **テスト用サーバー**
   - ローカル開発サーバーまたはステージング環境を使用

3. **テスト用ブラウザ**
   - 複数のブラウザでテストを実行（Chrome, Firefox, Safari など）
   - モバイルデバイスのエミュレーションも考慮

## テスト実行方法

```bash
# Cypressを使用する場合
npm run test:e2e

# Playwrightを使用する場合
npm run test:e2e:playwright
```

## 4_test_strategy/2_test_structure.md

# テストディレクトリ構造

このドキュメントでは、プロジェクトのテストに関するディレクトリ構造を定義します。適切なテストディレクトリ構造を持つことで、テストの管理と実行が容易になり、コードの品質を確保できます。

## テストディレクトリの基本構造

テストコードは、以下のディレクトリ構造に従って配置します：

```
/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

ルートディレクトリには以下の設定ファイルも配置します：

```
/
├─ jest.config.js                # Jest設定
├─ jest.setup.js                 # Jestセットアップ
└─ playwright.config.ts          # Playwright設定（E2Eテスト用）
```

## テストの種類別の構造

### 単体テスト（Unit Tests）

単体テストは、個々のコンポーネント、関数、フックなどの小さな単位をテストします。

- **テストツール**: Jest + React Testing Library
- **ディレクトリ**: `/__tests__/unit/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: ソースコードの構造を反映する

### 統合テスト（Integration Tests）

統合テストは、複数のコンポーネントや機能が連携して正しく動作することを確認します。

- **テストツール**: Jest + React Testing Library + MSW
- **ディレクトリ**: `/__tests__/integration/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: 機能ごとにグループ化する

### E2Eテスト（End-to-End Tests）

E2Eテストは、実際のユーザーシナリオに沿ってアプリケーション全体が正しく動作することを確認します。

- **テストツール**: Playwright または Cypress
- **ディレクトリ**: `/__tests__/e2e/`
- **ファイル命名規則**: `*.test.ts`
- **構造原則**: ユーザーフローごとにグループ化する

## サポートディレクトリ

### ユーティリティ（Utils）

テスト間で共有される便利な関数やヘルパーを提供します。

- **ディレクトリ**: `/__tests__/utils/`
- **内容**:
  - `test-utils.ts`: 共通ヘルパー関数
  - `renderWithProviders.tsx`: プロバイダー付きのコンポーネントレンダリング
  - カスタムマッチャーなど

### モック（Mocks）

テストで使用するモックデータとリクエストハンドラーを定義します。

- **ディレクトリ**: `/__tests__/mocks/`
- **内容**:
  - `/data/`: モックデータオブジェクト
  - `/handlers/`: MSWリクエストハンドラー
  - `server.ts`: MSWサーバー設定

## テストファイルの配置原則

1. **単体テスト**:
   - テスト対象のソースコードと同じ構造を反映
   - 例：`/components/ui/Button.tsx` → `/__tests__/unit/components/ui/Button.test.tsx`

2. **統合テスト**:
   - 機能やモジュールの連携に焦点を当てた構造
   - 例：認証フロー全体をテスト → `/__tests__/integration/auth/authFlow.test.tsx`

3. **E2Eテスト**:
   - ユーザーストーリーやユースケースに基づく構造
   - 例：ログインフロー → `/__tests__/e2e/auth/login.test.ts`

## テストディレクトリ構造の利点

1. **明確な分離**: テストの種類ごとに明確に分離することで、テストの目的と範囲が明確になる
2. **容易な実行**: 特定の種類のテストのみを実行することが容易
3. **構造の一貫性**: ソースコードの構造を反映することで、テストファイルの場所が予測しやすくなる
4. **再利用性**: ユーティリティとモックを共有することで、コードの重複を減らす

## テスト関連設定ファイル

### Jest設定（jest.config.js）

```javascript
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/_*.{js,jsx,ts,tsx}',
    '!src/**/index.{js,jsx,ts,tsx}',
  ],
};
```

### Jest設定（jest.setup.js）

```javascript
import '@testing-library/jest-dom';
import { server } from './src/__tests__/mocks/server';

// MSWのセットアップ
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### Playwright設定（playwright.config.ts）

```typescript
import { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './src/__tests__/e2e',
  use: {
    baseURL: 'http://localhost:3000',
    headless: true,
    viewport: { width: 1280, height: 720 },
    screenshot: 'only-on-failure',
  },
  reporter: [['html', { outputFolder: 'playwright-report' }]],
};

export default config;
```

## テスト実行コマンド

以下のコマンドをpackage.jsonに追加します：

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=src/__tests__/unit",
    "test:integration": "jest --testPathPattern=src/__tests__/integration",
    "test:e2e": "playwright test",
    "test:coverage": "jest --coverage"
  }
}
```

## まとめ

この構造に従うことで、テストの管理と実行が容易になり、コードの品質を確保できます。テストディレクトリ構造は、プロジェクトの成長に合わせて柔軟に拡張できます。

## 2_test_tools/1_jest.md

# Jest

Jestは、JavaScriptのテストフレームワークで、単体テストと統合テストに使用します。

## 設定

プロジェクトでは、以下の設定でJestを使用します：

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/_*.{js,jsx,ts,tsx}',
    '!src/**/index.{js,jsx,ts,tsx}',
  ],
  testMatch: ['**/__tests__/**/*.test.ts?(x)', '**/?(*.)+(test).ts?(x)'],
};
```

## セットアップファイル

```javascript
// jest.setup.js
// テスト実行前の環境設定
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://example.supabase.co';
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
process.env.OPENAI_API_KEY = 'test-api-key';
```

```javascript
// jest.setup.afterEnv.js
// テスト実行後の環境設定
import '@testing-library/jest-dom';

// グローバルなモックのセットアップ
jest.mock('next/router', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    query: {},
  }),
}));
```

## テスト実行

```bash
# すべてのテストを実行
npm test

# 特定のテストファイルを実行
npm test -- path/to/test.test.ts

# 単体テストのみ実行
npm run test:unit

# 統合テストのみ実行
npm run test:integration

# E2Eテストのみ実行
npm run test:e2e

# テストカバレッジを計測
npm run test:coverage
```

## マッチャー

Jestでは、以下のマッチャーを使用してアサーションを行います：

```typescript
// 値の検証
expect(value).toBe(expected);        // 厳密等価性（===）
expect(value).toEqual(expected);     // 深い等価性
expect(value).toBeDefined();         // undefined でないこと
expect(value).toBeNull();            // null であること
expect(value).toBeTruthy();          // truthy であること
expect(value).toBeFalsy();           // falsy であること

// 数値の検証
expect(value).toBeGreaterThan(expected);
expect(value).toBeLessThan(expected);
expect(value).toBeCloseTo(expected, numDigits);

// 文字列の検証
expect(string).toMatch(/pattern/);
expect(string).toContain(substring);

// 配列の検証
expect(array).toContain(item);
expect(array).toHaveLength(length);

// オブジェクトの検証
expect(object).toHaveProperty(keyPath, value);

// 例外の検証
expect(() => { throw new Error() }).toThrow();
expect(() => { throw new Error('message') }).toThrow('message');

// 非同期コードの検証
await expect(promise).resolves.toBe(value);
await expect(promise).rejects.toThrow();
```

## モック

Jestでは、以下の方法でモックを作成します：

```typescript
// 関数のモック
const mockFn = jest.fn();
mockFn.mockReturnValue(value);
mockFn.mockResolvedValue(value);
mockFn.mockRejectedValue(error);

// モジュールのモック
jest.mock('./path/to/module', () => ({
  functionName: jest.fn(),
}));

// スパイ
const spy = jest.spyOn(object, 'method');
```

## テストの構造

```typescript
// グループ化
describe('グループ名', () => {
  // 前処理
  beforeAll(() => {
    // テスト前の準備（1回のみ）
  });

  beforeEach(() => {
    // 各テスト前の準備
  });

  // テストケース
  it('テスト名', () => {
    // テストコード
  });

  test('テスト名', () => {
    // テストコード
  });

  // 後処理
  afterEach(() => {
    // 各テスト後のクリーンアップ
  });

  afterAll(() => {
    // テスト後のクリーンアップ（1回のみ）
  });
});
```

## React Testing Library

Reactコンポーネントのテストには、React Testing Libraryを使用します：

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '../Button';

describe('Button', () => {
  it('ボタンがレンダリングされること', () => {
    render(<Button>テスト</Button>);

    // テキストでの要素取得
    const button = screen.getByText('テスト');
    expect(button).toBeInTheDocument();

    // ロールでの要素取得
    const buttonByRole = screen.getByRole('button', { name: 'テスト' });
    expect(buttonByRole).toBeInTheDocument();
  });

  it('クリックイベントが発火すること', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>テスト</Button>);

    // fireEventを使用したイベント発火
    const button = screen.getByText('テスト');
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);

    // userEventを使用したイベント発火（より実際のユーザー操作に近い）
    userEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(2);
  });

  it('非同期処理の結果が表示されること', async () => {
    render(<AsyncComponent />);

    // ボタンをクリック
    userEvent.click(screen.getByText('データを取得'));

    // 非同期処理の完了を待機
    await waitFor(() => {
      expect(screen.getByText('データ取得完了')).toBeInTheDocument();
    });
  });
});
```

## 2_test_tools/2_cypress_playwright.md

# Cypress と Playwright

E2Eテストには、CypressとPlaywrightを使用します。どちらも強力なE2Eテストツールですが、用途に応じて使い分けます。

## Cypress

Cypressは、モダンなWebアプリケーションのE2Eテストに特化したツールです。

### 設定

```javascript
// cypress.config.js
const { defineConfig } = require('cypress');

module.exports = defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'src/__tests__/e2e/**/*.test.{js,jsx,ts,tsx}',
    supportFile: 'src/__tests__/e2e/support/e2e.ts',
    setupNodeEvents(on, config) {
      // イベントリスナーの設定
    },
  },
  env: {
    // 環境変数
    apiUrl: 'http://localhost:3000/api',
  },
  viewportWidth: 1280,
  viewportHeight: 720,
});
```

### ディレクトリ構造

```
/src
  └─ /__tests__
      └─ /e2e
          ├─ /flows           # ユーザーフロー別のテスト
          │   ├─ login.spec.ts
          │   └─ content.spec.ts
          ├─ /fixtures        # テストデータ
          │   └─ users.json
          ├─ /support         # ヘルパー関数
          │   ├─ commands.ts
          │   └─ e2e.ts
          └─ /utils           # ユーティリティ
              └─ selectors.ts
```

### テスト例

```typescript
// src/__tests__/e2e/flows/login.spec.ts
describe('ログインフロー', () => {
  beforeEach(() => {
    // テスト前の準備
    cy.visit('/login');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインフォームに入力
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ログイン成功メッセージが表示されることを確認
    cy.contains('ログインに成功しました').should('be.visible');
  });
});
```

### カスタムコマンド

```typescript
// src/__tests__/e2e/support/commands.ts
Cypress.Commands.add('login', (email, password) => {
  cy.visit('/login');
  cy.get('input[name="email"]').type(email);
  cy.get('input[name="password"]').type(password);
  cy.get('button[type="submit"]').click();
  cy.url().should('include', '/dashboard');
});

// 使用例
it('ログイン後にコンテンツを作成できること', () => {
  cy.login('test@example.com', 'password123');
  // 以降のテストコード
});
```

### テスト実行

```bash
# Cypressを開く
npx cypress open

# ヘッドレスモードでテストを実行
npx cypress run

# 特定のテストファイルを実行
npx cypress run --spec "src/__tests__/e2e/flows/login.spec.ts"
```

## Playwright

Playwrightは、複数のブラウザをサポートするE2Eテストツールです。

### 設定

```typescript
// playwright.config.ts
import { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './src/__tests__/e2e',
  testMatch: '**/*.spec.ts',
  use: {
    baseURL: 'http://localhost:3000',
    headless: true,
    viewport: { width: 1280, height: 720 },
    screenshot: 'only-on-failure',
    video: 'on-first-retry',
  },
  projects: [
    {
      name: 'Chrome',
      use: { browserName: 'chromium' },
    },
    {
      name: 'Firefox',
      use: { browserName: 'firefox' },
    },
    {
      name: 'Safari',
      use: { browserName: 'webkit' },
    },
  ],
};

export default config;
```

### ディレクトリ構造

```
/src
  └─ /__tests__
      └─ /e2e
          ├─ /flows           # ユーザーフロー別のテスト
          │   ├─ login.spec.ts
          │   └─ content.spec.ts
          ├─ /fixtures        # テストデータ
          │   └─ users.json
          ├─ /utils           # ユーティリティ
          │   └─ selectors.ts
          └─ /pages           # ページオブジェクト
              ├─ login.page.ts
              └─ dashboard.page.ts
```

### テスト例

```typescript
// src/__tests__/e2e/flows/content.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage } from '../pages/login.page';
import { DashboardPage } from '../pages/dashboard.page';

test.describe('コンテンツ作成フロー', () => {
  let loginPage;
  let dashboardPage;

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
    dashboardPage = new DashboardPage(page);

    // ログイン
    await loginPage.goto();
    await loginPage.login('test@example.com', 'password123');
    await expect(page).toHaveURL(/.*dashboard/);
  });

  test('新しいコンテンツを作成できること', async ({ page }) => {
    // 新規作成ページに移動
    await dashboardPage.clickNewContent();
    await expect(page).toHaveURL(/.*create/);

    // フォームに入力
    await page.fill('input[name="title"]', 'テスト用コンテンツ');
    await page.fill('textarea[name="body"]', 'これはテスト用のコンテンツです。');

    // 保存ボタンをクリック
    await page.click('button:has-text("保存")');

    // 保存成功メッセージが表示されることを確認
    await expect(page.locator('text=コンテンツが保存されました')).toBeVisible();
  });
});
```

### ページオブジェクトパターン

```typescript
// src/__tests__/e2e/pages/login.page.ts
import { Page } from '@playwright/test';

export class LoginPage {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async goto() {
    await this.page.goto('/login');
  }

  async login(email: string, password: string) {
    await this.page.fill('input[name="email"]', email);
    await this.page.fill('input[name="password"]', password);
    await this.page.click('button[type="submit"]');
  }
}
```

### テスト実行

```bash
# すべてのテストを実行
npx playwright test

# 特定のテストファイルを実行
npx playwright test src/__tests__/e2e/flows/login.spec.ts

# UIモードでテストを実行
npx playwright test --ui

# 特定のブラウザでテストを実行
npx playwright test --project=Chrome
```

## Cypress と Playwright の使い分け

### Cypressの利点

- 直感的なUIとデバッグ機能
- 自動リトライ機能
- 豊富なプラグインエコシステム
- 優れたドキュメント

### Playwrightの利点

- 複数のブラウザをサポート（Chrome, Firefox, Safari）
- モバイルエミュレーション
- 高速な実行
- 並列実行のサポート

### 使い分けの指針

- **Cypress**: 単一ブラウザでのテストや、チーム内にCypressの経験者がいる場合
- **Playwright**: 複数ブラウザでのテストや、パフォーマンスが重要な場合

## 共通のベストプラクティス

1. **ページオブジェクトパターンを使用する**
   - テストコードとページの詳細を分離する
   - 再利用性と保守性を向上させる

2. **データ駆動テストを活用する**
   - 同じテストを異なるデータセットで実行する
   - テストケースの網羅性を向上させる

3. **安定したセレクタを使用する**
   - データ属性（`data-testid`など）を使用する
   - CSSクラスやIDに依存しない

4. **テスト環境を適切に設定する**
   - テスト用データベースを使用する
   - テスト前後にデータをクリーンアップする

## 4_test_strategy/README.md

# テスト戦略

このディレクトリには、プロジェクトのテスト戦略に関するドキュメントが含まれています。

## ドキュメント構造

```
/rules/0_common/4_test_strategy/
├── README.md                     # このファイル
├── 1_strategy.md                 # テスト戦略の概要
├── 1_test_types/                 # テストの種類
│   ├── 1_unit_tests.md           # 単体テスト
│   ├── 2_integration_tests.md    # 統合テスト
│   └── 3_e2e_tests.md            # E2Eテスト
├── 2_test_tools/                 # テストツール
│   ├── 1_jest.md                 # Jest
│   └── 2_cypress_playwright.md   # Cypress/Playwright
└── 2_test_structure.md           # テストディレクトリ構造
```

## テスト戦略の概要

テスト戦略では、以下の要素を定義しています：

1. [テスト戦略の概要](mdc:1_strategy.md) - テスト戦略の全体像
2. テストの種類
   - [単体テスト](mdc:1_test_types/1_unit_tests.md) - 個々のコンポーネントや関数のテスト
   - [統合テスト](mdc:1_test_types/2_integration_tests.md) - 複数のモジュールの連携テスト
   - [E2Eテスト](mdc:1_test_types/3_e2e_tests.md) - アプリケーション全体の動作テスト
3. テストツール
   - [Jest](mdc:2_test_tools/1_jest.md) - 単体・統合テスト用フレームワーク
   - [Cypress/Playwright](mdc:2_test_tools/2_cypress_playwright.md) - E2Eテスト用フレームワーク
4. [テストディレクトリ構造](mdc:2_test_structure.md) - テストコードの配置方法

## テストディレクトリ構造

プロジェクトのテストディレクトリ構造の詳細については、[テストディレクトリ構造](mdc:2_test_structure.md)を参照してください。この文書では、テストコードの配置方法、命名規則、ディレクトリ構成などを定義しています。

