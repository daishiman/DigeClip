---
description: バックエンド機能要件
globs: ["**/app/api/**/*.ts", "**/lib/**/*.ts", "**/types/api/**/*.ts", "**/prisma/**/*.ts"]
alwaysApply: false
---
# バックエンド機能要件

## 2_backend_functional_requirements/1_Common_Requirements.md

# バックエンド共通要件

## 概要
このドキュメントは、DigeClipバックエンドの共通要件を定義します。各APIやデータモデルの仕様書から共通部分を抽出し、一元管理することで、要件の重複を避け、整合性を確保します。

> **注意:** 共通技術スタックについては [../../0_common/1_Common_Technology_Stack.md](../../0_common/1_Common_Technology_Stack.md) を参照してください。
> エラーハンドリング、セキュリティ、パフォーマンス、テスト要件などの共通要件については [../../0_common/2_Common_Requirements.md](../../0_common/2_Common_Requirements.md) を参照してください。

## バックエンド固有の要件

### 1. API設計原則
- RESTful APIの設計原則に従う
  - リソース指向の設計
  - 適切なHTTPメソッドの使用（GET, POST, PUT, DELETE）
  - 一貫性のあるエンドポイント命名規則
- OpenAPI（Swagger）仕様に準拠したAPI定義を作成
  - API仕様書の自動生成
  - クライアント側の型定義との連携

### 2. データベース設計
- 正規化されたデータモデル設計
  - 適切なリレーションシップの定義
  - インデックス最適化
- マイグレーション管理
  - バージョン管理されたスキーマ変更
  - ロールバック機能

### 3. バックエンド固有のセキュリティ
- 認証・認可の実装
  - JWTベースの認証
  - ロールベースのアクセス制御
- データ保護
  - 機密データの暗号化
  - PII（個人識別情報）の適切な取り扱い

### 4. バックエンド固有のパフォーマンス最適化
- クエリ最適化
  - N+1問題の回避
  - 効率的なJOIN操作
- キャッシュ戦略
  - 頻繁にアクセスされるデータのキャッシュ
  - キャッシュ無効化の適切な管理

### 5. バックエンド固有のテスト
- ユニットテスト
  - 各関数・メソッドの単体テスト
  - モックを活用した依存関係の分離
- 統合テスト
  - APIエンドポイントの結合テスト
  - データベース操作を含むテスト

## 1_data/1_Database_Selection.md

---
## データベースの選定

### 1. 選定対象

- **RDB**: MySQL / PostgreSQL / SQL Server 等
- **NoSQL**: MongoDB / Firebase Realtime DB / DynamoDB 等
- **DBaaS**: Supabase / PlanetScale / MongoDB Atlas 等

お金をかけず、経験の浅いエンジニアでも導入・運用しやすいことを最優先に、**無料枠があり、学習コストが低い**サービスを中心に検討します。

---

### 2. 選定基準

1. **トランザクションの重要度**
   - ユーザーが閲覧するデータは整合性がそこまで厳格ではなくても可
   - しかし、AIモデル設定や管理情報、要約結果は**一貫性**が必要

2. **データ量の見込み**
   - 新着コンテンツの本文/字幕テキスト、要約結果などが増加する可能性あり
   - ただし初期は中～小規模 (数万レコード程度) で収まる見込み

3. **拡張性 (スケールアウト)**
   - 将来、動画数/論文数が莫大になった場合に対応
   - シャーディングやレプリケーションのオプション

4. **導入・運用コスト**
   - 無料枠の有無、または安価なプランがあるか
   - 経験の浅いエンジニアでも簡単に管理できるGUI or CLI

5. **コミュニティ・サポート**
   - エラーや不明点が出たときに解決しやすい
   - ドキュメントやチュートリアルが充実

---

### 3. 結論と理由

- **採用DB**: **Supabase (PostgreSQL)**
  1. **理由:**
     - **無料枠**があり、初期コストゼロで始められる
     - 本質は PostgreSQL ベースなので RDB の一貫性を維持できる
     - ブラウザで操作できる **Supabase Studio** があり、初心者でも GUI で確認・編集が容易
     - 認証やリストの閲覧にも組込み機能がある (必要に応じて活用)
     - 将来的に**有料プラン**へのアップグレードや**Vercel/Edge Functions**との親和性も高い

- **補足**:
  - NoSQL (例: MongoDB) も検討したが、要約結果やタグとの関連を考慮し、**リレーションが扱いやすい** PostgreSQL 系を優先
  - PlanetScale (MySQL) なども選択肢に入るが、Supabase の UI がより初心者向けと判断

---

### 4. 今後の拡張可能性

1. **スケールアウト**
   - Supabase の有料プラン / PostgreSQL のスケーラビリティ (読み込みレプリカ等)
   - データ量増加時もプラン変更だけで対応可能

2. **シャーディング / レプリケーション**
   - 大規模負荷が想定される場合、PostgreSQL でシャーディング可能 (将来検討)
   - まずは無料枠で簡単に始め、需要に応じてオートスケール

3. **バックアップ / 監査**
   - Supabase が自動バックアップを提供（プランによる）
   - 重要データ（AIモデル設定や要約履歴）は適宜エクスポート検討

4. **柔軟な拡張**
   - 新テーブル（例: ユーザーアクティビティログ、翻訳データ等）の追加が容易
   - GraphQL アドオンや Storage 機能など Supabase の拡張機能も順次活用可

---

### 5. データベース運用管理

1. **マイグレーション管理**
   - **ツール**: Prisma を使用してマイグレーションを管理
   - **開発環境での変更手順**:
     1. スキーマ変更: `schema.prisma` ファイルを編集
     2. マイグレーション作成: `npx prisma migrate dev --name 変更内容の説明`
     3. 型の更新: `npx prisma generate`
   - **本番環境への適用**:
     1. 環境変数設定: `.env` ファイルで `DATABASE_URL` を本番データベースに設定
     2. マイグレーション適用: `npx prisma migrate deploy`
     3. 注意: 本番適用前に必ずバックアップを取得すること
   - **ロールバック方法**:
     1. バックアップからの復元が基本
     2. 必要に応じて前のマイグレーションに戻す操作を新たなマイグレーションとして作成

2. **バックアップと復元**
   - **定期バックアップ**:
     - Supabase コンソールの「Backups」機能で自動バックアップ (無料プランでは限定機能)
     - 重要データは定期的に CSV/JSON 形式でエクスポート (管理画面から手動実行)
   - **手動バックアップ**:
     - Supabase CLI: `supabase db dump -f backup.sql`
     - または PostgreSQL 直接アクセス: `pg_dump -U postgres -h db.xxxx.supabase.co -p 5432 postgres > backup.sql`
   - **復元手順**:
     - Supabase コンソールからバックアップ選択して復元
     - または CLI/pg_restore で復元: `psql -U postgres -h db.xxxx.supabase.co -p 5432 postgres < backup.sql`

3. **環境管理**
   - **環境分離**:
     - 開発環境: ローカル PostgreSQL または開発用 Supabase プロジェクト
     - テスト環境: 必要に応じて別 Supabase プロジェクト
     - 本番環境: 本番用 Supabase プロジェクト
   - **環境変数**:
     - 各環境の `DATABASE_URL` を `.env` ファイルで管理
     - 本番環境変数は安全に管理（Vercel の Environment Variables など）

4. **セキュリティ管理**
   - **APIキー管理**:
     - Supabase のサービスロールキーは厳重に管理
     - アプリケーションでは匿名ロールまたは認証済みロールを使用
   - **RLS (Row Level Security)**:
     - テーブルごとに適切な RLS ポリシーを設定
     - 機密データへのアクセス制限を実装
   - **暗号化**:
     - API キーなどの機密情報は暗号化して保存
     - PgCrypto 拡張機能を使用した列レベルの暗号化も検討

5. **監視とトラブルシューティング**
   - **パフォーマンス監視**:
     - Supabase ダッシュボードでクエリパフォーマンスを確認
     - 遅いクエリの特定と最適化
   - **エラー対応**:
     - マイグレーションエラー: エラーログを確認し、問題箇所を修正
     - 接続エラー: ネットワーク設定や認証情報の確認
     - クエリエラー: SQL 構文やスキーマの整合性をチェック

---

**まとめ**
- **Supabase** (PostgreSQL) を採用することで、**お金をかけず**に**初心者が始めやすい**DB環境を構築可能。
- Prisma によるマイグレーション管理で安全かつ効率的なスキーマ変更を実現。
- 適切なバックアップ戦略と環境管理で、データの安全性を確保。
- 将来的に大規模化した際もアップグレードやレプリケーションで対応できるため、**拡張性**にも優れる。
- 別の DBaaS への移行も PostgreSQL ならある程度容易なため、**リスク低減**にもつながる。
```

## 1_data/2_Schema_Design.md

## テーブル・コレクション設計

### 1. ER 図 / スキーマ概要

```mermaid
erDiagram
    sources ||--o{ contents : "1対多"
    sources ||--o{ summaries : "1対多"
    contents ||--o{ content_tags : "1対多"
    tags ||--o{ content_tags : "1対多"
    ai_models ||--o{ summaries : "1対多"
    contents ||--o{ notifications : "1対多"
    users ||--o{ notifications : "1対多"
    sources ||--o| youtube_sources : "1対0または1"
    sources ||--o| rss_sources : "1対0または1"
    sources ||--o| arxiv_sources : "1対0または1"
    app_settings
```

**説明:**
- **sources** テーブルと **contents** テーブルが1対多
  - 1つのソース(sources)に対し、複数のコンテンツ(contents)が紐づく (YouTubeチャンネル → N件の動画)
- **contents** と **summaries** は1対多
  - 1つのコンテンツに対して、**複数のステップ要約結果**や**複数AIモデルの要約**が存在可能
  - （AI要約を段階的に実行する場合、それぞれをレコードとして保存）
- **contents** と **tags** は中間テーブル (**content_tags**) で多対多
- **notifications** は各コンテンツの通知履歴（誰がいつ送ったか、成功/失敗など）
- **users** と **notifications** が1対多 (通知操作を行ったユーザーを記録する等)
- **sources** と **youtube_sources**/**rss_sources**/**arxiv_sources** は1対0または1
  - ソースタイプごとに固有の情報を別テーブルで管理
- **app_settings** はシステム全体の設定を単純なキー/バリュー形式で保存

---

### 2. テーブル定義例

#### 1. **sources** (監視対象の基本情報)

| カラム名        | 型            | 主キー | 備考                                        |
|----------------|---------------|-------|---------------------------------------------|
| `id`           | SERIAL        | ○     | ユニークID (AUTO INCREMENT)                 |
| `name`         | VARCHAR(100)  | ×     | ソース名 (例: "TechYouTuber", "BlogX"など)     |
| `type`         | VARCHAR(50)   | ×     | ソース種別 (youtube / rss / arxiv など)       |
| `active`       | BOOLEAN       | ×     | 有効/無効フラグ                               |
| `last_checked` | TIMESTAMP     | ×     | 最終チェック日時                              |
| `created_at`   | TIMESTAMP     | ×     | 作成日時 (DEFAULT now())                     |
| `updated_at`   | TIMESTAMP     | ×     | 更新日時 (トリガ/アプリで自動更新)            |

#### 2. **youtube_sources** (YouTube固有情報)

| カラム名           | 型            | 主キー | 備考                                        |
|-------------------|---------------|-------|---------------------------------------------|
| `source_id`       | INT           | ○     | sources.id へのFK                           |
| `channel_id`      | VARCHAR(100)  | ×     | YouTubeチャンネルID                         |
| `channel_url`     | TEXT          | ×     | チャンネルURL                               |
| `feed_url`        | TEXT          | ×     | RSSフィードURL                              |
| `subscriber_count`| INT           | ×     | チャンネル登録者数                           |
| `thumbnail_url`   | TEXT          | ×     | チャンネルサムネイルURL                      |
| `metadata`        | JSONB         | ×     | その他のメタデータ                           |

#### 3. **rss_sources** (RSS/ブログ固有情報)

| カラム名           | 型            | 主キー | 備考                                        |
|-------------------|---------------|-------|---------------------------------------------|
| `source_id`       | INT           | ○     | sources.id へのFK                           |
| `site_url`        | TEXT          | ×     | サイトURL                                   |
| `feed_url`        | TEXT          | ×     | RSSフィードURL                              |
| `language`        | VARCHAR(10)   | ×     | 言語コード (ja, en など)                     |
| `favicon_url`     | TEXT          | ×     | ファビコンURL                               |
| `metadata`        | JSONB         | ×     | その他のメタデータ                           |

#### 4. **arxiv_sources** (arXiv固有情報)

| カラム名           | 型            | 主キー | 備考                                        |
|-------------------|---------------|-------|---------------------------------------------|
| `source_id`       | INT           | ○     | sources.id へのFK                           |
| `category`        | VARCHAR(50)   | ×     | カテゴリ (cs.AI, cs.CL など)                |
| `query`           | TEXT          | ×     | 検索クエリ                                  |
| `metadata`        | JSONB         | ×     | その他のメタデータ                           |

#### 5. **contents** (動画/論文/記事など取得したコンテンツ)

| カラム名        | 型           | 主キー | 備考                                        |
|----------------|--------------|-------|---------------------------------------------|
| `id`           | SERIAL       | ○     | ユニークID (AUTO INCREMENT)                 |
| `source_id`    | INT          | ×     | sources.id へのFK                           |
| `external_id`  | VARCHAR(255) | ×     | YouTube動画ID, ブログ記事ID, 論文IDなど      |
| `title`        | TEXT         | ×     | コンテンツのタイトル                        |
| `description`  | TEXT         | ×     | 説明文 (要約とは別)                          |
| `url`          | TEXT         | ×     | 直接リンク(YouTube動画URL, 論文URL等)         |
| `type`         | VARCHAR(50)  | ×     | (動画/論文/ブログ等)                         |
| `published_at` | TIMESTAMP    | ×     | 公開日時 (RSSやAPIから取得)                  |
| `raw_text`     | TEXT         | ×     | テキスト本文 (字幕や記事の全文など)           |
| `metadata`     | JSONB        | ×     | サムネURL等、追加メタ情報                     |
| `status`       | VARCHAR(50)  | ×     | 要約済み / 未要約 / エラー 等                |
| `notified_at`  | TIMESTAMP    | ×     | 通知済み日時                                  |
| `created_at`   | TIMESTAMP    | ×     | 作成日時                                     |
| `updated_at`   | TIMESTAMP    | ×     | 更新日時                                     |

#### 6. **ai_models** (AIモデル設定)

| カラム名            | 型           | 主キー | 備考                                                      |
|--------------------|--------------|-------|-----------------------------------------------------------|
| `id`               | SERIAL       | ○     | ユニークID                                                |
| `name`             | VARCHAR(100) | ×     | モデル表示名 (例: "GPT-3.5", "Claude-v1")                  |
| `provider`         | VARCHAR(50)  | ×     | OpenAI, Anthropic, Googleなど                             |
| `model_id`         | VARCHAR(100) | ×     | 実際のモデル指定 (例: "gpt-3.5-turbo")                     |
| `api_key_encrypted`| TEXT         | ×     | APIキー(暗号化 or 非表示)                                 |
| `default_settings` | JSONB        | ×     | トークン数等の既定パラメータ                              |
| `active`           | BOOLEAN      | ×     | 有効/無効フラグ                                           |
| `is_default`       | BOOLEAN      | ×     | デフォルト使用モデルかどうか                              |
| `created_at`       | TIMESTAMP    | ×     | 作成日時                                                  |
| `updated_at`       | TIMESTAMP    | ×     | 更新日時                                                  |

#### 7. **summaries** (要約結果)

| カラム名         | 型         | 主キー | 備考                                                                |
|-----------------|------------|-------|---------------------------------------------------------------------|
| `id`            | SERIAL     | ○     | ユニークID                                                          |
| `content_id`    | INT        | ×     | contents.id へのFK                                                  |
| `ai_model_id`   | INT        | ×     | ai_models.id へのFK                                                 |
| `stage`         | VARCHAR(50)| ×     | 要約の段階 (例: "概要", "見出し", "詳細" など可変)                    |
| `summary_text`  | TEXT       | ×     | 要約本文                                                             |
| `prompt_used`   | TEXT       | ×     | 要約生成に使ったプロンプト (オプション)                              |
| `tokens_used`   | INT        | ×     | 消費トークン数 (将来のコスト計算に使える)                            |
| `processing_time` | INT      | ×     | 要約処理にかかった時間(ms等)                                         |
| `metadata`      | JSONB      | ×     | 追加情報（スコア等）                                                 |
| `created_at`    | TIMESTAMP  | ×     | 作成日時                                                            |

**ポイント**:
- **`stage`** カラムを追加し、複数段階の要約(概要→見出し→詳細 など)を柔軟に保存
- 例えば同じ content_id に対して stage="overview", stage="heading", stage="detail" 等を追加可能

#### 8. **notifications** (通知履歴)

| カラム名       | 型         | 主キー | 備考                                                                |
|---------------|------------|-------|---------------------------------------------------------------------|
| `id`          | SERIAL     | ○     | ユニークID                                                          |
| `content_id`  | INT        | ×     | contents.id へのFK                                                  |
| `summary_id`  | INT        | ×     | summaries.id へのFK (どの要約を使って通知したか)                     |
| `destination` | TEXT       | ×     | 送信先 (Discord Webhook URL 等)                                     |
| `status`      | VARCHAR(50)| ×     | 成功/失敗                                                           |
| `metadata`    | JSONB      | ×     | 実際に送信したEmbed内容やエラーメッセージなど                         |
| `sent_at`     | TIMESTAMP  | ×     | 送信完了日時                                                         |
| `created_at`  | TIMESTAMP  | ×     | レコード作成日時                                                    |

#### 9. **tags** (タグ管理)

| カラム名     | 型           | 主キー | 備考                                      |
|-------------|--------------|-------|-------------------------------------------|
| `id`        | SERIAL       | ○     | ユニークID                                |
| `name`      | VARCHAR(100) | ×     | タグ名 (例: "AI", "Tech", "論文")           |
| `color`     | VARCHAR(20)  | ×     | カラーコード(hex等)                       |
| `created_at`| TIMESTAMP    | ×     | 作成日時                                  |

#### 10. **content_tags** (コンテンツとタグの中間テーブル)

| カラム名      | 型       | 主キー | 備考                             |
|--------------|----------|-------|----------------------------------|
| `content_id` | INT      | ×     | contents.id へのFK               |
| `tag_id`     | INT      | ×     | tags.id へのFK                   |
| `created_at` | TIMESTAMP| ×     | レコード作成日時                 |

#### 11. **users** (管理者ユーザー)

| カラム名       | 型           | 主キー | 備考                                                    |
|---------------|--------------|-------|---------------------------------------------------------|
| `id`          | SERIAL       | ○     | ユニークID                                              |
| `email`       | VARCHAR(255) | ×     | ログイン用メールアドレス                                |
| `name`        | VARCHAR(100) | ×     | ユーザー表示名                                          |
| `password_hash` | TEXT       | ×     | パスワードのハッシュ (bcrypt等)                          |
| `role`        | VARCHAR(50)  | ×     | 管理者 / 一般ユーザーなど                                |
| `last_login`  | TIMESTAMP    | ×     | 最終ログイン日時                                         |
| `created_at`  | TIMESTAMP    | ×     | 作成日時                                                |
| `updated_at`  | TIMESTAMP    | ×     | 更新日時                                                |

#### 12. **app_settings** (システム設定)

| カラム名   | 型           | 主キー | 備考                                      |
|-----------|--------------|-------|-------------------------------------------|
| `key`     | VARCHAR(100) | ○     | 設定項目名 (例: "cron_youtube_interval")   |
| `value`   | TEXT         | ×     | 設定値                                     |
| `description`| TEXT      | ×     | 項目の説明                                 |
| `updated_at` | TIMESTAMP | ×     | 更新日時                                  |

---

### 3. 正規化・冗長化の方針

- 基本的には **第3正規形** 付近を目標にしつつ、将来の柔軟性のために **JSONB (metadata)** を併用
- **ソースタイプごとに別テーブル**を用意し、固有情報を適切に管理
  - 各ソースタイプの特性に合わせたカラムを定義し、検索や管理を容易に
  - 共通情報は **sources** テーブルに保持
- 要約結果 (summaries) を **content_id** + **ai_model_id** + **stage** で差異を管理し、
  - 同一コンテンツに対して「概要」「見出し」「詳細」など複数段階の要約を保持
- タグは多対多のため **content_tags** で管理
- インポートや機能追加に備え、**metadata** カラムをうまく活用してスキーマ変更を最小限に

---

### 4. インデックス戦略

- **sources (type)**: ソースタイプ別検索に対応
- **youtube_sources (channel_id)**: YouTubeチャンネルIDでの検索を高速化
- **rss_sources (feed_url)**: フィードURLでの検索を高速化
- **contents (source_id)**: ソース別検索に対応
- **contents (external_id)**: 一意制約 or ユニークインデックス (同じ外部IDを2重登録しないように)
- **summaries (content_id, ai_model_id, stage)**: 同一コンテンツ+モデル+段階の組合せで取得高速化
- **notifications (content_id)**: コンテンツ別通知履歴検索
- **tags (name)**: ユニークにするかは運用次第
- **users (email)**: ログイン用にユニークインデックス

Supabase(PostgreSQL)環境なら **JSONB** 用の GIN インデックスも検討可能。

---

### 5. 今後の拡張

1. **追加カラム (例: translations, rating)**
   - AI要約をさらに翻訳した結果や品質評価を保存したい場合、**summaries** テーブルに `metadata` を活用する or カラム追加
2. **データマイグレーション**
   - Supabase CLI / バージョン管理ツールを使って安全に実施
   - 大量データ移行時はバックアップ必須
3. **大規模化**
   - Supabase 有料プラン or PostgreSQL レプリケーション対応
   - 需要が増えたら シャーディング / テーブル分割
4. **AI要約の段階的ステップ**
   - "概要"(stage="overview") → "見出し"(stage="heading") → "詳細"(stage="detail") …
   - ステップ数は不定でも, `stage` 列があれば柔軟に対応可能
5. **全文検索**
   - raw_text が増大し検索需要が高まれば PostgreSQLの全文検索 or Elasticsearchを追加
6. **監査ログ / アクセス履歴**
   - 大量発生時に別テーブルor外部ストレージを利用

---

**まとめ**
- スキーマ定義は**段階的なAI要約**に対応するため、**summaries** テーブルに**`stage`** カラムを追加
- **ソースタイプごとに別テーブル**を用意し、固有情報を適切に管理することで重複コンテンツの防止や検索性を向上
- **JSONB** カラムを活用し、柔軟かつ小さな変更で拡張が可能
- 初期は Supabase (PostgreSQL) の無料枠で運用し、**データ量・負荷が増えれば有料プランやレプリケーション**に移行
- これにより「**お金をかけずに**」「**容易に**」「**将来的な機能追加**」にも対応できるデータ構造を実現。

## 1_data/3_Data_Lifecycle.md

## データライフサイクル (保存期間・バックアップ)

### 1. データ保存期間

**概要:**
本システムでは、**お金をかけずに、経験の浅いエンジニアでも**運用しやすいよう、**保存期間を無期限**とします。
データが増えすぎた場合や運用上の問題が出てきた場合、将来的に手動/自動での削除やアーカイブ機能を追加検討します。

1. **ユーザー情報 (users テーブル)**
   - **保存期間:** **無期限**
   - **削除ポリシー:** 不要になったユーザー (退職/退会など) を手動で削除
   - **将来拡張:** GDPR等対応が必要な場合、自動削除ルールを検討

2. **取得したコンテンツ (contents テーブル)**
   - **保存期間:** **無期限**
   - **削除ポリシー:** 現時点では削除/アーカイブの運用を行わない
   - **将来拡張:** データ量が大きくなり過ぎた場合、古いデータを手動 or 自動で削除/アーカイブ

3. **要約結果 (summaries テーブル)**
   - **保存期間:** **無期限** (コンテンツと連動)
   - **段階的な要約** (概要/見出し/詳細など) もすべて保持
   - **将来拡張:** 量が増加し過ぎたら古い要約を手動/自動で整理

4. **通知履歴 (notifications テーブル)**
   - **保存期間:** **無期限**
   - **用途:** トラブル調査, 通知送信状況確認
   - **将来拡張:** 大量データによるパフォーマンス懸念が出た際に別テーブル or ログ管理システムへ移行

5. **ログ情報 (DB操作ログ / アクセスログ等)**
   - **保存場所:** Supabase のログ or 外部ロギングサービス
   - **保存期間:** デフォルト(無期限) / サービス仕様上の最大期間
   - **将来拡張:** 有料プランや外部ツールで期限設定を行う可能性

---

### 2. バックアップポリシー

1. **フルバックアップ**
   - **取得頻度:** 原則1日1回 (夜間) を理想とするが、無料枠制限に応じて調整
   - **保存先:** Supabase の自動バックアップ or 手動ダンプ
   - **保存期間:** Supabase で提供される範囲内
   - **運用方法:**
     - **開発環境:** 必要に応じて手動バックアップ
     - **本番環境:** 毎日夜間に自動バックアップ（可能であれば）
     - **責任者:** システム管理者が定期確認
     - **確認事項:** バックアップログ、エラー通知の確認

2. **増分バックアップ (将来検討)**
   - 初期は不要
   - 大規模化や可用性要件が上がった場合に導入を検討

3. **オフライン/外部へのエクスポート**
   - **頻度:** 重要な設定変更時、または月1回程度
   - **対象データ:**
     - 重要データ(要約/AIモデル設定など)を手動でエクスポート
     - 特に暗号化したAPIキー等は念のため別途バックアップ
   - **保存先:** ローカルストレージ、クラウドストレージ（S3、Dropboxなど）
   - **形式:** CSV、JSON、SQLダンプなど
   - **手順:**
     1. Supabaseダッシュボードからテーブルごとにエクスポート
     2. または `supabase db dump` コマンドでエクスポート
     3. 暗号化またはパスワード保護してストレージに保存
     4. 定期的に復元テストを実施

---

### 3. リカバリ手順

1. **Supabaseコンソールでリストア**
   - **シナリオ:** データ破損、誤った操作、マイグレーション失敗など
   - **手順:**
     1. Supabaseダッシュボードにログイン
     2. 「Settings」→「Database」→「Backups」へ移動
     3. バックアップ一覧から必要な日時を選択
     4. リストア操作を実行
     5. リストア完了後、データ整合性を確認
   - **注意事項:** リストア中はサービスが一時的に停止する可能性あり
   - **復旧時間の目安:** 10分〜1時間（データ量により変動）

2. **手動ダンプファイルの適用** (大規模運用時)
   - **シナリオ:** Supabaseのリストア機能が使えない場合や部分的な復元
   - **必要ツール:** PostgreSQL CLI (psql, pg_restore)
   - **手順:**
     1. ダンプファイルを用意（事前バックアップから）
     2. テスト環境で復元テスト: `pg_restore -U postgres -h host -d dbname backup.sql`
     3. 問題なければ本番環境で同様に実行
     4. テーブル単位の復元も可能: `psql -U postgres -h host -d dbname -c "COPY table FROM 'file.csv' CSV HEADER"`
   - **障害発生時の対応チーム:** 技術リード + DBに詳しいメンバー

3. **DR(ディザスタリカバリ)計画** (将来拡張)
   - 無料枠段階では基本的に考慮しない
   - 本格的な可用性要件が出てきた場合、有料プランや別リージョンレプリケーションを導入

4. **マイグレーションの失敗対応**
   - **シナリオ:** Prismaマイグレーション実行時のエラー
   - **対応手順:**
     1. エラーログを確認し問題箇所を特定
     2. 開発環境でマイグレーションをロールバック（新しいマイグレーションファイルで元に戻す）
     3. 修正したマイグレーションを作成
     4. 本番環境適用前に必ずテスト環境で検証
   - **緊急時のロールバック:** バックアップからのリストアが最も確実

---

### 4. データ削除・アーカイブ

1. **削除のタイミング**
   - 当面は**無期限**保存を基本方針
   - 手動で不要データを削除 or アーカイブする運用

2. **アーカイブ先**
   - Supabase の別テーブルに移行
   - ローカルCSV/Excel or S3 など外部ストレージへのエクスポート
   - 大量データの場合にのみ対応検討

3. **手動/自動の手順**
   - 初期リリースでは**手動運用**を前提とし、管理者がスクリプトやSupabaseコンソールで削除
   - 将来的に要望があれば**Vercel Cron** 等で自動化

---

### 5. 環境別データ管理方針

1. **開発環境**
   - **データ特性:** テストデータ中心、容量制限なし
   - **バックアップ頻度:** 大きな変更時のみ手動バックアップ
   - **復元ポリシー:** 問題発生時に手動復元
   - **アクセス権限:** 開発チーム全員がフル権限

2. **テスト環境** (必要に応じて)
   - **データ特性:** 本番に近いデータセット（機密情報マスク済み）
   - **バックアップ頻度:** テスト前後
   - **復元ポリシー:** テストケース実行ごとにリセット可能
   - **アクセス権限:** QAチーム、開発リーダー

3. **本番環境**
   - **データ特性:** 実データ、保全性最重視
   - **バックアップ頻度:** 日次（自動）+ 大きな変更前（手動）
   - **復元ポリシー:** 障害時のみ、管理者承認必須
   - **アクセス権限:** 厳格に制限（管理者のみデータ変更可）
   - **監視体制:** パフォーマンス指標、エラーログを定期確認

---

**まとめ**
- **無期限保存**を基本とし、将来的に肥大化した場合に備えて**手動/自動アーカイブ**の仕組みを追加できる設計
- バックアップは**Supabaseの自動バックアップ**と**手動ダンプ**を組み合わせ、**簡易リカバリ**ができる体制
- 環境ごとに適切なデータ管理ポリシーを設定し、本番環境のデータ保全性を最重視
- **マイグレーション失敗時**の対応手順を明確化し、迅速な復旧を可能に
- 大規模/高可用性要件が出たら**有料プラン**や**別リージョンレプリケーション**を視野に入れる
- **初心者にも分かりやすい**運用フローで、段階的に拡張できる方針とする。

## 1_data/4_Privacy_Compliance.md

```markdown
---
## 個人情報・機密情報の取扱い

### 1. 収集データ一覧

**概要:**
このシステムでは、主に **ユーザー情報**（管理者ユーザー用）、**コンテンツ情報**（YouTube 字幕・ブログ本文・論文テキスト等の一部に個人情報が含まれる可能性）や **AIモデル設定**（APIキーなど機密要素）を扱う場合があります。現在は必要最小限の要件を定義し、**将来的に機能追加**しやすい設計とする方針です。

1. **ユーザー情報 (users テーブル)**
   - 氏名（任意・表示名）
   - メールアドレス (ログインID)
   - パスワードハッシュ
   - ロール（管理者/一般など）
   - **将来拡張:** 氏名・住所などの追加情報や SNS 連携が必要な場合に備えて `metadata` JSON カラムで対応可

2. **コンテンツ情報**
   - YouTube動画の字幕テキスト、ブログ本文、論文抄録など
   - 一部個人名・連絡先が含まれる可能性
   - AI要約生成時に個人情報を含むテキストが要約結果に出るリスク
   - **対策:** 不要部分をフィルタ or ユーザーが確認して削除できる機能 (将来対応)

3. **AIモデル設定 (ai_models テーブル)**
   - APIキー(暗号化保存)
   - モデル名、プロバイダ情報
   - **将来拡張:** 複数キー管理や期限付きキーの更新プロセス

4. **通知履歴 (notifications)**
   - 送信先 (Discord Webhook URL など)
   - 実際に送信した Embed 内容 (要約テキストを含む)
   - 個人情報が含まれる場合に注意が必要

---

### 2. 暗号化要件

1. **保存データ暗号化**
   - **APIキーなど機密情報**は暗号化 (例: AES256) か、少なくとも Base64+別管理キー
   - パスワード: **ハッシュ (bcrypt, Argon2 など)** で保存
   - 個人情報（氏名/メールアドレス等）は、DB上で平文でも可（最小限）だが、将来公的規制に合わせ暗号化しやすい設計に

2. **通信経路暗号化**
   - **HTTPS/TLS** を必須 (Vercelの無料HTTPSや Supabaseの暗号化通信)
   - Discord Webhook 通信も HTTPS で行われる

3. **パスワードハッシュ方式**
   - **bcrypt** または **Argon2** を推奨
   - ソルト付き、ストレッチ回数を設定 (デフォルトで十分)

4. **将来拡張: KMSとの連携**
   - 高度なセキュリティ要件が出てきた場合、 AWS KMS / GCP KMS / HashiCorp Vault などで管理

---

### 3. 規制・ガイドライン順守

1. **GDPR, Pマーク, CCPA** など
   - 現状は国内中心の小規模運用を想定し、**正式な個人情報保護規定**には簡易対応
   - 将来的に欧州ユーザーや大規模導入が想定される場合、**データ削除請求 (Right to be Forgotten)** やクッキー同意などの機能を追加
   - 現段階では「無期限保存」方針だが、要望や規制がある場合は**データ削除要請に対応する仕組み**を準備

2. **利用規約/プライバシーポリシー**
   - 必要最小限の文書を用意し、個人情報をどう扱うか明示
   - 将来ステークホルダーや法務の意見で改定

3. **ログ・監査**
   - 大きなセキュリティ規制は未対応だが、**Supabaseの監査ログ**や**Vercelのデプロイ履歴**で簡易的に対応
   - 本格的に監査や認証が必要な時は**ISO27001 / SOC2** 等のフレームワーク準拠を検討

---

### 4. 機密情報漏洩対策

1. **権限管理**
   - 管理画面 (Admin) は認証必須、**role** カラムでアクセス制御
   - 一般ユーザー: 要約閲覧やタグ編集程度
   - 将来、大企業向けなら**RBAC**(Role-Based Access Control) の細分化

2. **ログ監査**
   - Supabase やアプリ側で主要操作(ソース追加, AIモデル追加等) のログを記録
   - 変更履歴をDBに保存 or Slack通知(将来オプション)

3. **インシデント報告フロー**
   - 漏洩や不正アクセスが疑われる場合、PM/POへ即時報告 → 障害対応手順書(将来作成)に従う
   - クリティカルならAPIキーを即無効化、DBを一時停止等

4. **機能追加時のセキュリティ考慮**
   - 新機能で個人情報増やす際は暗号化やアクセス制限を再確認
   - APIルートごとにCSRF対策 / JWTの更新等を検討

---

**まとめ**
- 現段階では**最小限の個人情報**（メールアドレス、パスワードハッシュなど）のみ扱い、DB上は平文でも可
- **APIキー**や**パスワード**など機密情報は暗号化orハッシュで安全に保存
- 将来、大規模化や法的要件増大時に**GDPR対応**や**大規模監査ログ管理**を拡張しやすい構成
- お金をかけず、初心者が扱いやすいように**無料プラン + 簡易運用**でスタートし、必要に応じて追加対策していく。
```

## 2_backend_functional_requirements/2_Backend_Technology_Stack.md

# バックエンド技術スタック

> **注意:** このドキュメントでは、バックエンド固有の技術スタックと実装方針を定義します。共通技術スタックについては [../../0_common/1_Common_Technology_Stack.md](../../0_common/1_Common_Technology_Stack.md) を参照してください。共通要件（エラーハンドリング、セキュリティ、パフォーマンスなど）については [../../0_common/2_Common_Requirements.md](../../0_common/2_Common_Requirements.md) を参照してください。バックエンド固有の共通要件については [1_Common_Requirements.md](1_Common_Requirements.md) を参照してください。ディレクトリ構造については [../../0_common/3_Directory_Structure.md](../../0_common/3_Directory_Structure.md) を参照してください。コーディング規約については [../../0_common/4_Coding_Conventions.md](../../0_common/4_Coding_Conventions.md) を参照してください。

## 1. バックエンド固有の技術選定

### サーバーフレームワーク

1. **Next.js API Routes / App Router API**
   - フロントエンドと同じリポジトリで管理可能
   - TypeScriptとの相性が良い
   - Vercelでのデプロイが容易
   - サーバーレス関数として実行

2. **Express.js**（必要に応じて）
   - 軽量で柔軟なNode.jsフレームワーク
   - 豊富なミドルウェア
   - ルーティング機能
   - エラーハンドリング

---

### データベース

1. **Supabase**
   - PostgreSQLベースのBaaS（Backend as a Service）
   - 認証機能内蔵
   - リアルタイム機能
   - RESTおよびGraphQL API
   - 無料枠あり

2. **Prisma ORM**
   - TypeScriptファーストのORM
   - 型安全なデータベースアクセス
   - マイグレーション管理
   - データモデリングが簡単

---

### 認証

1. **NextAuth.js / Auth.js**
   - 複数の認証プロバイダーをサポート
   - セッション管理
   - JWTサポート
   - Next.jsとの統合が容易

2. **Supabase Auth**
   - メール/パスワード認証
   - ソーシャルログイン
   - MFA（多要素認証）
   - RLS（Row Level Security）

---

### API開発

1. **tRPC**（オプション）
   - エンドツーエンドの型安全なAPI
   - クライアント-サーバー間の型共有
   - 自動補完サポート
   - Next.jsとの統合が容易

2. **OpenAPI / Swagger**
   - API仕様の標準化
   - ドキュメント自動生成
   - クライアントコード生成
   - API検証

---

### ファイルストレージ

1. **Supabase Storage**
   - オブジェクトストレージ
   - アクセス制御
   - 画像変換
   - CDN配信

2. **Vercel Blob**
   - 簡単な統合
   - CDN配信
   - 無料枠あり

---

### バックエンドテスト

1. **Jest**
   - ユニットテスト
   - モック機能
   - カバレッジレポート
   - スナップショットテスト

2. **Supertest**
   - APIエンドポイントテスト
   - HTTPリクエスト/レスポンステスト
   - 統合テスト

## 2_api/0_Common_Requirements.md

# バックエンド共通要件

## 概要

このドキュメントでは、DigeClipバックエンドの共通要件を定義します。すべてのバックエンド実装はこれらの要件に準拠する必要があります。

> **注意:** 共通技術スタックについては [../../0_common/1_Common_Technology_Stack.md](../../0_common/1_Common_Technology_Stack.md) を参照してください。
> エラーハンドリング、セキュリティ、パフォーマンス、テスト要件などの共通要件については [../../0_common/2_Common_Requirements.md](../../0_common/2_Common_Requirements.md) を参照してください。

## バックエンド固有の要件

### API設計原則

- RESTful APIの原則に従う
- リソース指向の設計
- 適切なHTTPメソッドの使用
- 一貫性のあるエンドポイント命名

### バックエンド固有のセキュリティ

- APIレート制限の実装
- APIキー管理の厳格化
- バックエンドサービス間の認証

### データベース設計

- 正規化と非正規化のバランス
- インデックス最適化
- トランザクション管理
- マイグレーション戦略

### ログとモニタリング

- 構造化ログの実装
- パフォーマンスメトリクスの収集
- アラート設定
- 監査ログの保存

### バックエンド固有のパフォーマンス最適化

- クエリ最適化
- キャッシュ戦略
- 非同期処理の活用
- バッチ処理の実装

### リソース使用量

- メモリリークを防止
- コネクションプールを適切に管理
- 大量データ処理時はストリーミング処理を検討

### エラー耐性

- 一時的な障害からの自動復旧
- リトライメカニズムの実装
- サーキットブレーカーパターンの検討

### API互換性

- 後方互換性を維持
- 破壊的変更を行う場合はバージョニングを活用
- 非推奨機能は段階的に廃止

### クロスプラットフォーム

- 異なるクライアントプラットフォームでの動作を保証
- ブラウザ互換性を考慮

### データ保持ポリシー

- 不要なデータは定期的に削除
- ユーザーデータの削除リクエストに対応

### 監視

- ヘルスチェックエンドポイントの実装
- 主要メトリクスの監視
- アラート設定

### 監査ログ

- 重要な操作は監査ログを記録
- ログは改ざん防止措置を講じる

## 2_api/1_Architecture_Overview.md

# アーキテクチャ概要

## 前提条件

本システムでは、**お金をかけずに、容易に経験の浅いエンジニアが短期間で実装**できることを第一優先とし、将来的な拡張にも対応しやすい設計を目指します。以下のガイドラインは、現在の要件と運用規模を前提としたアーキテクチャ方針です。

## 1. モノリシック or マイクロサービス

### 選定方針と理由

- **現状はモノリシック構成**:
  - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
  - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。

- **将来的な拡張**:
  - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
  - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。

### メリット/デメリット
- **メリット**:
  - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
  - **Vercel 無料枠**内で管理しやすい。
- **デメリット**:
  - 大規模化時、モノリシックがボトルネックになる可能性。
  - CI/CD や更新が大きくなるとビルド時間が延びる。

## 2. サーバレスアーキテクチャ

### 対象範囲

- **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
- Cron Jobs (Vercel) を利用して定期実行。
- **Supabase** はマネージド PostgreSQL でサーバレスに近い形。

### 導入メリット

- **コストがほぼゼロ** (無料枠内)
- 運用負荷が少なく、**エンジニアがインフラ構築不要**
- デプロイとスケールが自動化され、**初心者でも扱いやすい**

### デメリット / 将来検討

- Vercel の無料枠・API 実行回数に制限がある。
- ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
- AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。

## 3. レイヤードアーキテクチャ

本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。

1. **プレゼンテーション層 (UI)**
   - Next.js のページコンポーネント + Tailwind CSS
   - フロント側で認証・画面表示・ユーザー操作を受け付け

2. **APIレイヤー** (`/app/api/*`)
   - Next.js の API Routes (Serverless Functions) で REST API 的に実装
   - HTTPリクエストの受付
   - 認証・認可の確認
   - リクエストのバリデーション
   - 適切なサービスの呼び出し
   - レスポンスの整形

3. **サービスレイヤー** (`/lib/services/*`)
   - ビジネスロジックの実装
   - トランザクション管理
   - 複数リポジトリの連携
   - 外部APIとの連携

4. **リポジトリレイヤー** (`/lib/db/repositories/*`)
   - データアクセスロジックの抽象化
   - クエリの実行
   - データの変換（DB形式 ⇔ アプリケーション形式）

5. **ユーティリティレイヤー** (`/lib/utils/*`)
   - 共通機能の提供
   - ヘルパー関数
   - バリデーション
   - エラーハンドリング

## 4. ディレクトリ構造

プロジェクトのディレクトリ構造については、共通ディレクトリ構造ドキュメントを参照してください：
[共通ディレクトリ構造](../../0_common/3_Directory_Structure.md)

## 5. 認証・認可

### 認証方式

- **Supabase Auth** を利用
  - メール/パスワード認証
  - ソーシャルログイン（Google, GitHub など）
  - JWT トークンベースの認証

### 認可方式

- **Row Level Security (RLS)** を活用
  - Supabase の RLS ポリシーでデータアクセス制御
  - ユーザーロールに基づいたアクセス制御
  - API レベルでの追加的な認可チェック

## 6. エラーハンドリング

### エラー種別

- **クライアントエラー** (4xx)
  - バリデーションエラー
  - 認証・認可エラー
  - リソース不存在エラー
- **サーバーエラー** (5xx)
  - 内部エラー
  - 外部サービス連携エラー
  - データベースエラー

### エラーレスポンス形式

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "入力値が不正です",
    "details": [
      {
        "field": "email",
        "message": "有効なメールアドレスを入力してください"
      }
    ]
  }
}
```

## 7. パフォーマンス最適化

### キャッシュ戦略

- **Vercel Edge Cache** の活用
  - 静的コンテンツのキャッシュ
  - API レスポンスのキャッシュ（適切な場合）
- **クライアントサイドキャッシュ**
  - React Query / SWR によるデータキャッシュ
  - ローカルストレージ / IndexedDB の活用

### データベース最適化

- **インデックス設計**
  - 頻繁に検索されるフィールドにインデックスを作成
  - 複合インデックスの活用
- **クエリ最適化**
  - 必要なデータのみを取得
  - N+1問題の回避
  - ページネーションの実装

## 8. スケーラビリティ

### 現状の制約

- Vercel の無料枠では同時実行数に制限あり
- Supabase の無料枠ではデータベース容量に制限あり

### スケールアップ戦略

- **Vercel Pro** へのアップグレード
  - 同時実行数の増加
  - 実行時間の延長
- **Supabase Pro** へのアップグレード
  - データベース容量の増加
  - 同時接続数の増加

### スケールアウト戦略

- **マイクロサービス化**
  - AI処理部分の分離
  - バッチ処理の分離
- **キューイングシステムの導入**
  - 非同期処理の実装
  - ジョブの分散処理

## 2_api/2_Technology_Stack.md

# 技術スタック

## 前提条件

お金をかけず、容易に経験の浅いエンジニアが実装できることを第一優先とし、将来的な機能追加・スケーラビリティにも柔軟に対応できる構成を目指します。ここでは、フロントエンド + バックエンドを同一言語(TypeScript)で統一した場合を想定しつつ、最小限の手順でローカル開発を開始し、本番環境にも無料枠でデプロイ可能な技術スタックを提案します。

## 1. 言語選定

- **TypeScript 5.x**
  - **選定理由**:
    1. **静的型付け**によりコンパイル時のエラー検出が可能で、保守性を大きく向上する
    2. **JavaScriptとの高い互換性**があり、Reactなどのフロントエンドライブラリと自然に統合できる
    3. **広範なコミュニティ**と学習資源があり、初心者でも移行・導入がスムーズ
    4. **サーバレス/クラウド環境**（Vercel Functions など）と親和性が高く、Edge Functions の実装事例も充実
  - **バージョン**: TypeScript 5.1 以降
    - 新しいコンパイラ機能とパフォーマンス最適化が充実しており、型推論の質も向上

## 2. フレームワーク

- **フロントエンド**: [Next.js 14 (React)](https://nextjs.org/docs)
  - **採用理由**:
    1. **SSR, SSG, ISR** など柔軟なレンダリング方式を公式サポートし、ベストプラクティスに沿った開発がしやすい
    2. [Vercel](https://vercel.com/) との組み合わせが非常にスムーズで、無料枠でのデプロイおよびプレビュー機能が充実
    3. TypeScript との相性が良く、公式テンプレート (`create-next-app`) で初期セットアップが簡単
    4. 大規模コミュニティがあり、学習リソースやプラグインが豊富

- **バックエンド (簡易API)**: Next.js API Routes
  - **採用理由**:
    1. 小〜中規模のプロジェクトでは、フロントエンドと同一リポジトリ/フレームワークで完結できるため、導入のハードルが低い
    2. Vercel のサーバレスFunctionsとしてそのままデプロイ可能
    3. 単純なCRUD APIであれば十分なパフォーマンスを発揮する

> **将来的に複雑なビジネスロジック**や**高負荷処理**が必要になった場合、NestJS (TypeScript) を導入し、バックエンドを別サーバに切り出す拡張プランを想定。

## 3. コア技術

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Next.js | 14.x | フロントエンド＆バックエンドフレームワーク |
| TypeScript | 5.x | 型安全な開発言語 |
| Supabase | 最新 | データベース（PostgreSQL）、認証 |
| Vercel | 最新 | ホスティング、サーバレス関数 |

## 4. 主要ライブラリ / ミドルウェア

### 4.1 バックエンドライブラリ

| ライブラリ | 用途 |
|-----------|------|
| zod | スキーマバリデーション |
| @supabase/supabase-js | Supabase クライアント |
| jsonwebtoken | JWT認証 |
| date-fns | 日付操作 |
| axios | HTTP クライアント |
| cheerio | HTMLパース（コンテンツ抽出） |
| rss-parser | RSSフィード解析 |
| node-cron | クーロンジョブ（Vercel Cronと併用） |

### 4.2 ORマッパー

- **Prisma ORM**
  - **選定理由**:
    - Supabase (PostgreSQL) との連携が容易で、[Prisma Accelerate](https://www.prisma.io/blog/prisma-and-serverless-73hbgKnZ6t) によりエッジ環境でのCold Startを大幅に改善
    - スキーマ定義ファイルから**型安全なクエリクライアント**を自動生成し、TypeScriptと非常に相性が良い
    - コミュニティが活発でチュートリアルやサンプルが充実し、初心者でも導入しやすい

### 4.3 キャッシュサーバ

- **Redis (Upstash, Railway, or Render)**
  - **選定理由**:
    - 非常に高速なインメモリキャッシュを提供し、数万〜数十万リクエスト/秒にも耐えられる
    - 多くのクラウドで**無料枠**や**低料金プラン**が存在し、サーバレス運用も可能 (例: Upstash Redis)
    - キャッシュヒット率が高いページや要約結果などの再利用に最適

### 4.4 APIドキュメント生成ツール

- **Swagger / OpenAPI + Postman Collection**
  - **選定理由**:
    - Next.js API Routes の場合、公式の自動ドキュメント生成は存在しないため、**手動で OpenAPI スキーマ**を記述し、Swagger UI などを使うか、Postman Collection でエンドポイントを管理する
    - 将来的に NestJS へ移行した際は、標準の Swagger モジュールで自動ドキュメント生成が可能

### 4.5 AI/ML関連

| ライブラリ | 用途 |
|-----------|------|
| openai | OpenAI API クライアント |
| @anthropic-ai/sdk | Anthropic API クライアント |
| langchain | LLM操作フレームワーク（オプション） |

### 4.6 テスト

| ライブラリ | 用途 |
|-----------|------|
| Jest | ユニットテスト、統合テスト |
| supertest | APIテスト |
| @testing-library/react | Reactコンポーネントテスト |
| MSW (Mock Service Worker) | APIモック |

## 5. 開発 / デプロイ手順

### 5.1 ローカル環境のセットアップ

1. **リポジトリクローン & ディレクトリ移動**
   ```bash
   git clone https://github.com/your-account/your-project.git
   cd your-project
   ```

2. **依存インストール**
   ```bash
   npm install
   # or yarn install
   ```

3. **環境変数設定**
   - ルート直下に `.env.local` を作成し、以下のように記述（例）
     ```
     DATABASE_URL=postgresql://user:password@db.host.com:5432/db_name
     NEXT_PUBLIC_SUPABASE_URL=https://<project>.supabase.co
     NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
     DISCORD_WEBHOOK_URL=your-discord-webhook
     ```
   - `api_key_encrypted` 等の秘匿情報は、暗号化や別の手段（例: Vercel 秘密管理）で管理

4. **DBマイグレーション (Prisma)**
   ```bash
   npx prisma migrate dev --name init
   # DBスキーマを初期化
   ```

5. **アプリ起動 (開発モード)**
   ```bash
   npm run dev
   # localhost:3000 でフロントエンド + API が動作
   ```

6. **ブラウザ確認**
   - http://localhost:3000 でトップページへアクセス
   - http://localhost:3000/api/... でAPIテスト（例: GET /api/contents）

> **Docker環境**が必要な場合は、`docker-compose up -d` で PostgreSQL, Redis などミドルウェアを同時起動できる。VS Code Dev Containers を使えば環境差異を最小化し、誰でも同じ開発環境を再現可能。

### 5.2 本番デプロイ方法

1. **Vercelへの接続**
   - GitHub リポジトリを Vercel ダッシュボードで Import
   - Build Command: `npm run build` / Output Directory: `.next`
   - Environment Variables をダッシュボードに設定（`DATABASE_URL`, `DISCORD_WEBHOOK_URL` など）

2. **Supabase (PostgreSQL) との連携**
   - [Supabase](https://supabase.com/) プロジェクトを作成し、**Project Settings** 内の **Database** タブで接続URL を取得
   - Vercel上で `DATABASE_URL` として設定

3. **DB マイグレーション**
   - デプロイ後、Vercel の Build Logs にて `npx prisma migrate deploy` を実行して、DBスキーマを本番環境に反映
   - 必要に応じて Vercel の Deploy Hook などを用いて自動化

4. **Cron設定 (Vercel Cron Jobs)**
   - Vercel ダッシュボード → プロジェクト → Settings → Cron Jobs で **毎時**など実行間隔を指定
   - Path を `/api/cron/monitor` （例）に設定 → Cron が起動すると指定の API Route が呼ばれる
   - API 内で **YouTube RSS 取得 → 新着DB登録 → AI要約 → Discord通知** を実行

5. **ドメイン設定**
   - 独自ドメインを無料で接続可能 (Hobbyプラン)
   - DNS設定を行い、https でアクセス可能に

> **Railway や Fly.io** を使用する場合、 Dockerfile を用意し `railway up` or `fly deploy` コマンドなどでバックエンドのみをコンテナ化しデプロイできる。**フロントは Vercel、バックエンドは Railway**という構成も容易に実現可能。

## 6. コーディング規約

### 命名規則
- **ファイル名**: キャメルケース (例: `userService.ts`)
- **クラス/インターフェース**: パスカルケース (例: `UserService`)
- **関数/変数**: キャメルケース (例: `getUserById`)
- **定数**: 大文字スネークケース (例: `MAX_RETRY_COUNT`)

### コメント
- 複雑なロジックには必ずコメントを付ける
- JSDoc形式でAPI関数にはドキュメントコメントを記述

### 型定義
- 必ず型定義を行い、`any`型の使用は最小限に抑える
- 共通の型は`/types`ディレクトリに定義

## 7. まとめ

- **言語**: TypeScript (5.x), フロントエンドとバックエンドを統一
- **フレームワーク**: Next.js 14 + API Routes（簡易バックエンド）、将来 NestJS 拡張も可
- **主要ライブラリ**: Prisma（ORM）, Redisキャッシュ（Upstash or Railway）, Swagger/Postman でAPIドキュメント
- **開発手順**: `create-next-app` で雛形 → `.env.local` 設定 → `npx prisma migrate dev` → `npm run dev`
- **デプロイ**: Vercel の無料プランに GitHub 連携してCI/CD、Cron で定期実行ジョブ
- **将来的拡張**: Supabase有料プラン、複数AIモデル切替、複雑なバックエンド(NestJS化)など柔軟に追加可能

この構成なら、初心者エンジニアでも比較的容易に実装開始でき、**お金をかけずに**、**短期間(1週間程度)**で MVP リリースが可能となります。その後のスケール・機能拡張にも耐えやすいため、保守性と拡張性を兼ね備えた技術スタックと言えます。

## 2_api/3_API_Design.md

# API設計

## 概要

このドキュメントでは、DigeClipのAPIエンドポイント設計と仕様を定義します。APIはRESTful原則に従い、JSON形式でデータをやり取りします。

## API基本設計

### ベースURL

```
https://api.digeclip.com/api
```

開発環境では:

```
http://localhost:3000/api
```

### APIバージョニング

現時点ではバージョニングは行わず、将来的に必要になった場合はURLパスにバージョンを含める形式を採用します:

```
/api/v1/resources
```

### リソース命名規則

- 複数形の名詞を使用 (例: `/sources`, `/contents`)
- 小文字のケバブケース (例: `/ai-models`)
- ネストしたリソースはパスで表現 (例: `/contents/{id}/summaries`)

### HTTPメソッド

| メソッド | 用途 |
|---------|------|
| GET | リソースの取得 |
| POST | リソースの作成 |
| PUT | リソースの更新（全体） |
| PATCH | リソースの部分更新 |
| DELETE | リソースの削除 |

### レスポンス形式

#### 成功時

```json
{
  "data": {
    // リソースデータ
  },
  "meta": {
    // メタデータ（ページネーション情報など）
  }
}
```

#### エラー時

```json
{
  "error": {
    "code": "E400",
    "message": "ユーザーフレンドリーなエラーメッセージ",
    "details": {
      "field1": "フィールド固有のエラーメッセージ",
      "field2": "フィールド固有のエラーメッセージ"
    }
  }
}
```

### ステータスコード

| コード | 意味 |
|--------|------|
| 200 | 成功 |
| 201 | 作成成功 |
| 204 | 削除成功 |
| 400 | バリデーションエラー |
| 401 | 認証エラー |
| 403 | 権限エラー |
| 404 | リソース未発見 |
| 409 | リソース競合 |
| 429 | リクエスト数制限超過 |
| 500 | 内部サーバーエラー |
| 503 | サービス利用不可 |

### クエリパラメータ

#### ページネーション

```
/api/contents?page=1&limit=10
```

#### フィルタリング

```
/api/contents?status=published&source_id=123
```

#### ソート

```
/api/contents?sort=published_at:desc
```

#### 検索

```
/api/contents?search=keyword
```

## API一覧

APIドキュメントは以下のように構造化されています：

1. [共通仕様](./api/common/README.md) - ディレクトリ構成、認証・認可概要、共通仕様
2. [認証系API](./api/auth/README.md) - ユーザー登録、ログイン、ログアウト、パスワード管理
3. [ユーザーロールAPI](./api/user/README.md) - 一般ユーザーが利用する機能
4. [管理者ロールAPI](./api/admin/README.md) - 管理者のみが操作する機能

### 認証系API

#### ユーザー登録

- **エンドポイント**: `POST /api/auth/register`
- **リクエスト**:
  ```json
  {
    "email": "user@example.com",
    "password": "password123",
    "name": "User Name"
  }
  ```
- **レスポンス**:
  ```json
  {
    "data": {
      "id": "user_id",
      "email": "user@example.com",
      "name": "User Name",
      "role": "user",
      "created_at": "2023-01-01T00:00:00Z"
    }
  }
  ```

#### ログイン

- **エンドポイント**: `POST /api/auth/login`
- **リクエスト**:
  ```json
  {
    "email": "user@example.com",
    "password": "password123"
  }
  ```
- **レスポンス**:
  ```json
  {
    "data": {
      "token": "jwt_token",
      "user": {
        "id": "user_id",
        "email": "user@example.com",
        "name": "User Name",
        "role": "user"
      }
    }
  }
  ```

#### ログアウト

- **エンドポイント**: `POST /api/auth/logout`
- **認証**: 必要
- **レスポンス**:
  ```json
  {
    "data": {
      "message": "Successfully logged out"
    }
  }
  ```

### ユーザーロールAPI

#### コンテンツ一覧取得

- **エンドポイント**: `GET /api/user/contents`
- **認証**: 必要
- **クエリパラメータ**:
  - `page`: ページ番号（デフォルト: 1）
  - `limit`: 1ページあたりの件数（デフォルト: 10）
  - `status`: ステータスでフィルタリング
  - `source_id`: ソースIDでフィルタリング
  - `sort`: ソート条件（例: `published_at:desc`）
  - `search`: 検索キーワード
- **レスポンス**:
  ```json
  {
    "data": [
      {
        "id": "content_id",
        "title": "Content Title",
        "source": {
          "id": "source_id",
          "name": "Source Name",
          "icon_url": "https://example.com/icon.png"
        },
        "published_at": "2023-01-01T00:00:00Z",
        "status": "summarized",
        "tags": [
          {
            "id": "tag_id",
            "name": "Tag Name",
            "color": "#3B82F6"
          }
        ]
      }
    ],
    "meta": {
      "total": 100,
      "page": 1,
      "limit": 10,
      "pages": 10
    }
  }
  ```

#### コンテンツ詳細取得

- **エンドポイント**: `GET /api/user/contents/{id}`
- **認証**: 必要
- **レスポンス**:
  ```json
  {
    "data": {
      "id": "content_id",
      "title": "Content Title",
      "source": {
        "id": "source_id",
        "name": "Source Name",
        "icon_url": "https://example.com/icon.png"
      },
      "original_url": "https://example.com/article",
      "published_at": "2023-01-01T00:00:00Z",
      "content_text": "Original content text...",
      "status": "summarized",
      "summaries": [
        {
          "id": "summary_id",
          "type": "short",
          "text": "Short summary text...",
          "model": {
            "id": "model_id",
            "name": "GPT-4"
          }
        },
        {
          "id": "summary_id",
          "type": "medium",
          "text": "Medium summary text...",
          "model": {
            "id": "model_id",
            "name": "GPT-4"
          }
        }
      ],
      "tags": [
        {
          "id": "tag_id",
          "name": "Tag Name",
          "color": "#3B82F6"
        }
      ],
      "created_at": "2023-01-01T00:00:00Z",
      "updated_at": "2023-01-01T00:00:00Z"
    }
  }
  ```

### 管理者ロールAPI

#### ソース一覧取得

- **エンドポイント**: `GET /api/admin/sources`
- **認証**: 必要（管理者ロール）
- **クエリパラメータ**:
  - `page`: ページ番号（デフォルト: 1）
  - `limit`: 1ページあたりの件数（デフォルト: 10）
  - `type`: タイプでフィルタリング
  - `is_active`: アクティブフラグでフィルタリング
  - `sort`: ソート条件（例: `name:asc`）
  - `search`: 検索キーワード
- **レスポンス**:
  ```json
  {
    "data": [
      {
        "id": "source_id",
        "name": "Source Name",
        "url": "https://example.com/feed",
        "type": "RSS",
        "icon_url": "https://example.com/icon.png",
        "description": "Source description",
        "is_active": true,
        "created_at": "2023-01-01T00:00:00Z",
        "updated_at": "2023-01-01T00:00:00Z"
      }
    ],
    "meta": {
      "total": 50,
      "page": 1,
      "limit": 10,
      "pages": 5
    }
  }
  ```

#### ソース作成

- **エンドポイント**: `POST /api/admin/sources`
- **認証**: 必要（管理者ロール）
- **リクエスト**:
  ```json
  {
    "name": "New Source",
    "url": "https://example.com/feed",
    "type": "RSS",
    "icon_url": "https://example.com/icon.png",
    "description": "Source description",
    "is_active": true
  }
  ```
- **レスポンス**:
  ```json
  {
    "data": {
      "id": "source_id",
      "name": "New Source",
      "url": "https://example.com/feed",
      "type": "RSS",
      "icon_url": "https://example.com/icon.png",
      "description": "Source description",
      "is_active": true,
      "created_at": "2023-01-01T00:00:00Z",
      "updated_at": "2023-01-01T00:00:00Z"
    }
  }
  ```

#### ソース更新

- **エンドポイント**: `PUT /api/admin/sources/{id}`
- **認証**: 必要（管理者ロール）
- **リクエスト**:
  ```json
  {
    "name": "Updated Source",
    "url": "https://example.com/feed",
    "type": "RSS",
    "icon_url": "https://example.com/icon.png",
    "description": "Updated description",
    "is_active": true
  }
  ```
- **レスポンス**:
  ```json
  {
    "data": {
      "id": "source_id",
      "name": "Updated Source",
      "url": "https://example.com/feed",
      "type": "RSS",
      "icon_url": "https://example.com/icon.png",
      "description": "Updated description",
      "is_active": true,
      "created_at": "2023-01-01T00:00:00Z",
      "updated_at": "2023-01-01T00:00:00Z"
    }
  }
  ```

#### ソース削除

- **エンドポイント**: `DELETE /api/admin/sources/{id}`
- **認証**: 必要（管理者ロール）
- **レスポンス**: 204 No Content

## セキュリティ

### 認証

- JWTベースの認証を実装
- トークンは `Authorization` ヘッダーで送信: `Authorization: Bearer {token}`
- トークンの有効期限は24時間

### 認可

- ロールベースのアクセス制御（RBAC）を実装
- ロール: `admin`, `user`
- 各APIエンドポイントに必要なロールを定義

### CORS

- 適切なCORSポリシーを設定
- 本番環境では特定のオリジンのみを許可

### レート制限

- APIリクエスト数を制限
- 認証済みユーザー: 100リクエスト/分
- 未認証ユーザー: 20リクエスト/分

## API実装ガイドライン

1. すべてのAPIエンドポイントは共通のエラーハンドリングミドルウェアを使用
2. リクエストデータは必ずバリデーション
3. 認証が必要なエンドポイントは認証ミドルウェアを使用
4. レスポンスは統一されたフォーマットで返却
5. 適切なHTTPステータスコードを使用
6. 大量のデータを返す場合はページネーションを実装
7. 機密情報はレスポンスから除外

## API実装例

```typescript
// /api/user/contents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';

async function handler(req: NextRequest) {
  // クエリパラメータのバリデーション
  const searchParams = req.nextUrl.searchParams;
  const query = await validate(schemas.contentSearch, Object.fromEntries(searchParams));

  // サービス呼び出し
  const { items, total } = await contentService.searchContents(query);

  // レスポンス
  return NextResponse.json({
    data: items,
    meta: {
      total,
      page: query.page,
      limit: query.limit,
      pages: Math.ceil(total / query.limit)
    }
  });
}

// ミドルウェア適用（認証＋エラーハンドリング）
export const GET = withApiHandler(handler, { role: 'user' });
```

## 2_api/4_External_Integration.md

# 外部サービス連携

## 前提条件

本システムでは「経験の浅いエンジニアでも低コストで導入しやすく、将来的な機能拡張にも耐えられる」外部サービス連携を目指します。

- 必須連携：**SNS認証（Google OAuth）**、**決済サービス**（必要な場合）、**メール配信**、**その他拡張的なAPI**（地図/レコメンドなど）
- **Mastra.ai** 等のエージェント機能との連携も視野に入れ、複数段階要約（overview, heading, detail）に対応する。

以下では、SNS認証 → 決済サービス → メール配信 → その他外部APIの順に、具体的な要件・フロー・エラー対策を示します。
内容は**お金をかけずに、容易に経験の浅いエンジニアが実装できる**ことを重視し、**将来の機能追加**に耐えうる構成とします。

## 1. SNS認証

### 1.1 連携フロー

1. **Google OAuth 2.0**
   - フロントエンド（Next.js）側で「Googleでログイン」ボタンを設置
   - ボタン押下 → Googleログインページへリダイレクト
   - 同意後、アプリのコールバックURL (`/api/auth/google-callback`) に `code` & `state` が返却
   - サーバーで `code` を使って Googleのトークン取得API を呼び出し → `id_token` or `access_token`
   - トークンを検証し、ユーザーのメールアドレス等を取得
   - ローカルDB（Supabase）でユーザーを見つける/作成する
   - **JWT**を発行し、フロントに返す（Cookie or LocalStorageで保持）

2. **GitHub OAuth** (拡張例)
   - Googleと似たOAuthフロー (任意で今後追加可能)

3. **(任意)** Firebase Authentication
   - Google認証をFirebase上で完結させる方法もあるが、複雑度が上がるため今回は省略。

#### 実装の容易性
- Google Identity Servicesの公式JavaScript SDKを利用→トークン取得が簡単。
- **NextAuth.js**などのライブラリを使えば、さらにコード量を大幅削減可能。

### 1.2 アクセストークン管理

- **JWT**を最終的にサーバーが発行 → `Authorization: Bearer <token>` ヘッダ or Cookieで送受信
- 有効期限 (`exp`) を設定（例：1時間）
- リフレッシュトークンは簡単化のため今回は省略可（ユーザーが再ログインor Googleログインで継続使用）
- HTTP Cookieの場合：`Secure` / `HttpOnly` / `SameSite` を有効化

### 1.3 エラー対処

- **ユーザーが認証キャンセル**: UIで「キャンセルしました」のメッセージ
- **無効なトークン**: 401エラー（`{ error: { code: "E401", message: "Invalid token" } }`）
- **Google連携失敗**: 500エラー or 400エラー（ネットワーク不良の場合はリトライ処理）

## 2. 決済サービス

> 必要に応じて導入（追加コストが懸念される場合は後回し推奨）

### 2.1 APIエンドポイント

- 推奨：**Stripe** (従量課金・SDK充実)、**Square** (シンプル)、**Instamojo** (インド向け)
- 例：Stripeの場合 → `api.stripe.com/v1/...`

### 2.2 Webhook

- 決済完了/失敗イベントを受け取るWebhookエンドポイントを `/api/payment/webhook` などで用意
- **署名検証**（Stripeの `Stripe-Signature` ヘッダ等）
- イベント例：`payment_intent.succeeded` / `payment_intent.failed`

### 2.3 リトライ方針

- Stripeの **Smart Retries** に任せる
- アプリで二重課金を防ぐべき → **idempotency key** を使い、重複支払いを回避

## 3. メール配信

### 3.1 送信タイミング

1. **トランザクションメール**（パスワードリセット、注文確認など）
   - 即時送信（イベント駆動）
2. **バルクメール**（ニュースレターなど）
   - 定期 or 手動バッチ実行

### 3.2 テンプレート管理

- **SendGrid**, **Mailgun**, **MailerSend** など
- **Handlebars**や**各社独自テンプレ**で件名・本文を動的に生成
- 無料プラン制限：例）SendGrid 100通/日、Mailgun 100通/日 など

### 3.3 大量送信時の制限

- 超過すると送信失敗やレートリミット → キューイング機構が必要
- 有料プラン or 日単位のスケジューリング

## 4. その他外部API

### 4.1 地図API

- **Google Maps API**: 機能豊富だが無料枠制限がある
- **OpenStreetMap + Leaflet**: 無料、オープンソース
- **Mapbox**: 無料枠あり、デザイン性高い

### 4.2 レコメンドエンジン

- **Recombee**, **Algolia Recommend**: 30日無料トライアルなど
- **オープンソース**: Apache Mahout, Surprise など(導入難度高い)

### 4.3 エラー対応

- 各APIのレスポンスコードに従い**適切にハンドリング**。
- ネットワークエラー時は基本的に**リトライ** or ユーザーに再試行を促すメッセージ。

## 5. Mastra.aiとの連携 (将来的なAIエージェント連携)

### 5.1 複数段階要約への活用

- 例）決済履歴やメール配信統計などを**Mastra.ai** APIに送信
- `overview → heading → detail` のステップ要約を Mastra.ai のワークフローとして定義
- 返却された要約を DB に保存し、ユーザーに表示

### 5.2 エージェント機能

- **Mastra.ai**のツール呼び出しを利用して：
  - 決済API（Stripe等）のステータス照会
  - メールサービスの配信統計取得
  - SNS認証ログの異常検出
- **Google/AWS**等のLLMや**Anthropic**にもルーティング可能（Vercel AI SDKとの組合せ）

## 6. エラー・共通方針

1. **HTTPステータス**
   - 2xx: 成功
   - 4xx: クライアントエラー（認証失敗、パラメータ不正など）
   - 5xx: サーバーまたは外部APIエラー
2. **共通レスポンス形式**
   ```json
   {
     "error": {
       "code": "E4xx",
       "message": "Error details",
       "details": {}
     }
   }
   ```
   - code: 任意の文字列 (E4001 など)
   - message: ユーザー向けメッセージ
   - details: 追加情報（省略可）

3. **リトライ戦略**
   - ネットワーク不良時には数回まで再試行
   - レートリミット超過などは**バックオフ**して再試行

4. **セキュリティ**
   - OAuthトークン、APIキーは暗号化
   - Webhook署名検証
   - CSRFトークンの使用 (認証付きページ)

## 7. まとめと今後のステップ

- **SNS認証（Google OAuth）**は最初に導入 → 必要に応じてGitHubや他SNSを追加
- **決済サービス**はStripe等を想定し、Webhookでステータス同期 → MVP段階では不要なら保留
- **メール配信**はSendGrid/Mailgun等を使い、トランザクションメールを即時送信 → ニュースレターはキューやレート注意
- **その他API**（地図、レコメンド）はプロジェクト特性に合わせて選択 → 後で追加が容易になるようAPI設計を拡張性高く
- **Mastra.ai**とのエージェント連携は後期フェーズ → 要約(overview→heading→detail)や外部API統合に応用可能

以上の方針で、外部サービス連携を**低コストかつ短期間**で実装しつつ、**将来的な機能追加**（複数サービス/OAuth, 決済, メール拡張, Mastra.aiエージェントなど）にも柔軟に対応できる構成を目指します。

## 2_api/5_Implementation_Patterns.md

# 実装パターン

## 概要

このドキュメントでは、バックエンド実装における推奨パターンとコード例を提供します。これらのパターンは、コードの一貫性、保守性、および拡張性を確保するために設計されています。

## ディレクトリ構造

プロジェクトのディレクトリ構造については、共通ディレクトリ構造ドキュメントを参照してください：
[共通ディレクトリ構造](../../0_common/3_Directory_Structure.md)

## コーディング規約

コーディング規約については、共通コーディング規約ドキュメントを参照してください：
[コーディング規約](../../0_common/4_Coding_Conventions.md)

# API実装パターン集

## 概要

このドキュメントでは、DigeClipのバックエンドAPI実装における共通パターンと外部サービス連携方法を定義します。目的は「同じようなコードを何度も書かなくて済む」ようにすることです。「どんなエンジニアでも間違うことなく実装できる」ことを重視しつつ、「実装が複雑すぎず時間がかからない」方法を採用します。

## 1. 基本的なAPIエンドポイント実装パターン

### 1.1 一覧取得 (GET /api/[role]/[resource])

```typescript
// /api/user/contents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';

async function handler(req: NextRequest) {
  // クエリパラメータのバリデーション
  const searchParams = req.nextUrl.searchParams;
  const query = await validate(schemas.contentSearch, Object.fromEntries(searchParams));

  // サービス呼び出し
  const { items, total } = await contentService.searchContents(query);

  // レスポンス
  return NextResponse.json({
    data: items,
    meta: {
      total,
      page: query.page,
      limit: query.limit,
      pages: Math.ceil(total / query.limit)
    }
  });
}

// ミドルウェア適用（認証＋エラーハンドリング）
export const GET = withApiHandler(handler, { role: 'user' });
```

### 1.2 詳細取得 (GET /api/[role]/[resource]/[id])

```typescript
// /api/user/contents/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { contentService } from '@/lib/services/content/contentService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // サービス呼び出し
  const content = await contentService.getContentById(id);

  // 存在チェック
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // レスポンス
  return NextResponse.json({ data: content });
}

export const GET = withApiHandler(handler, { role: 'user' });
```

### 1.3 新規作成 (POST /api/[role]/[resource])

```typescript
// /api/admin/sources/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { sourceService } from '@/lib/services/source/sourceService';

async function handler(req: NextRequest) {
  // リクエストボディのバリデーション
  const body = await req.json();
  const data = await validate(schemas.sourceCreate, body);

  // サービス呼び出し
  const source = await sourceService.createSource(data);

  // レスポンス
  return NextResponse.json({ data: source }, { status: 201 });
}

export const POST = withApiHandler(handler, { role: 'admin' });
```

### 1.4 更新 (PUT /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { sourceService } from '@/lib/services/source/sourceService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // リクエストボディのバリデーション
  const body = await req.json();
  const data = await validate(schemas.sourceUpdate, body);

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  const updatedSource = await sourceService.updateSource(id, data);

  // レスポンス
  return NextResponse.json({ data: updatedSource });
}

export const PUT = withApiHandler(handler, { role: 'admin' });
```

### 1.5 削除 (DELETE /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { sourceService } from '@/lib/services/source/sourceService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  await sourceService.deleteSource(id);

  // レスポンス (204 No Content)
  return new NextResponse(null, { status: 204 });
}

export const DELETE = withApiHandler(handler, { role: 'admin' });
```

## 2. 複合リソース操作パターン

### 2.1 リレーション取得 (GET /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/summaries/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // クエリパラメータのバリデーション
  const searchParams = req.nextUrl.searchParams;
  const query = await validate(schemas.summarySearch, Object.fromEntries(searchParams));

  // サービス呼び出し
  const summaries = await contentService.getContentSummaries(id, query);

  // レスポンス
  return NextResponse.json({ data: summaries });
}

export const GET = withApiHandler(handler, { role: 'user' });
```

### 2.2 リレーション追加 (POST /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const body = await req.json();
  const data = await validate(schemas.tagAdd, body);

  // サービス呼び出し
  const updatedContent = await contentService.addTagToContent(id, data.tagId);

  // レスポンス
  return NextResponse.json({ data: updatedContent });
}

export const POST = withApiHandler(handler, { role: 'user' });
```

### 2.3 リレーション削除 (DELETE /api/[role]/[resource]/[id]/[relation]/[relationId])

```typescript
// /api/user/contents/[id]/tags/[tagId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { contentService } from '@/lib/services/content/contentService';
import { errors } from '@/lib/utils/error';

async function handler(
  req: NextRequest,
  { params }: { params: { id: string; tagId: string } }
) {
  const { id, tagId } = params;

  // IDのバリデーション
  if (!id || !tagId) {
    throw errors.validation({
      id: !id ? 'コンテンツIDが不正です' : undefined,
      tagId: !tagId ? 'タグIDが不正です' : undefined
    });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // サービス呼び出し
  await contentService.removeTagFromContent(id, tagId);

  // レスポンス
  return new NextResponse(null, { status: 204 });
}

export const DELETE = withApiHandler(handler, { role: 'user' });
```

## 3. 特殊操作パターン

### 3.1 一括操作 (POST /api/[role]/[resource]/batch)

```typescript
// /api/admin/contents/batch/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest) {
  // リクエストボディのバリデーション
  const body = await req.json();
  const data = await validate(schemas.contentBatchOperation, body);

  // 操作タイプに応じた処理
  let result;

  switch (data.operation) {
    case 'delete':
      result = await contentService.batchDelete(data.ids);
      break;
    case 'tag':
      result = await contentService.batchAddTag(data.ids, data.tagId);
      break;
    case 'untag':
      result = await contentService.batchRemoveTag(data.ids, data.tagId);
      break;
    default:
      throw errors.validation({ operation: '不明な操作タイプです' });
  }

  // レスポンス
  return NextResponse.json({ data: result });
}

export const POST = withApiHandler(handler, { role: 'admin' });
```

### 3.2 アクション実行 (POST /api/[role]/[resource]/[id]/[action])

```typescript
// /api/admin/contents/[id]/summarize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';
import { aiService } from '@/lib/services/ai/aiService';
import { errors } from '@/lib/utils/error';

async function handler(req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;

  // IDのバリデーション
  if (!id) {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const body = await req.json();
  const data = await validate(schemas.summarizeOptions, body);

  // サービス呼び出し
  const summary = await aiService.summarizeContent(id, data.modelId, data.type);

  // レスポンス
  return NextResponse.json({ data: summary });
}

export const POST = withApiHandler(handler, { role: 'admin' });
```

### 3.3 検索 (POST /api/[role]/[resource]/search)

```typescript
// /api/user/contents/search/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { contentService } from '@/lib/services/content/contentService';

async function handler(req: NextRequest) {
  // リクエストボディのバリデーション
  const body = await req.json();
  const searchParams = await validate(schemas.contentAdvancedSearch, body);

  // サービス呼び出し
  const { items, total } = await contentService.advancedSearch(searchParams);

  // レスポンス
  return NextResponse.json({
    data: items,
    meta: {
      total,
      page: searchParams.page,
      limit: searchParams.limit,
      pages: Math.ceil(total / searchParams.limit)
    }
  });
}

export const POST = withApiHandler(handler, { role: 'user' });
```

## 4. 認証関連パターン

### 4.1 ログイン (POST /api/auth/login)

```typescript
// /api/auth/login/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandling } from '@/lib/middleware/errorHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { authService } from '@/lib/services/auth/authService';

async function handler(req: NextRequest) {
  // リクエストボディのバリデーション
  const body = await req.json();
  const credentials = await validate(schemas.login, body);

  // 認証
  try {
    const { user, token } = await authService.login(credentials.email, credentials.password);

    // JWTをCookieにセット
    const response = NextResponse.json({
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      }
    });

    response.cookies.set({
      name: 'auth-token',
      value: token,
      path: '/',
      httpOnly: true,
      sameSite: 'strict',
      secure: process.env.NODE_ENV === 'production',
      maxAge: 86400 // 24時間
    });

    return response;
  } catch (error) {
    // 認証エラー
    return NextResponse.json(
      {
        error: {
          code: 'E401',
          message: 'メールアドレスまたはパスワードが正しくありません'
        }
      },
      { status: 401 }
    );
  }
}

export const POST = withErrorHandling(handler);
```

### 4.2 ログアウト (POST /api/auth/logout)

```typescript
// /api/auth/logout/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';

async function handler(req: NextRequest) {
  // Cookieを削除
  const response = NextResponse.json({
    data: { message: 'ログアウトしました' }
  });

  response.cookies.set({
    name: 'auth-token',
    value: '',
    path: '/',
    httpOnly: true,
    sameSite: 'strict',
    secure: process.env.NODE_ENV === 'production',
    maxAge: 0
  });

  return response;
}

export const POST = withApiHandler(handler);
```

### 4.3 ユーザー登録 (POST /api/auth/register)

```typescript
// /api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandling } from '@/lib/middleware/errorHandler';
import { validate, schemas } from '@/lib/utils/validation';
import { authService } from '@/lib/services/auth/authService';

async function handler(req: NextRequest) {
  // リクエストボディのバリデーション
  const body = await req.json();
  const userData = await validate(schemas.register, body);

  // メールアドレスの重複チェック
  const existingUser = await authService.getUserByEmail(userData.email);
  if (existingUser) {
    return NextResponse.json(
      {
        error: {
          code: 'E400',
          message: 'このメールアドレスは既に登録されています'
        }
      },
      { status: 400 }
    );
  }

  // ユーザー登録
  const user = await authService.register(userData);

  // レスポンス
  return NextResponse.json(
    {
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      }
    },
    { status: 201 }
  );
}

export const POST = withErrorHandling(handler);
```

## 5. 定期実行ジョブパターン

### 5.1 コンテンツ取得ジョブ (GET /api/cron/fetch-contents)

```typescript
// /api/cron/fetch-contents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { sourceService } from '@/lib/services/source/sourceService';
import { contentService } from '@/lib/services/content/contentService';

async function handler(req: NextRequest) {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json(
      { error: { code: 'E401', message: '不正なアクセスです' } },
      { status: 401 }
    );
  }

  // アクティブなソース一覧を取得
  const sources = await sourceService.getActiveSources();

  // 各ソースから新しいコンテンツを取得
  const results = await Promise.allSettled(
    sources.map(async (source) => {
      try {
        const newContents = await sourceService.fetchNewContents(source.id);

        // 新しいコンテンツごとに処理
        for (const content of newContents) {
          // コンテンツを保存
          await contentService.createContent({
            title: content.title,
            sourceId: source.id,
            originalUrl: content.url,
            publishedAt: content.publishedAt,
            // その他の必要なデータ
          });
        }

        return { sourceId: source.id, count: newContents.length };
      } catch (error) {
        console.error(`Error fetching contents from source ${source.id}:`, error);
        return { sourceId: source.id, error: error.message };
      }
    })
  );

  return NextResponse.json({
    message: 'コンテンツ取得ジョブが完了しました',
    results
  });
}

// 認証不要（Cronからの呼び出し）
export const GET = withApiHandler(handler);
```

### 5.2 要約ジョブ (GET /api/cron/summarize)

```typescript
// /api/cron/summarize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { contentService } from '@/lib/services/content/contentService';
import { aiService } from '@/lib/services/ai/aiService';

async function handler(req: NextRequest) {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json(
      { error: { code: 'E401', message: '不正なアクセスです' } },
      { status: 401 }
    );
  }

  // 要約が必要なコンテンツを取得
  const contents = await contentService.getContentsNeedingSummary();

  // 各コンテンツを要約
  const results = await Promise.allSettled(
    contents.map(async (content) => {
      try {
        // デフォルトAIモデルを取得
        const defaultModel = await aiService.getDefaultModel();

        // 要約を実行
        const summary = await aiService.summarizeContent(content.id, defaultModel.id);

        return { contentId: content.id, success: true };
      } catch (error) {
        console.error(`Error summarizing content ${content.id}:`, error);
        return { contentId: content.id, error: error.message };
      }
    })
  );

  return NextResponse.json({
    message: '要約ジョブが完了しました',
    results
  });
}

// 認証不要（Cronからの呼び出し）
export const GET = withApiHandler(handler);
```

## 6. ミドルウェア実装

### 6.1 APIハンドラーミドルウェア

```typescript
// /lib/middleware/apiHandler.ts
import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandling } from './errorHandler';
import { withAuth } from './auth';

type ApiHandlerOptions = {
  role?: 'admin' | 'user' | null;
};

export function withApiHandler(
  handler: (req: NextRequest, params: any) => Promise<NextResponse>,
  options: ApiHandlerOptions = {}
) {
  // 認証が必要な場合
  if (options.role) {
    return withErrorHandling(withAuth(handler, options.role));
  }

  // 認証不要の場合
  return withErrorHandling(handler);
}
```

### 6.2 認証ミドルウェア

```typescript
// /lib/middleware/auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { authService } from '@/lib/services/auth/authService';
import { errors } from '@/lib/utils/error';

export function withAuth(
  handler: (req: NextRequest, params: any) => Promise<NextResponse>,
  requiredRole: 'admin' | 'user'
) {
  return async (req: NextRequest, params: any) => {
    // トークンの取得
    const token = req.cookies.get('auth-token')?.value;

    if (!token) {
      throw errors.unauthorized('認証が必要です');
    }

    try {
      // トークンの検証
      const user = await authService.verifyToken(token);

      // ロールチェック
      if (requiredRole === 'admin' && user.role !== 'admin') {
        throw errors.forbidden('この操作を行う権限がありません');
      }

      // ユーザー情報をリクエストに追加
      req.user = user;

      // 元のハンドラーを実行
      return handler(req, params);
    } catch (error) {
      throw errors.unauthorized('認証セッションが無効です');
    }
  };
}
```

### 6.3 エラーハンドリングミドルウェア

```typescript
// /lib/middleware/errorHandler.ts
import { NextRequest, NextResponse } from 'next/server';

export function withErrorHandling(
  handler: (req: NextRequest, params: any) => Promise<NextResponse>
) {
  return async (req: NextRequest, params: any) => {
    try {
      return await handler(req, params);
    } catch (error) {
      console.error('API Error:', error);

      // カスタムエラーの場合
      if (error.code && error.message) {
        return NextResponse.json(
          {
            error: {
              code: error.code,
              message: error.message,
              details: error.details
            }
          },
          { status: error.statusCode || 500 }
        );
      }

      // 未処理のエラーの場合
      return NextResponse.json(
        {
          error: {
            code: 'E500',
            message: '内部サーバーエラーが発生しました'
          }
        },
        { status: 500 }
      );
    }
  };
}
```

## 7. 外部サービス連携パターン

### 7.1 SNS認証

#### 7.1.1 Google OAuth 2.0連携フロー

```typescript
// /api/auth/google/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { authService } from '@/lib/services/auth/authService';

async function handler(req: NextRequest) {
  // Google認証URLを生成
  const authUrl = await authService.generateGoogleAuthUrl();

  // リダイレクト
  return NextResponse.redirect(authUrl);
}

export const GET = withApiHandler(handler);
```

```typescript
// /api/auth/google-callback/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { authService } from '@/lib/services/auth/authService';

async function handler(req: NextRequest) {
  // コードとステートを取得
  const searchParams = req.nextUrl.searchParams;
  const code = searchParams.get('code');
  const state = searchParams.get('state');

  if (!code) {
    return NextResponse.json(
      { error: { code: 'E400', message: '認証コードがありません' } },
      { status: 400 }
    );
  }

  try {
    // Googleトークンを取得し、ユーザー情報を検証
    const { user, token } = await authService.handleGoogleCallback(code, state);

    // JWTを発行してCookieに設定
    const response = NextResponse.redirect(new URL('/', req.url));
    response.cookies.set('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 // 24時間
    });

    return response;
  } catch (error) {
    console.error('Google認証エラー:', error);
    return NextResponse.redirect(new URL('/auth/error?code=google_auth_failed', req.url));
  }
}

export const GET = withApiHandler(handler);
```

#### 7.1.2 アクセストークン管理

```typescript
// /lib/middleware/auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { jwtVerify } from '@/lib/utils/jwt';

export async function authMiddleware(req: NextRequest) {
  // Cookieからトークンを取得
  const token = req.cookies.get('token')?.value;

  if (!token) {
    return NextResponse.json(
      { error: { code: 'E401', message: '認証が必要です' } },
      { status: 401 }
    );
  }

  try {
    // トークンを検証
    const payload = await jwtVerify(token);

    // リクエストにユーザー情報を追加
    req.user = payload.user;

    return NextResponse.next();
  } catch (error) {
    return NextResponse.json(
      { error: { code: 'E401', message: 'トークンが無効です' } },
      { status: 401 }
    );
  }
}
```

### 7.2 決済サービス連携

#### 7.2.1 Stripe決済フロー

```typescript
// /api/payment/create-session/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { withAuth } from '@/lib/middleware/auth';
import { paymentService } from '@/lib/services/payment/paymentService';

async function handler(req: NextRequest) {
  const { user } = req;
  const { planId } = await req.json();

  try {
    // Stripeセッションを作成
    const session = await paymentService.createStripeSession({
      userId: user.id,
      planId,
      successUrl: `${process.env.NEXT_PUBLIC_APP_URL}/payment/success`,
      cancelUrl: `${process.env.NEXT_PUBLIC_APP_URL}/payment/cancel`
    });

    return NextResponse.json({ data: { sessionId: session.id, url: session.url } });
  } catch (error) {
    console.error('決済セッション作成エラー:', error);
    return NextResponse.json(
      { error: { code: 'E500', message: '決済セッションの作成に失敗しました' } },
      { status: 500 }
    );
  }
}

export const POST = withApiHandler(withAuth(handler));
```

#### 7.2.2 Webhook処理

```typescript
// /api/payment/webhook/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { paymentService } from '@/lib/services/payment/paymentService';

// Webhookはraw bodyが必要なため、bodyParserをオフに
export const config = {
  api: {
    bodyParser: false
  }
};

async function handler(req: NextRequest) {
  if (req.method !== 'POST') {
    return NextResponse.json({ error: { message: 'Method not allowed' } }, { status: 405 });
  }

  // リクエストボディをバッファとして取得
  const buf = await req.arrayBuffer();
  const rawBody = Buffer.from(buf);

  // Stripe署名を検証
  const signature = req.headers.get('stripe-signature');

  if (!signature) {
    return NextResponse.json(
      { error: { code: 'E400', message: 'Stripe署名がありません' } },
      { status: 400 }
    );
  }

  try {
    // イベントを検証して処理
    const event = await paymentService.verifyStripeWebhook(rawBody, signature);

    // イベントタイプに応じた処理
    switch (event.type) {
      case 'payment_intent.succeeded':
        await paymentService.handlePaymentSuccess(event.data.object);
        break;
      case 'payment_intent.payment_failed':
        await paymentService.handlePaymentFailure(event.data.object);
        break;
      // その他のイベント
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Webhook処理エラー:', error);
    return NextResponse.json(
      { error: { code: 'E400', message: 'Webhook処理に失敗しました' } },
      { status: 400 }
    );
  }
}

export const POST = withApiHandler(handler);
```

### 7.3 メール配信

#### 7.3.1 トランザクションメール送信

```typescript
// /lib/services/notification/emailService.ts
import { createTransport } from 'nodemailer';
import { renderTemplate } from '@/lib/utils/template';

export const emailService = {
  async sendTransactionalEmail({ to, subject, templateName, data }) {
    // メールトランスポートを作成
    const transporter = createTransport({
      host: process.env.SMTP_HOST,
      port: Number(process.env.SMTP_PORT),
      secure: process.env.SMTP_SECURE === 'true',
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASSWORD
      }
    });

    // テンプレートをレンダリング
    const html = await renderTemplate(templateName, data);

    // メール送信
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to,
      subject,
      html
    });
  },

  // パスワードリセットメール
  async sendPasswordReset(user, resetToken) {
    const resetUrl = `${process.env.NEXT_PUBLIC_APP_URL}/auth/reset-password?token=${resetToken}`;

    await this.sendTransactionalEmail({
      to: user.email,
      subject: 'パスワードリセット',
      templateName: 'password-reset',
      data: {
        name: user.name,
        resetUrl
      }
    });
  },

  // ウェルカムメール
  async sendWelcome(user) {
    await this.sendTransactionalEmail({
      to: user.email,
      subject: 'DigeClipへようこそ',
      templateName: 'welcome',
      data: {
        name: user.name
      }
    });
  }
};
```

#### 7.3.2 バルクメール送信

```typescript
// /api/cron/send-newsletter/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withApiHandler } from '@/lib/middleware/apiHandler';
import { emailService } from '@/lib/services/notification/emailService';
import { userService } from '@/lib/services/user/userService';
import { contentService } from '@/lib/services/content/contentService';

async function handler(req: NextRequest) {
  // CRON_SECRETによる認証
  const authHeader = req.headers.get('authorization');
  const token = authHeader?.split(' ')[1];

  if (token !== process.env.CRON_SECRET) {
    return NextResponse.json(
      { error: { code: 'E401', message: '認証が必要です' } },
      { status: 401 }
    );
  }

  try {
    // 購読ユーザーを取得
    const subscribers = await userService.getNewsletterSubscribers();

    // 最新コンテンツを取得
    const latestContents = await contentService.getLatestContents(10);

    // バッチ処理でメール送信
    const batchSize = 50; // 一度に送信する最大数

    for (let i = 0; i < subscribers.length; i += batchSize) {
      const batch = subscribers.slice(i, i + batchSize);

      // 並列処理でメール送信
      await Promise.all(
        batch.map(user =>
          emailService.sendTransactionalEmail({
            to: user.email,
            subject: '今週のダイジェスト',
            templateName: 'weekly-digest',
            data: {
              name: user.name,
              contents: latestContents
            }
          })
        )
      );

      // レート制限を避けるための遅延
      if (i + batchSize < subscribers.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    return NextResponse.json({
      data: {
        success: true,
        sent: subscribers.length
      }
    });
  } catch (error) {
    console.error('ニュースレター送信エラー:', error);
    return NextResponse.json(
      { error: { code: 'E500', message: 'ニュースレターの送信に失敗しました' } },
      { status: 500 }
    );
  }
}

export const GET = withApiHandler(handler);
```

### 7.4 AI/LLM連携

#### 7.4.1 OpenAI APIを使用した要約生成

```typescript
// /lib/services/ai/openaiService.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

export const openaiService = {
  async generateSummary(content, type = 'short') {
    // 要約タイプに応じたプロンプトを設定
    const promptMap = {
      short: '次の記事を100文字以内で簡潔に要約してください:',
      medium: '次の記事を300文字程度で要約してください:',
      long: '次の記事を500文字程度で詳細に要約してください:'
    };

    const prompt = promptMap[type] || promptMap.short;

    try {
      const response = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: 'あなたは記事を要約する専門家です。与えられた記事を指定された長さで要約してください。' },
          { role: 'user', content: `${prompt}\n\n${content}` }
        ],
        temperature: 0.3,
        max_tokens: type === 'short' ? 100 : type === 'medium' ? 300 : 500
      });

      return response.choices[0].message.content.trim();
    } catch (error) {
      console.error('OpenAI API エラー:', error);
      throw new Error('要約の生成に失敗しました');
    }
  }
};
```

#### 7.4.2 Anthropic APIを使用した要約生成

```typescript
// /lib/services/ai/anthropicService.ts
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

export const anthropicService = {
  async generateSummary(content, type = 'short') {
    // 要約タイプに応じたプロンプトを設定
    const promptMap = {
      short: '次の記事を100文字以内で簡潔に要約してください:',
      medium: '次の記事を300文字程度で要約してください:',
      long: '次の記事を500文字程度で詳細に要約してください:'
    };

    const prompt = promptMap[type] || promptMap.short;

    try {
      const response = await anthropic.messages.create({
        model: 'claude-3-opus-20240229',
        max_tokens: type === 'short' ? 100 : type === 'medium' ? 300 : 500,
        temperature: 0.3,
        system: 'あなたは記事を要約する専門家です。与えられた記事を指定された長さで要約してください。',
        messages: [
          { role: 'user', content: `${prompt}\n\n${content}` }
        ]
      });

      return response.content[0].text.trim();
    } catch (error) {
      console.error('Anthropic API エラー:', error);
      throw new Error('要約の生成に失敗しました');
    }
  }
};
```

#### 7.4.3 AIモデル選択サービス

```typescript
// /lib/services/ai/aiService.ts
import { openaiService } from './openaiService';
import { anthropicService } from './anthropicService';
import { aiModelRepository } from '@/lib/db/repositories/aiModelRepository';

export const aiService = {
  async generateSummary(content, type = 'short', modelId = null) {
    try {
      // モデルIDが指定されていない場合はデフォルトモデルを使用
      let model;

      if (modelId) {
        model = await aiModelRepository.findById(modelId);
      } else {
        model = await aiModelRepository.findDefault();
      }

      if (!model) {
        throw new Error('AIモデルが見つかりません');
      }

      // プロバイダーに応じたサービスを選択
      switch (model.provider) {
        case 'openai':
          return await openaiService.generateSummary(content, type);
        case 'anthropic':
          return await anthropicService.generateSummary(content, type);
        default:
          throw new Error('サポートされていないAIプロバイダーです');
      }
    } catch (error) {
      console.error('AI要約エラー:', error);
      throw new Error('要約の生成に失敗しました');
    }
  }
};
```

### 7.5 外部サービス連携のエラー処理パターン

```typescript
// /lib/utils/apiError.ts
export class ApiError extends Error {
  constructor(public code, public message, public status = 500, public details = {}) {
    super(message);
    this.name = 'ApiError';
  }
}

// 外部APIエラーをラップする関数
export async function withExternalApiCall<T>(
  apiCall: () => Promise<T>,
  errorMap: Record<string, { code: string; message: string; status: number }> = {}
): Promise<T> {
  try {
    return await apiCall();
  } catch (error) {
    console.error('外部API呼び出しエラー:', error);

    // エラーコードに基づいてマッピング
    const errorCode = error.code || 'unknown_error';
    const mappedError = errorMap[errorCode] || {
      code: 'E500',
      message: '外部サービスとの通信中にエラーが発生しました',
      status: 500
    };

    throw new ApiError(
      mappedError.code,
      mappedError.message,
      mappedError.status,
      { originalError: error.message }
    );
  }
}
```

```typescript
// 使用例
import { withExternalApiCall } from '@/lib/utils/apiError';

// OpenAI APIの呼び出し
const summary = await withExternalApiCall(
  () => openaiService.generateSummary(content, type),
  {
    'insufficient_quota': {
      code: 'E503',
      message: 'AIサービスの利用制限に達しました。後でお試しください。',
      status: 503
    },
    'rate_limit_exceeded': {
      code: 'E429',
      message: 'リクエスト数の制限に達しました。しばらく待ってからお試しください。',
      status: 429
    }
  }
);
```

### 7.6 Mastra.aiとの連携

#### 7.6.1 複数段階要約への活用

```typescript
// /lib/services/ai/mastraService.ts
import axios from 'axios';

export const mastraService = {
  async generateMultiStepSummary(content) {
    try {
      // Mastra.ai APIへのリクエスト
      const response = await axios.post(
        `${process.env.MASTRA_API_URL}/workflows/execute`,
        {
          workflowId: process.env.MASTRA_WORKFLOW_ID,
          input: {
            content
          }
        },
        {
          headers: {
            'Authorization': `Bearer ${process.env.MASTRA_API_KEY}`,
            'Content-Type': 'application/json'
          }
        }
      );

      // レスポンスから要約を取得
      const { overview, headings, details } = response.data.result;

      return {
        overview,
        headings,
        details
      };
    } catch (error) {
      console.error('Mastra.ai API エラー:', error);
      throw new Error('複数段階要約の生成に失敗しました');
    }
  },

  async getWorkflowStatus(executionId) {
    try {
      const response = await axios.get(
        `${process.env.MASTRA_API_URL}/workflows/executions/${executionId}`,
        {
          headers: {
            'Authorization': `Bearer ${process.env.MASTRA_API_KEY}`
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Mastra.ai ワークフローステータス取得エラー:', error);
      throw new Error('ワークフローステータスの取得に失敗しました');
    }
  }
};
```

#### 7.6.2 エージェント機能の活用

```typescript
// /lib/services/ai/mastraAgentService.ts
import axios from 'axios';

export const mastraAgentService = {
  async executeAgentAction(action, parameters) {
    try {
      // Mastra.ai Agentへのリクエスト
      const response = await axios.post(
        `${process.env.MASTRA_API_URL}/agents/execute`,
        {
          agentId: process.env.MASTRA_AGENT_ID,
          action,
          parameters
        },
        {
          headers: {
            'Authorization': `Bearer ${process.env.MASTRA_API_KEY}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data.result;
    } catch (error) {
      console.error('Mastra.ai Agent エラー:', error);
      throw new Error('エージェントアクションの実行に失敗しました');
    }
  },

  // 決済ステータス照会
  async checkPaymentStatus(paymentId) {
    return this.executeAgentAction('checkPaymentStatus', { paymentId });
  },

  // メール配信統計取得
  async getEmailStats(campaignId) {
    return this.executeAgentAction('getEmailStats', { campaignId });
  },

  // 異常検出
  async detectAnomalies(data) {
    return this.executeAgentAction('detectAnomalies', { data });
  }
};
```

## 8. まとめ

このドキュメントでは、DigeClipバックエンドの実装における共通パターンと外部サービス連携方法を定義しました。これらのパターンを活用することで、一貫性のある実装が可能になり、開発効率と保守性が向上します。

実装時には以下の点に注意してください：

1. **エラーハンドリング**: すべてのAPIエンドポイントで適切なエラーハンドリングを行い、ユーザーフレンドリーなエラーメッセージを返す
2. **バリデーション**: リクエストデータは必ず検証し、不正なデータを早期に検出する
3. **トランザクション**: 複数のデータベース操作を伴う処理ではトランザクションを使用する
4. **セキュリティ**: 認証・認可を適切に実装し、機密情報を保護する
5. **外部サービス連携**: レート制限やエラー処理を考慮し、リトライ戦略を実装する

これらのパターンは、DigeClipの要件に合わせて適宜カスタマイズして使用してください。

## 2_api/README.md

# API 一覧・設計 (Roles 別 + 認証周り含む)

> **前提**
> - **Next.js**(TypeScript) をベースに **ビジネスロジックを分離**。
> - **ロール**は「**admin**(管理者)」「**user**(一般ユーザー)」に加え、「**guest**(未ログイン)」状態も考慮。
> - **認証**は以下をサポート:
>   1. **Googleアカウント認証** (OAuth 2.0)
>   2. **JWT** (自前ログイン用; email+pwなど)
> - ログインまわり (サインアップ/サインイン/パスワードリセット/Googleログイン) をすべて網羅。
> - **Vercelの**`/api`**ルート**でロールごとに `/api/admin/...` と `/api/user/...`、さらに認証系は `/api/auth/...` として整理。
> - **すべての機能**に対して、必要がありそうな**APIを漏れなく**定義。
> - **リクエストとレスポンス**は TypeScript 型を示し、**例**のJSONをつける。
> - **エラー**についても共通フォーマットを示す。

## ドキュメント構成

このAPIドキュメントは以下のように構成されています：

1. [共通仕様](./common/README.md) - ディレクトリ構成、認証・認可概要、共通仕様
2. [認証系API](./auth/README.md) - ユーザー登録、ログイン、ログアウト、パスワード管理
3. [ユーザーロールAPI](./user/README.md) - 一般ユーザーが利用する機能
4. [管理者ロールAPI](./admin/README.md) - 管理者のみが操作する機能

## API概要

### 認証系 ( `/api/auth/...` )

認証関連のエンドポイントを提供します。ユーザー登録、ログイン、ログアウト、パスワード管理などの機能を含みます。

| 主要エンドポイント | 説明 |
|-----------------|------|
| `/api/auth/register` | ユーザー登録 |
| `/api/auth/login` | メール&パスワードログイン |
| `/api/auth/google-callback` | Google OAuth ログイン |
| `/api/auth/logout` | ログアウト |

### ユーザーロール ( `/api/user/...` )

一般ユーザーが利用する機能のエンドポイントを提供します。コンテンツの閲覧、タグ管理、システム状態確認などの機能を含みます。

| 主要エンドポイント | 説明 |
|-----------------|------|
| `/api/user/contents` | コンテンツ一覧取得 |
| `/api/user/contents/[id]` | コンテンツ詳細取得 |
| `/api/user/tags` | タグ一覧取得 |

### 管理者ロール ( `/api/admin/...` )

管理者が利用する機能のエンドポイントを提供します。ソース管理、コンテンツ管理、AIモデル管理、通知履歴管理、タグ管理、システム設定管理などの機能を含みます。

| 主要カテゴリ | 説明 |
|------------|------|
| `/api/admin/sources/...` | ソース管理 |
| `/api/admin/contents/...` | コンテンツ管理 |
| `/api/admin/ai-models/...` | AIモデル管理 |
| `/api/admin/notifications/...` | 通知履歴管理 |
| `/api/admin/tags/...` | タグ管理 |
| `/api/admin/system/...` | システム設定管理 |

## admin/README.md

# 管理者ロール API ( `/api/admin/...` )

管理者が利用する機能のエンドポイントを提供します。ソース管理、コンテンツ管理、AIモデル管理、通知履歴管理、タグ管理、システム設定管理などの機能を含みます。

## API一覧

### ソース管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/sources](./sources/list.md) | GET | ソース一覧取得 | 要(admin) |
| [/api/admin/sources](./sources/create.md) | POST | ソース追加 | 要(admin) |
| [/api/admin/sources/[id]](./sources/detail.md) | GET | ソース詳細取得 | 要(admin) |
| [/api/admin/sources/[id]](./sources/update.md) | PUT | ソース更新 | 要(admin) |
| [/api/admin/sources/[id]](./sources/delete.md) | DELETE | ソース削除 | 要(admin) |

### コンテンツ管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/contents](./contents/list.md) | GET | コンテンツ一覧取得 | 要(admin) |
| [/api/admin/contents/[id]](./contents/detail.md) | GET | コンテンツ詳細取得 | 要(admin) |
| [/api/admin/contents/[id]](./contents/delete.md) | DELETE | コンテンツ削除 | 要(admin) |
| [/api/admin/contents/[id]/reprocess](./contents/reprocess.md) | POST | コンテンツ再処理 | 要(admin) |

### AIモデル管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/ai-models](./ai-models/list.md) | GET | AIモデル一覧取得 | 要(admin) |
| [/api/admin/ai-models](./ai-models/create.md) | POST | AIモデル追加 | 要(admin) |
| [/api/admin/ai-models/[id]](./ai-models/detail.md) | GET | AIモデル詳細取得 | 要(admin) |
| [/api/admin/ai-models/[id]](./ai-models/update.md) | PUT | AIモデル更新 | 要(admin) |
| [/api/admin/ai-models/[id]](./ai-models/delete.md) | DELETE | AIモデル削除 | 要(admin) |

### 通知履歴管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/notifications](./notifications/list.md) | GET | 通知履歴一覧取得 | 要(admin) |
| [/api/admin/notifications/test](./notifications/test.md) | POST | 通知テスト送信 | 要(admin) |

### タグ管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/tags](./tags/list.md) | GET | タグ一覧取得 | 要(admin) |
| [/api/admin/tags](./tags/create.md) | POST | タグ作成 | 要(admin) |
| [/api/admin/tags/[id]](./tags/update.md) | PUT | タグ更新 | 要(admin) |
| [/api/admin/tags/[id]](./tags/delete.md) | DELETE | タグ削除 | 要(admin) |

### システム設定管理

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/admin/system/status](./system/status.md) | GET | システム状態取得 | 要(admin) |
| [/api/admin/system/run-monitor](./system/run-monitor.md) | POST | 監視処理手動実行 | 要(admin) |
| [/api/admin/system/settings](./system/get-settings.md) | GET | アプリケーション設定取得 | 要(admin) |
| [/api/admin/system/settings](./system/update-settings.md) | PUT | アプリケーション設定更新 | 要(admin) |

## ai_models/create.md

# AIモデル作成 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/ai_models`
- **機能概要**: 新しいAIモデルをシステムに追加
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminCreateAIModelRequest`
```ts
export interface IAdminCreateAIModelRequest {
  name: string;
  provider: string;
  model_id: string;
  capabilities: string[];
  default_for?: string[];
  active: boolean;
  config: {
    api_key_variable?: string;
    endpoint?: string;
    max_tokens?: number;
    temperature?: number;
    additional_params?: Record<string, any>;
  };
}
```

**例 (リクエストJSON)**
```jsonc
{
  "name": "Gemini Pro",
  "provider": "Google",
  "model_id": "gemini-pro",
  "capabilities": ["summarization", "tagging"],
  "default_for": [],
  "active": true,
  "config": {
    "api_key_variable": "GOOGLE_API_KEY",
    "endpoint": "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent",
    "max_tokens": 2048,
    "temperature": 0.4,
    "additional_params": {
      "top_k": 40
    }
  }
}
```

## レスポンス

**Response**: `IAdminCreateAIModelResponse`
```ts
export interface IAdminCreateAIModelResponse {
  id: number;
  name: string;
  provider: string;
  model_id: string;
  capabilities: string[];
  default_for?: string[];
  active: boolean;
  config: {
    api_key_variable?: string;
    endpoint?: string;
    max_tokens?: number;
    temperature?: number;
    additional_params?: Record<string, any>;
  };
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 3,
  "name": "Gemini Pro",
  "provider": "Google",
  "model_id": "gemini-pro",
  "capabilities": ["summarization", "tagging"],
  "default_for": [],
  "active": true,
  "config": {
    "api_key_variable": "GOOGLE_API_KEY",
    "endpoint": "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent",
    "max_tokens": 2048,
    "temperature": 0.4,
    "additional_params": {
      "top_k": 40
    }
  },
  "created_at": "2025-03-15T10:30:00Z",
  "updated_at": "2025-03-15T10:30:00Z"
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4002",
    "message": "Invalid model configuration",
    "details": {
      "capabilities": "Must include at least one valid capability"
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **入力検証**:
   - すべての必須フィールド（name, provider, model_id, capabilities, active, config）が存在することを確認してください。
   - 各フィールドの型と形式を検証してください:
     - `name`: 空でない文字列
     - `provider`: 空でない文字列
     - `model_id`: 空でない文字列
     - `capabilities`: 少なくとも1つの有効な値を含む配列（"summarization", "tagging", "content_extraction"など）
     - `default_for`: capabilities に含まれる値のみを含む配列
     - `active`: ブール値
     - `config`: 必要なフィールドを含むオブジェクト
   - `temperature` は 0.0〜1.0 の範囲内であることを確認してください。
   - `max_tokens` は正の整数であることを確認してください。

3. **重複チェック**:
   - 同じ `name` または同じ `provider` + `model_id` の組み合わせを持つモデルが既に存在しないか確認してください。
   - 重複がある場合は `409 Conflict` エラーを返してください。

4. **デフォルトモデル設定**:
   - `default_for` に指定された機能について、既存のデフォルトモデルがある場合の処理方針を決定してください:
     - 既存のデフォルト設定を上書きする
     - エラーを返す
     - 両方のモデルをデフォルトとして設定する
   - 選択した方針をドキュメントに明記し、一貫して実装してください。

5. **環境変数の検証**:
   - `api_key_variable` に指定された環境変数が実際に設定されているか確認することを推奨します。
   - 設定されていない場合は警告をログに記録するか、`active` を `false` に設定することを検討してください。

6. **トランザクション処理**:
   - データベースへの挿入操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に `default_for` の設定変更が他のモデルに影響する場合は、整合性を保つためにトランザクションが重要です。

7. **日付フィールド**:
   - `created_at` と `updated_at` フィールドには現在のUTC時刻を設定してください。
   - 日時は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で保存・返却してください。

8. **配列とJSONの処理**:
   - `capabilities`, `default_for`, `additional_params` などの配列やオブジェクトフィールドは、データベースの型に応じて適切にシリアライズしてください。
   - PostgreSQLを使用する場合は、JSONB型の使用を検討してください。

9. **監査ログ**:
   - 誰がいつどのAIモデルを作成したかを記録する監査ログを実装してください。
   - ログには少なくとも、操作者ID、操作日時、作成されたモデルIDを含めてください。

10. **APIキーのセキュリティ**:
    - 実際のAPIキー値はリクエストやレスポンスに含めないでください。
    - 環境変数名やシークレット参照のみを保存・返却してください。

11. **モデル接続テスト**:
    - 可能であれば、新しいモデルを作成する際に簡単な接続テストを実行し、設定が有効であることを確認することを検討してください。
    - テスト結果を応答に含めるか、別のエンドポイント（`/api/admin/ai_models/[id]/test`）でテストを実行できるようにしてください。

## ai_models/delete.md

# AIモデル削除 API

- **HTTPメソッド**: `DELETE`
- **エンドポイント**: `/api/admin/ai_models/[id]`
- **機能概要**: 既存のAIモデルをシステムから削除
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: 削除するAIモデルのID (必須)

## レスポンス

**Response**: `IAdminDeleteAIModelResponse`
```ts
export interface IAdminDeleteAIModelResponse {
  message: string;
  id: number;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "AI model successfully deleted",
  "id": 3
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4041",
    "message": "AI model not found"
  }
}
```

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4003",
    "message": "Cannot delete model that is set as default for capabilities"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **モデル存在確認**:
   - 指定された `id` のAIモデルが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **使用中チェック**:
   - 削除対象のモデルが現在システムで使用されていないことを確認してください:
     - デフォルトモデルとして設定されていないか（`default_for` が空か）
     - 現在処理中のコンテンツで使用されていないか
     - 定期的なジョブで使用されるよう設定されていないか
   - 使用中の場合は `400 Bad Request` エラーを返し、詳細な理由を提供してください。

5. **強制削除オプション**:
   - 将来的な拡張として、使用中のモデルも強制的に削除できるクエリパラメータ（例：`?force=true`）の実装を検討してください。
   - 強制削除を実装する場合は、代替モデルの設定など、必要な対応策も実装してください。

6. **トランザクション処理**:
   - 削除操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に関連するデフォルト設定の更新など、複数のテーブルを更新する場合はトランザクションが重要です。

7. **関連データの処理**:
   - モデルの使用履歴や統計情報など、関連するデータの処理方針を決定してください:
     - 完全に削除する
     - 匿名化して保持する
     - そのまま保持する（外部キー制約を調整）
   - 選択した方針を一貫して実装してください。

8. **ソフトデリート検討**:
   - 完全に削除するのではなく、`deleted_at` フラグを設定するソフトデリートの実装を検討してください。
   - これにより、誤削除からの復旧や履歴の保持が容易になります。

9. **デフォルトモデルの再設定**:
   - モデルが一部の機能のデフォルトとして設定されていた場合、代替のデフォルトモデルを自動的に設定するか、明示的なエラーを返すかを決定してください。
   - 自動設定する場合は、選択ロジックを明確にし、ログに記録してください。

10. **監査ログ**:
    - 誰がいつどのAIモデルを削除したかを記録する監査ログを実装してください。
    - ログには少なくとも、操作者ID、操作日時、削除されたモデルID、モデル名を含めてください。

11. **キャッシュ管理**:
    - モデル情報のキャッシュがある場合、削除後にキャッシュを無効化してください。
    - 特にモデルリストや設定情報のキャッシュが影響を受ける可能性があります。

12. **エラー処理**:
    - 削除中に発生する可能性のある様々なエラーケースを考慮し、適切なエラーメッセージを返してください。
    - データベースエラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。

## ai_models/detail.md

# AIモデル詳細取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/ai_models/[id]`
- **機能概要**: 特定のAIモデルの詳細情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: AIモデルのID (必須)

## レスポンス

**Response**: `IAdminGetAIModelDetailResponse`
```ts
export interface IAdminGetAIModelDetailResponse {
  id: number;
  name: string;
  provider: string;
  model_id: string;
  capabilities: string[];
  default_for?: string[];
  active: boolean;
  config: {
    api_key_variable?: string;
    endpoint?: string;
    max_tokens?: number;
    temperature?: number;
    additional_params?: Record<string, any>;
  };
  usage_stats?: {
    total_requests: number;
    total_tokens: number;
    average_response_time: number;
    last_used: string;
  };
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 2,
  "name": "Claude 3 Opus",
  "provider": "Anthropic",
  "model_id": "claude-3-opus-20240229",
  "capabilities": ["summarization", "tagging", "content_extraction"],
  "default_for": ["tagging", "content_extraction"],
  "active": true,
  "config": {
    "api_key_variable": "ANTHROPIC_API_KEY",
    "endpoint": "https://api.anthropic.com/v1/messages",
    "max_tokens": 4000,
    "temperature": 0.7,
    "additional_params": {
      "top_p": 0.9,
      "top_k": 50
    }
  },
  "usage_stats": {
    "total_requests": 1250,
    "total_tokens": 3750000,
    "average_response_time": 2.3,
    "last_used": "2025-03-14T18:22:10Z"
  },
  "created_at": "2025-03-01T09:15:30Z",
  "updated_at": "2025-03-10T14:25:12Z"
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4041",
    "message": "AI model not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **データベースアクセス**:
   - AIモデル情報は `ai_models` テーブルから取得します。
   - 使用統計情報（usage_stats）は別テーブル（例：`ai_model_usage_stats`）から取得する場合があります。
   - 必要に応じてテーブル結合を行い、効率的なクエリを実装してください。

4. **機密情報の取り扱い**:
   - `config` 内の情報、特に `api_key_variable` は機密情報を直接含まないようにしてください。
   - 実際のAPIキー値ではなく、環境変数名やシークレットの参照名のみを返すようにしてください。
   - 必要に応じて、機密情報をマスクまたは省略してください。

5. **エラーハンドリング**:
   - モデルが存在しない場合は `404 Not Found` を返してください。
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。

6. **日付フォーマット**:
   - すべての日時フィールド（created_at, updated_at, last_used）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

7. **使用統計の計算**:
   - `usage_stats` は実際の使用データから動的に計算する必要があります。
   - 大量のログデータがある場合、集計クエリのパフォーマンスに注意してください。
   - 頻繁にアクセスされる場合は、定期的に集計値を更新するバックグラウンドジョブの実装を検討してください。

8. **配列フィールドの処理**:
   - `capabilities` と `default_for` は配列として返す必要があります。
   - データベースの実装によっては、これらのフィールドを文字列からJSONに変換する処理が必要になる場合があります。

9. **additional_params の処理**:
   - `additional_params` は任意の構造を持つオブジェクトとして保存・取得する必要があります。
   - データベースでは JSONB 型などを使用し、適切にシリアライズ/デシリアライズしてください。

10. **キャッシュ戦略**:
    - 詳細情報は頻繁に変更されない可能性があるため、適切なキャッシュ戦略を検討してください。
    - ただし、usage_stats は定期的に更新される可能性があるため、部分的なキャッシュ更新または短いTTLの設定を検討してください。

## ai_models/list.md

# AIモデル一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/ai_models`
- **機能概要**: システムで利用可能なAIモデルの一覧を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request**: なし

## レスポンス

**Response**: `IAdminGetAIModelsResponse`
```ts
export interface IAdminGetAIModelsResponse {
  models: IAdminAIModel[];
}

export interface IAdminAIModel {
  id: number;
  name: string;
  provider: string;
  model_id: string;
  capabilities: string[];
  default_for?: string[];
  active: boolean;
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "models": [
    {
      "id": 1,
      "name": "GPT-4",
      "provider": "OpenAI",
      "model_id": "gpt-4",
      "capabilities": ["summarization", "tagging"],
      "default_for": ["summarization"],
      "active": true,
      "created_at": "2025-01-15T12:00:00Z",
      "updated_at": "2025-02-20T15:30:45Z"
    },
    {
      "id": 2,
      "name": "Claude 3 Opus",
      "provider": "Anthropic",
      "model_id": "claude-3-opus-20240229",
      "capabilities": ["summarization", "tagging", "content_extraction"],
      "default_for": ["tagging", "content_extraction"],
      "active": true,
      "created_at": "2025-03-01T09:15:30Z",
      "updated_at": "2025-03-01T09:15:30Z"
    }
  ]
}
```

## エラー

**Error**: e.g. `500 Internal Server Error`
```jsonc
{
  "error": {
    "code": "E5001",
    "message": "Failed to retrieve AI models"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **データベースアクセス**:
   - AIモデル情報はデータベースの `ai_models` テーブルから取得します。
   - パフォーマンスを考慮し、必要に応じてインデックスを作成してください。
   - 特に `capabilities` や `default_for` フィールドが配列型の場合、適切なデータ型（JSONBなど）を使用してください。

3. **フィルタリングとソート**:
   - 将来的な拡張として、クエリパラメータによるフィルタリング（例：`?provider=OpenAI`）やソート（例：`?sort_by=name&sort_order=asc`）の実装を検討してください。
   - これらのパラメータを実装する場合は、適切な入力検証を行ってください。

4. **キャッシュ戦略**:
   - AIモデルリストは頻繁に変更されないため、適切なキャッシュ戦略を実装することでパフォーマンスを向上させることができます。
   - キャッシュの有効期限（TTL）を設定し、モデルが更新された際にキャッシュを無効化する仕組みを検討してください。

5. **エラーハンドリング**:
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

6. **日付フォーマット**:
   - すべての日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

7. **配列フィールドの処理**:
   - `capabilities` と `default_for` は配列として返す必要があります。
   - データベースの実装によっては、これらのフィールドを文字列からJSONに変換する処理が必要になる場合があります。

8. **パフォーマンス考慮事項**:
   - モデル数が多い場合は、ページネーションの実装を検討してください。
   - レスポンスサイズが大きくなる場合は、圧縮を検討してください。

9. **セキュリティ考慮事項**:
   - レスポンスにはAPIキーや機密設定情報を含めないでください。
   - 詳細な設定情報は個別のエンドポイント（`/api/admin/ai_models/[id]`）で取得するようにしてください。

## ai_models/test.md

# AIモデルテスト API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/ai_models/[id]/test`
- **機能概要**: 特定のAIモデルの動作をテスト
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: テストするAIモデルのID (必須)

**Request**: `IAdminTestAIModelRequest`
```ts
export interface IAdminTestAIModelRequest {
  capability: string;
  test_input: string;
  parameters?: Record<string, any>;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "capability": "summarization",
  "test_input": "これはテスト用のテキストです。AIモデルの要約機能をテストします。",
  "parameters": {
    "temperature": 0.3,
    "max_tokens": 100
  }
}
```

## レスポンス

**Response**: `IAdminTestAIModelResponse`
```ts
export interface IAdminTestAIModelResponse {
  success: boolean;
  model_id: number;
  model_name: string;
  capability: string;
  output: string;
  metrics: {
    tokens_used: number;
    processing_time: number;
    cost_estimate?: number;
  };
  error?: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "success": true,
  "model_id": 2,
  "model_name": "Claude 3 Opus",
  "capability": "summarization",
  "output": "テスト用テキストのAIモデル要約機能テスト",
  "metrics": {
    "tokens_used": 42,
    "processing_time": 1.2,
    "cost_estimate": 0.0008
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4004",
    "message": "Model does not support the requested capability",
    "details": {
      "capability": "summarization",
      "supported_capabilities": ["tagging", "content_extraction"]
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **モデル存在確認**:
   - 指定された `id` のAIモデルが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **機能サポート確認**:
   - リクエストの `capability` が指定されたモデルの `capabilities` 配列に含まれているか確認してください。
   - サポートされていない機能の場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

5. **入力検証**:
   - `test_input` が空でないことを確認してください。
   - `parameters` が指定された場合、モデルがサポートするパラメータであることを確認してください。
   - 特に `temperature` や `max_tokens` などの値が適切な範囲内であることを検証してください。

6. **AIモデル接続**:
   - モデルの設定情報（`api_key_variable`, `endpoint` など）を使用して、実際のAIサービスに接続してください。
   - 環境変数から適切なAPIキーを取得し、セキュアに扱ってください。
   - リクエストタイムアウトを設定し、長時間応答がない場合は適切にエラーハンドリングしてください。

7. **メトリクス計測**:
   - 処理時間を正確に計測するために、リクエスト開始時と完了時にタイムスタンプを記録してください。
   - トークン使用量はAIサービスのレスポンスから取得するか、入出力テキストから推定してください。
   - コスト見積もりは、トークン使用量とモデルの料金設定に基づいて計算してください。

8. **エラーハンドリング**:
   - AIサービスへの接続エラーや応答エラーを適切に処理してください。
   - エラーの詳細情報をログに記録し、ユーザーには理解しやすいメッセージを返してください。
   - 特に認証エラー（APIキー無効など）と使用量制限エラー（レートリミットなど）を区別して処理してください。

9. **レスポンスフォーマット**:
   - AIモデルからの生の応答を適切に処理し、一貫したフォーマットで返してください。
   - 特に異なるAIサービス（OpenAI, Anthropic, Google など）間での応答形式の違いを吸収してください。

10. **テスト結果の記録**:
    - テスト結果を一時的にデータベースに記録し、後で参照できるようにすることを検討してください。
    - これにより、モデルのパフォーマンス比較や問題診断が容易になります。

11. **リソース管理**:
    - 大量のテストリクエストによるコスト増加を防ぐため、レート制限の実装を検討してください。
    - 特に、短時間に同じモデルに対する複数のテストリクエストを制限することが重要です。

12. **セキュリティ考慮事項**:
    - `test_input` に機密情報や有害なコンテンツが含まれないよう、基本的な検証を実装してください。
    - AIモデルの応答にも同様の検証を適用し、安全でない内容が返されないようにしてください。

## ai_models/update.md

# AIモデル更新 API

- **HTTPメソッド**: `PUT`
- **エンドポイント**: `/api/admin/ai_models/[id]`
- **機能概要**: 既存のAIモデルの設定を更新
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: 更新するAIモデルのID (必須)

**Request**: `IAdminUpdateAIModelRequest`
```ts
export interface IAdminUpdateAIModelRequest {
  name?: string;
  provider?: string;
  model_id?: string;
  capabilities?: string[];
  default_for?: string[];
  active?: boolean;
  config?: {
    api_key_variable?: string;
    endpoint?: string;
    max_tokens?: number;
    temperature?: number;
    additional_params?: Record<string, any>;
  };
}
```

**例 (リクエストJSON)**
```jsonc
{
  "name": "Claude 3 Opus (Updated)",
  "active": true,
  "config": {
    "temperature": 0.5,
    "max_tokens": 5000,
    "additional_params": {
      "top_p": 0.95
    }
  },
  "default_for": ["summarization", "tagging"]
}
```

## レスポンス

**Response**: `IAdminUpdateAIModelResponse`
```ts
export interface IAdminUpdateAIModelResponse {
  id: number;
  name: string;
  provider: string;
  model_id: string;
  capabilities: string[];
  default_for?: string[];
  active: boolean;
  config: {
    api_key_variable?: string;
    endpoint?: string;
    max_tokens?: number;
    temperature?: number;
    additional_params?: Record<string, any>;
  };
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 2,
  "name": "Claude 3 Opus (Updated)",
  "provider": "Anthropic",
  "model_id": "claude-3-opus-20240229",
  "capabilities": ["summarization", "tagging", "content_extraction"],
  "default_for": ["summarization", "tagging"],
  "active": true,
  "config": {
    "api_key_variable": "ANTHROPIC_API_KEY",
    "endpoint": "https://api.anthropic.com/v1/messages",
    "max_tokens": 5000,
    "temperature": 0.5,
    "additional_params": {
      "top_p": 0.95,
      "top_k": 50
    }
  },
  "created_at": "2025-03-01T09:15:30Z",
  "updated_at": "2025-03-15T11:42:18Z"
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4041",
    "message": "AI model not found"
  }
}
```

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4002",
    "message": "Invalid model configuration",
    "details": {
      "temperature": "Must be between 0 and 1"
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **モデル存在確認**:
   - 指定された `id` のAIモデルが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **部分更新の処理**:
   - このAPIは部分更新（PATCH的な動作）を行います。リクエストに含まれるフィールドのみを更新してください。
   - リクエストに含まれていないフィールドは現在の値を維持してください。
   - `config` オブジェクトも部分更新として扱い、指定されたプロパティのみを更新してください。
   - `additional_params` は完全に置き換えるか、マージするかの方針を決定し、一貫して実装してください。

5. **入力検証**:
   - 提供されたフィールドの型と形式を検証してください:
     - `name`: 空でない文字列
     - `provider`: 空でない文字列
     - `model_id`: 空でない文字列
     - `capabilities`: 少なくとも1つの有効な値を含む配列
     - `default_for`: capabilities に含まれる値のみを含む配列
     - `active`: ブール値
   - `temperature` は 0.0〜1.0 の範囲内であることを確認してください。
   - `max_tokens` は正の整数であることを確認してください。

6. **重複チェック**:
   - `name`, `provider`, または `model_id` を変更する場合、新しい値が他のモデルと重複しないことを確認してください。
   - 重複がある場合は `409 Conflict` エラーを返してください。

7. **デフォルトモデル設定**:
   - `default_for` を更新する場合、既存のデフォルトモデル設定との整合性を確保してください。
   - 他のモデルがデフォルトとして設定されている機能を新たにデフォルトとして設定する場合の処理方針を決定してください:
     - 既存のデフォルト設定を上書きする
     - エラーを返す
     - 両方のモデルをデフォルトとして設定する
   - 選択した方針をドキュメントに明記し、一貫して実装してください。

8. **環境変数の検証**:
   - `api_key_variable` を更新する場合、指定された環境変数が実際に設定されているか確認することを推奨します。
   - 設定されていない場合は警告をログに記録するか、`active` を `false` に設定することを検討してください。

9. **トランザクション処理**:
   - データベース更新操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に `default_for` の設定変更が他のモデルに影響する場合は、整合性を保つためにトランザクションが重要です。

10. **楽観的ロック**:
    - 同時更新の競合を防ぐため、楽観的ロック（バージョン番号や更新タイムスタンプによる）の実装を検討してください。
    - 競合が検出された場合は `409 Conflict` エラーを返してください。

11. **日付フィールド**:
    - `updated_at` フィールドには現在のUTC時刻を設定してください。
    - 日時は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で保存・返却してください。

12. **監査ログ**:
    - 誰がいつどのAIモデルをどのように更新したかを記録する監査ログを実装してください。
    - ログには少なくとも、操作者ID、操作日時、対象モデルID、変更されたフィールドを含めてください。

13. **キャッシュ管理**:
    - モデル情報のキャッシュがある場合、更新後にキャッシュを無効化または更新してください。

14. **アクティブ状態の変更処理**:
    - `active` を `false` に変更する場合、そのモデルが現在使用中でないことを確認することを検討してください。
    - 特に `default_for` に設定されている場合は、代替のデフォルトモデルを設定するか、警告を表示してください。

## contents/delete.md

# コンテンツ削除 API

- **HTTPメソッド**: `DELETE`
- **エンドポイント**: `/api/admin/contents/[id]`
- **機能概要**: 特定のコンテンツを削除
- **認証要否**: **要**(admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

## レスポンス

**Response**: `IAdminDeleteContentResponse`
```ts
export interface IAdminDeleteContentResponse {
  message: string;
  id: number;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Content deleted successfully",
  "id": 42
}
```

## エラー

**Error**: e.g. `404 Not Found` (コンテンツが見つからない)
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Content not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **トランザクション処理**:
   - 削除操作は必ずトランザクション内で実行してください。
   - 関連するデータ（summaries, notifications, tags関連など）も適切に削除または更新する必要があります。
   - 参照整合性を維持するため、外部キー制約を考慮してください。

4. **ソフトデリート**:
   - 実際のデータを物理的に削除するのではなく、`deleted_at` フラグを設定するソフトデリートを実装することを推奨します。
   - これにより、誤削除からの復旧やデータ分析の整合性を維持できます。

5. **エラーハンドリング**:
   - コンテンツが存在しない場合は `404 Not Found` を返してください。
   - 削除中にエラーが発生した場合は、トランザクションをロールバックし、`500 Internal Server Error` を返してください。
   - 詳細なエラーログを記録してください。

6. **監査ログ**:
   - 誰がいつどのコンテンツを削除したかを記録する監査ログを実装してください。
   - ログには少なくとも、操作者ID、操作日時、対象コンテンツID、操作種別を含めてください。

7. **同時実行制御**:
   - 同じコンテンツに対する同時削除リクエストを適切に処理するため、楽観的ロックまたは悲観的ロックを検討してください。

8. **キャッシュ管理**:
   - 削除後、関連するキャッシュを適切に無効化してください。
   - 特に、コンテンツリスト、タグ関連のキャッシュなどが影響を受ける可能性があります。

9. **関連リソースの処理**:
   - コンテンツに関連する添付ファイルやメディアがある場合、それらのストレージリソースも適切に処理（削除または保持）してください。

## contents/detail.md

# コンテンツ詳細取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/contents/[id]`
- **機能概要**: 特定のコンテンツの詳細情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

## レスポンス

**Response**: `IAdminGetContentDetailResponse`
```ts
export interface ISummaryDetail {
  id: number;
  ai_model_id: number;
  ai_model_name: string;
  stage: string;
  summary_text: string;
  tokens_used?: number;
  processing_time?: number;
  created_at: string;
}

export interface INotificationDetail {
  id: number;
  destination: string;
  status: "success" | "failed";
  error_message?: string;
  sent_at: string;
}

export interface IAdminGetContentDetailResponse {
  id: number;
  source_id: number;
  source_name: string;
  title: string;
  url: string;
  type: "video" | "article" | "paper" | "other";
  published_at?: string;
  raw_text: string; // 管理者は全文を取得可能
  metadata?: Record<string, any>;
  status: "pending" | "summarized" | "error";
  error_message?: string;
  tags: string[];
  summaries: ISummaryDetail[];
  notifications: INotificationDetail[];
  created_at: string;
  updated_at: string;
  processing_history?: {
    detection_time: string;
    text_extraction_time?: string;
    summarization_time?: string;
    notification_time?: string;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 42,
  "source_id": 1,
  "source_name": "テックチャンネル",
  "title": "AIの最新動向 2025年版",
  "url": "https://www.youtube.com/watch?v=abc123",
  "type": "video",
  "published_at": "2025-03-10T14:30:00Z",
  "raw_text": "本日は2025年のAI業界の最新動向についてお話しします。まず初めに、生成AIの進化について...(全文)...",
  "metadata": {
    "thumbnail": "https://i.ytimg.com/vi/abc123/maxresdefault.jpg",
    "duration": 1234,
    "views": 5000,
    "channel_id": "UC12345"
  },
  "status": "summarized",
  "tags": ["AI", "テクノロジー"],
  "summaries": [
    {
      "id": 101,
      "ai_model_id": 1,
      "ai_model_name": "GPT-4",
      "stage": "overview",
      "summary_text": "この動画は2025年におけるAI業界の主要な発展について解説している。特に生成AIの進化、自律システムの普及、倫理的枠組みの標準化について重点的に触れている。",
      "tokens_used": 120,
      "processing_time": 2.3,
      "created_at": "2025-03-10T14:50:00Z"
    },
    {
      "id": 102,
      "ai_model_id": 1,
      "ai_model_name": "GPT-4",
      "stage": "detail",
      "summary_text": "1. 生成AIの進化: マルチモーダルモデルが標準となり...(省略)...\n2. 自律システムの普及: 家庭用ロボットの普及率が先進国で20%を突破...(省略)...\n3. 倫理的枠組み: ISO/IEC 42001がグローバルスタンダードとして...(省略)...",
      "tokens_used": 450,
      "processing_time": 5.1,
      "created_at": "2025-03-10T14:51:00Z"
    }
  ],
  "notifications": [
    {
      "id": 201,
      "destination": "Discord Webhook #tech-news",
      "status": "success",
      "sent_at": "2025-03-10T15:00:00Z"
    }
  ],
  "created_at": "2025-03-10T14:45:00Z",
  "updated_at": "2025-03-10T15:00:00Z",
  "processing_history": {
    "detection_time": "2025-03-10T14:45:00Z",
    "text_extraction_time": "2025-03-10T14:48:00Z",
    "summarization_time": "2025-03-10T14:51:00Z",
    "notification_time": "2025-03-10T15:00:00Z"
  }
}
```

## エラー

**Error**: e.g. `404 Not Found` (コンテンツが見つからない)
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Content not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **データベースアクセス**:
   - コンテンツ情報の取得には複数のテーブル結合が必要です（contents, sources, summaries, notifications, tags）。
   - パフォーマンスを考慮し、必要に応じてクエリを最適化してください。
   - 大量のテキストデータ（raw_text）を含むため、レスポンスサイズに注意してください。

4. **エラーハンドリング**:
   - コンテンツが存在しない場合は `404 Not Found` を返してください。
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。

5. **日付フォーマット**:
   - すべての日時フィールドは ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

6. **セキュリティ考慮事項**:
   - raw_text フィールドには機密情報が含まれる可能性があるため、適切なアクセス制御を実装してください。
   - レスポンスにXSS攻撃の可能性があるコンテンツが含まれる場合は、適切にエスケープ処理を行ってください。

7. **パフォーマンス**:
   - 大量のデータを返す可能性があるため、必要に応じてレスポンスの圧縮を検討してください。
   - summaries や notifications が多数ある場合は、ページネーションの実装を検討してください。

## contents/list.md

# コンテンツ一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/contents`
- **機能概要**: 全てのコンテンツを取得（ステータスや情報源でフィルタリング可能）
- **認証要否**: **要**(admin)

## リクエスト

**Request Query**:
```ts
export interface IAdminGetContentsQuery {
  status?: "pending" | "summarized" | "error";
  sourceId?: number;
  type?: "video" | "article" | "paper";
  page?: number;
  pageSize?: number;
}
```

**例**
```
GET /api/admin/contents?status=error&page=1&pageSize=10
```

## レスポンス

**Response**: `IAdminGetContentsResponse`
```ts
export interface IAdminContentItem {
  id: number;
  source_id: number;
  title: string;
  url: string;
  type: "video" | "article" | "paper" | "other";
  published_at?: string;
  raw_text?: string; // 管理者は一部を取得可能
  metadata?: Record<string, any>;
  status: "pending" | "summarized" | "error";
  error_message?: string;
  tags: string[];
  created_at: string;
  updated_at: string;
  notified_at?: string;
}

export interface IAdminGetContentsResponse {
  data: IAdminContentItem[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "data": [
    {
      "id": 42,
      "source_id": 1,
      "title": "AIの最新動向 2025年版",
      "url": "https://www.youtube.com/watch?v=abc123",
      "type": "video",
      "published_at": "2025-03-10T14:30:00Z",
      "raw_text": "本日は2025年のAI業界の最新動向について...(省略)...",
      "metadata": {
        "thumbnail": "https://i.ytimg.com/vi/abc123/maxresdefault.jpg",
        "duration": 1234,
        "views": 5000
      },
      "status": "error",
      "error_message": "Failed to generate summary: API timeout",
      "tags": ["AI", "テクノロジー"],
      "created_at": "2025-03-10T14:45:00Z",
      "updated_at": "2025-03-10T15:00:00Z"
    },
    {
      "id": 45,
      "source_id": 2,
      "title": "プログラミング言語比較 2025",
      "url": "https://www.youtube.com/watch?v=xyz789",
      "type": "video",
      "published_at": "2025-03-09T10:00:00Z",
      "raw_text": "今回は2025年における主要プログラミング言語の...(省略)...",
      "metadata": {
        "thumbnail": "https://i.ytimg.com/vi/xyz789/maxresdefault.jpg",
        "duration": 2345,
        "views": 3000
      },
      "status": "error",
      "error_message": "Failed to extract text: No captions available",
      "tags": ["プログラミング"],
      "created_at": "2025-03-09T10:15:00Z",
      "updated_at": "2025-03-09T10:30:00Z"
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 10,
    "total": 15
  }
}
```

## エラー

**Error**: e.g. `403 Forbidden` (権限エラー)
```jsonc
{
  "error": {
    "code": "E4030",
    "message": "Admin permission required"
  }
}
```

## contents/reprocess.md

# コンテンツ再処理 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/contents/[id]/reprocess`
- **機能概要**: エラーのあったコンテンツを再処理
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminReprocessContentRequest`
```ts
export interface IAdminReprocessContentRequest {
  steps?: ("text_extraction" | "summarization" | "notification")[];
  ai_model_id?: number; // 特定のAIモデルで再処理する場合
}
```

**例 (リクエストJSON)**
```jsonc
{
  "steps": ["summarization", "notification"],
  "ai_model_id": 2
}
```

## レスポンス

**Response**: `IAdminReprocessContentResponse`
```ts
export interface IAdminReprocessContentResponse {
  message: string;
  id: number;
  job_id?: string;
  steps: string[];
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Content reprocessing job queued",
  "id": 42,
  "job_id": "reprocess_20250315_123456",
  "steps": ["summarization", "notification"]
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効なステップ)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid processing steps"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パラメータ検証**:
   - `id` パスパラメータは数値であることを確認してください。
   - `steps` 配列の各要素が有効な値（"text_extraction", "summarization", "notification"）であることを検証してください。
   - `ai_model_id` が指定された場合、存在するモデルIDであることを確認してください。
   - パラメータが無効な場合は適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **非同期処理**:
   - 再処理はバックグラウンドジョブとして実行し、即時レスポンスを返してください。
   - ジョブキュー（例：Bull, Celery, AWS SQS など）を使用して処理を管理してください。
   - 一意の `job_id` を生成し、後でジョブのステータスを追跡できるようにしてください。

4. **ステップの依存関係**:
   - 処理ステップには依存関係があります（例：summarization は text_extraction の後に実行する必要がある）。
   - ステップの順序を強制するか、依存関係を考慮したジョブスケジューリングを実装してください。
   - 例えば、`steps` に "summarization" のみが含まれ、コンテンツの text_extraction が完了していない場合は、自動的に text_extraction も実行するか、エラーを返すかを決定してください。

5. **AIモデル連携**:
   - `ai_model_id` が指定された場合、指定されたモデルが要求された処理ステップ（summarization など）をサポートしているか確認してください。
   - AIモデルへのリクエストにはレート制限やタイムアウトを設定し、適切にエラーハンドリングしてください。
   - AIモデルの使用量やトークン消費を監視・記録してください。

6. **状態管理**:
   - コンテンツの処理状態を適切に更新してください（例：status フィールドを "pending" に設定）。
   - 各ステップの開始時刻と完了時刻を記録し、processing_history を更新してください。

7. **エラーハンドリング**:
   - コンテンツが存在しない場合は `404 Not Found` を返してください。
   - 再処理中のエラーはログに記録し、コンテンツの error_message フィールドを更新してください。
   - ジョブキューの障害に備えて、適切なリトライメカニズムを実装してください。

8. **通知処理**:
   - "notification" ステップが含まれる場合、通知設定（チャンネル、テンプレートなど）を確認してください。
   - 通知の送信状態を notifications テーブルに記録してください。

9. **監査ログ**:
   - 誰がいつどのコンテンツの再処理をリクエストしたかを記録する監査ログを実装してください。
   - 使用されたAIモデルや処理ステップも記録してください。

10. **リソース管理**:
    - 同時に多数の再処理ジョブが実行されないよう、キューの同時実行数を制限することを検討してください。
    - 長時間実行されるジョブのタイムアウト処理を実装してください。

## notifications/history.md

# 通知履歴取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/notifications/history`
- **機能概要**: 送信された通知の履歴を取得
- **認証要否**: **要**(admin)

## リクエスト

**Query Parameters**:
- `page`: ページ番号 (デフォルト: 1)
- `per_page`: 1ページあたりの件数 (デフォルト: 20, 最大: 100)
- `start_date`: 開始日 (YYYY-MM-DD形式) (オプション)
- `end_date`: 終了日 (YYYY-MM-DD形式) (オプション)
- `status`: 通知ステータスでフィルタ (`sent`, `failed`, `pending`, `all`) (デフォルト: `all`)
- `channel`: 通知チャンネルでフィルタ (`email`, `slack`, `discord`, `all`) (デフォルト: `all`)
- `content_id`: 特定のコンテンツに関連する通知のみを取得 (オプション)
- `user_id`: 特定のユーザーに送信された通知のみを取得 (オプション)

## レスポンス

**Response**: `IAdminGetNotificationHistoryResponse`
```ts
export interface IAdminGetNotificationHistoryResponse {
  notifications: IAdminNotification[];
  pagination: {
    total: number;
    page: number;
    per_page: number;
    total_pages: number;
  };
  summary?: {
    total_sent: number;
    total_failed: number;
    total_pending: number;
    by_channel: {
      channel: string;
      count: number;
    }[];
  };
}

export interface IAdminNotification {
  id: number;
  type: "content_alert" | "digest" | "system_alert" | "custom";
  title: string;
  content_preview: string;
  channel: string;
  recipient: string;
  status: "sent" | "failed" | "pending";
  error_message?: string;
  content_id?: number;
  user_id?: number;
  created_at: string;
  sent_at?: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "notifications": [
    {
      "id": 123,
      "type": "content_alert",
      "title": "新しい記事: AIの進化と社会への影響",
      "content_preview": "近年のAI技術の急速な進化は社会に大きな影響を与えています...",
      "channel": "email",
      "recipient": "user@example.com",
      "status": "sent",
      "content_id": 456,
      "user_id": 789,
      "created_at": "2025-03-15T10:30:00Z",
      "sent_at": "2025-03-15T10:30:05Z"
    },
    {
      "id": 122,
      "type": "digest",
      "title": "DigeClip Daily Digest (2025-03-14)",
      "content_preview": "昨日の重要なコンテンツをまとめました。5件の新しい記事があります。",
      "channel": "slack",
      "recipient": "general",
      "status": "sent",
      "user_id": 789,
      "created_at": "2025-03-15T09:00:00Z",
      "sent_at": "2025-03-15T09:00:03Z"
    },
    {
      "id": 121,
      "type": "system_alert",
      "title": "システム警告: ディスク使用率が高くなっています",
      "content_preview": "ディスク使用率が85%に達しました。不要なファイルを削除してください。",
      "channel": "email",
      "recipient": "admin@example.com",
      "status": "failed",
      "error_message": "SMTP connection timeout",
      "created_at": "2025-03-14T23:45:10Z"
    }
  ],
  "pagination": {
    "total": 120,
    "page": 1,
    "per_page": 20,
    "total_pages": 6
  },
  "summary": {
    "total_sent": 115,
    "total_failed": 3,
    "total_pending": 2,
    "by_channel": [
      {
        "channel": "email",
        "count": 80
      },
      {
        "channel": "slack",
        "count": 35
      },
      {
        "channel": "discord",
        "count": 5
      }
    ]
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4012",
    "message": "Invalid date format",
    "details": {
      "start_date": "Must be in YYYY-MM-DD format"
    }
  }
}
```

## notifications/list.md

# 通知履歴一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/notifications`
- **機能概要**: 通知履歴の一覧を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request Query**:
```ts
export interface IAdminGetNotificationsQuery {
  status?: "success" | "failed";
  contentId?: number;
  page?: number;
  pageSize?: number;
}
```

**例**
```
GET /api/admin/notifications?status=failed&page=1&pageSize=10
```

## レスポンス

**Response**: `IAdminGetNotificationsResponse`
```ts
export interface INotificationItem {
  id: number;
  contentId: number;
  summaryId?: number;
  destination: string;
  status: "success" | "failed";
  sentAt: string;
  metadata?: Record<string, any>;
  error_message?: string;
}

export interface IAdminGetNotificationsResponse {
  data: INotificationItem[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "data": [
    {
      "id": 201,
      "contentId": 42,
      "summaryId": 101,
      "destination": "Discord Webhook #tech-news",
      "status": "success",
      "sentAt": "2025-03-10T15:00:00Z",
      "metadata": {
        "webhook_id": "webhook123",
        "message_id": "msg456"
      }
    },
    {
      "id": 202,
      "contentId": 43,
      "summaryId": 103,
      "destination": "Discord Webhook #programming",
      "status": "failed",
      "sentAt": "2025-03-09T10:35:00Z",
      "error_message": "Discord API rate limit exceeded",
      "metadata": {
        "webhook_id": "webhook456",
        "retry_count": 3
      }
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 10,
    "total": 2
  }
}
```

## エラー

**Error**: e.g. `403 Forbidden` (権限エラー)
```jsonc
{
  "error": {
    "code": "E4030",
    "message": "Admin permission required"
  }
}
```

## notifications/test.md

# 通知テスト送信 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/notifications/test`
- **機能概要**: テスト通知を送信して通知設定をテスト
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminTestNotificationRequest`
```ts
export interface IAdminTestNotificationRequest {
  channel: "email" | "slack" | "discord";
  recipient: string; // メールアドレス、Slackチャンネル名、Discordチャンネル名など
  title?: string; // 通知タイトル（省略時はデフォルトのテストタイトルが使用される）
  message?: string; // 通知メッセージ（省略時はデフォルトのテストメッセージが使用される）
  include_content_sample?: boolean; // コンテンツサンプルを含めるか
  content_id?: number; // 特定のコンテンツを使用する場合
}
```

**例 (リクエストJSON - メール通知)**
```jsonc
{
  "channel": "email",
  "recipient": "admin@example.com",
  "title": "DigeClip テスト通知",
  "message": "これはテスト通知です。通知設定が正しく機能していることを確認してください。"
}
```

**例 (リクエストJSON - Slack通知)**
```jsonc
{
  "channel": "slack",
  "recipient": "general",
  "include_content_sample": true
}
```

## レスポンス

**Response**: `IAdminTestNotificationResponse`
```ts
export interface IAdminTestNotificationResponse {
  success: boolean;
  message: string;
  notification_id?: number;
  details?: {
    channel: string;
    recipient: string;
    sent_at: string;
    delivery_status?: string;
    response_time_ms?: number;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}
```

**例 (レスポンスJSON - 成功)**
```jsonc
{
  "success": true,
  "message": "テスト通知が正常に送信されました",
  "notification_id": 124,
  "details": {
    "channel": "email",
    "recipient": "admin@example.com",
    "sent_at": "2025-03-15T17:30:15Z",
    "delivery_status": "delivered",
    "response_time_ms": 450
  }
}
```

**例 (レスポンスJSON - 失敗)**
```jsonc
{
  "success": false,
  "message": "テスト通知の送信に失敗しました",
  "error": {
    "code": "E5004",
    "message": "SMTP connection failed",
    "details": {
      "smtp_error": "Connection timed out"
    }
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4013",
    "message": "Invalid notification request",
    "details": {
      "recipient": "Valid email address is required for email channel"
    }
  }
}
```

**Error**: e.g. `500 Internal Server Error`
```jsonc
{
  "error": {
    "code": "E5005",
    "message": "Notification service unavailable",
    "details": {
      "service": "slack",
      "error": "API token not configured"
    }
  }
}
```

## sources/bulk.md

# ソース一括操作 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/sources/bulk`
- **機能概要**: 複数のソースに対して一括操作を実行
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminBulkSourceOperationRequest`
```ts
export interface IAdminBulkSourceOperationRequest {
  operation: "activate" | "deactivate" | "delete" | "sync";
  source_ids: number[];
}
```

**例 (リクエストJSON)**
```jsonc
{
  "operation": "activate",
  "source_ids": [1, 2, 3, 4, 5]
}
```

## レスポンス

**Response**: `IAdminBulkSourceOperationResponse`
```ts
export interface IAdminBulkSourceOperationResponse {
  message: string;
  operation: string;
  results: {
    success: number[];
    failed: {
      id: number;
      reason: string;
    }[];
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Bulk operation completed",
  "operation": "activate",
  "results": {
    "success": [1, 2, 4, 5],
    "failed": [
      {
        "id": 3,
        "reason": "Source not found"
      }
    ]
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効な操作)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid operation. Must be one of: activate, deactivate, delete, sync"
  }
}
```

**Error**: e.g. `400 Bad Request` (ソースIDが指定されていない)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "No source IDs provided"
  }
}
```

## sources/create.md

# ソース作成 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/sources`
- **機能概要**: 新しいソースを作成
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminCreateSourceRequest`
```ts
export interface IAdminCreateSourceRequest {
  name: string;
  type: "youtube" | "rss" | "arxiv" | "other";
  active?: boolean;

  // YouTube固有情報
  youtube_info?: {
    channel_id: string;
    channel_url: string;
  feed_url?: string;
    subscriber_count?: number;
    thumbnail_url?: string;
  };

  // RSS固有情報
  rss_info?: {
    site_url: string;
    feed_url: string;
    language?: string;
    favicon_url?: string;
  };

  // arXiv固有情報
  arxiv_info?: {
    category: string;
    query: string;
  };

  // その他のメタデータ
  metadata?: Record<string, any>;
}
```

**例 (リクエストJSON - YouTube)**
```jsonc
{
  "name": "テックYouTubeチャンネル",
  "type": "youtube",
  "active": true,
  "youtube_info": {
    "channel_id": "UC12345abcde",
    "channel_url": "https://www.youtube.com/channel/UC12345abcde",
    "feed_url": "https://www.youtube.com/feeds/videos.xml?channel_id=UC12345abcde",
    "subscriber_count": 100000,
    "thumbnail_url": "https://yt3.googleusercontent.com/ytc/123456789"
  }
}
```

**例 (リクエストJSON - RSS)**
```jsonc
{
  "name": "テックニュースブログ",
  "type": "rss",
  "active": true,
  "rss_info": {
    "site_url": "https://example.com/tech-blog",
  "feed_url": "https://example.com/tech-blog/feed",
    "language": "ja",
    "favicon_url": "https://example.com/favicon.ico"
  }
}
```

## レスポンス

**Response**: `IAdminCreateSourceResponse`
```ts
export interface IAdminCreateSourceResponse {
  id: number;
  name: string;
  type: "youtube" | "rss" | "arxiv" | "other";
  active: boolean;
  last_checked: string | null;
  created_at: string;
  updated_at: string;

  // ソースタイプに応じた情報
  youtube_info?: {
    channel_id: string;
    channel_url: string;
    feed_url: string;
    subscriber_count: number;
    thumbnail_url: string;
  };

  rss_info?: {
    site_url: string;
    feed_url: string;
    language: string;
    favicon_url: string;
  };

  arxiv_info?: {
    category: string;
    query: string;
  };
}
```

**例 (レスポンスJSON - YouTube)**
```jsonc
{
  "id": 5,
  "name": "テックYouTubeチャンネル",
  "type": "youtube",
  "active": true,
  "last_checked": null,
  "created_at": "2023-06-15T09:30:00Z",
  "updated_at": "2023-06-15T09:30:00Z",
  "youtube_info": {
    "channel_id": "UC12345abcde",
    "channel_url": "https://www.youtube.com/channel/UC12345abcde",
    "feed_url": "https://www.youtube.com/feeds/videos.xml?channel_id=UC12345abcde",
    "subscriber_count": 100000,
    "thumbnail_url": "https://yt3.googleusercontent.com/ytc/123456789"
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効なリクエストデータ)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid source data",
    "details": {
      "name": "Name is required",
      "type": "Type must be one of: youtube, rss, arxiv, other",
      "youtube_info": "YouTube info is required when type is youtube"
    }
  }
}
```

## sources/delete.md

# ソース削除 API

- **HTTPメソッド**: `DELETE`
- **エンドポイント**: `/api/admin/sources/[id]`
- **機能概要**: 特定のソースを削除
- **認証要否**: **要**(admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

## レスポンス

**Response**: `IAdminDeleteSourceResponse`
```ts
export interface IAdminDeleteSourceResponse {
  message: string;
  id: number;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Source deleted successfully",
  "id": 1
}
```

## エラー

**Error**: e.g. `404 Not Found` (ソースが見つからない)
```jsonc
{
  "error": {
    "code": "E4044",
    "message": "Source not found"
  }
}
```

## sources/detail.md

# ソース詳細取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/sources/[id]`
- **機能概要**: 特定のソースの詳細情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

## レスポンス

**Response**: `IAdminGetSourceDetailResponse`
```ts
export interface IAdminGetSourceDetailResponse {
  id: number;
  name: string;
  type: "youtube" | "rss" | "arxiv" | "other";
  active: boolean;
  last_checked?: string;
  created_at: string;
  updated_at: string;

  // YouTube固有情報
  youtube_info?: {
    channel_id: string;
    channel_url: string;
    feed_url: string;
    subscriber_count: number;
    thumbnail_url: string;
    metadata?: Record<string, any>;
  };

  // RSS固有情報
  rss_info?: {
    site_url: string;
    feed_url: string;
    language: string;
    favicon_url: string;
    metadata?: Record<string, any>;
  };

  // arXiv固有情報
  arxiv_info?: {
    category: string;
    query: string;
    metadata?: Record<string, any>;
  };

  stats?: {
    total_contents: number;
    new_contents_last_7days: number;
    failed_checks?: number;
  };
}
```

**例 (レスポンスJSON - YouTube)**
```jsonc
{
  "id": 1,
  "name": "テックチャンネル",
  "type": "youtube",
  "active": true,
  "last_checked": "2025-03-15T07:30:00Z",
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-03-15T07:30:00Z",
  "youtube_info": {
    "channel_id": "UC12345",
    "channel_url": "https://www.youtube.com/channel/UC12345",
    "feed_url": "https://www.youtube.com/feeds/videos.xml?channel_id=UC12345",
    "subscriber_count": 100000,
    "thumbnail_url": "https://yt3.googleusercontent.com/ytc/123456789"
  },
  "stats": {
    "total_contents": 156,
    "new_contents_last_7days": 4,
    "failed_checks": 0
  }
}
```

**例 (レスポンスJSON - RSS)**
```jsonc
{
  "id": 2,
  "name": "テックブログ",
  "type": "rss",
  "active": true,
  "last_checked": "2025-03-15T07:30:00Z",
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-03-15T07:30:00Z",
  "rss_info": {
    "site_url": "https://example.com/tech-blog",
    "feed_url": "https://example.com/tech-blog/feed",
    "language": "ja",
    "favicon_url": "https://example.com/favicon.ico"
  },
  "stats": {
    "total_contents": 78,
    "new_contents_last_7days": 3,
    "failed_checks": 0
  }
}
```

## エラー

**Error**: e.g. `404 Not Found` (ソースが見つからない)
```jsonc
{
  "error": {
    "code": "E4044",
    "message": "Source not found"
  }
}
```

## sources/export.md

# ソースエクスポート API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/sources/export`
- **機能概要**: ソース情報をCSVまたはJSONファイルとしてエクスポート
- **認証要否**: **要**(admin)

## リクエスト

**Request**: クエリパラメータ
- `format`: エクスポート形式（`csv` または `json`、デフォルト: `json`）
- `filter`: フィルター条件（例: `{"type":"rss","active":true}`）
- `include_stats`: 統計情報を含めるかどうか（`true` または `false`、デフォルト: `false`）

**例**
```
GET /api/admin/sources/export?format=csv&filter={"type":"rss"}&include_stats=true
```

## レスポンス

**Response**: ファイルダウンロード
- Content-Type: `text/csv` または `application/json`
- Content-Disposition: `attachment; filename="sources_export_YYYY-MM-DD.csv"` または `attachment; filename="sources_export_YYYY-MM-DD.json"`

**CSVファイル形式例**
```
id,name,type,url,feed_url,active,created_at,updated_at
1,テックニュースブログ,rss,https://example.com/tech-blog,https://example.com/tech-blog/feed,true,2023-06-15T09:30:00Z,2023-06-15T09:30:00Z
2,AIリサーチチャンネル,youtube,https://youtube.com/channel/ai-research,,true,2023-06-14T14:20:00Z,2023-06-14T14:20:00Z
```

**JSONファイル形式例**
```jsonc
[
  {
    "id": 1,
    "name": "テックニュースブログ",
    "type": "rss",
    "url": "https://example.com/tech-blog",
    "feed_url": "https://example.com/tech-blog/feed",
    "active": true,
    "created_at": "2023-06-15T09:30:00Z",
    "updated_at": "2023-06-15T09:30:00Z",
    "stats": {
      "content_count": 156,
      "last_content_date": "2023-06-15T08:45:00Z"
    }
  },
  {
    "id": 2,
    "name": "AIリサーチチャンネル",
    "type": "youtube",
    "url": "https://youtube.com/channel/ai-research",
    "feed_url": null,
    "active": true,
    "created_at": "2023-06-14T14:20:00Z",
    "updated_at": "2023-06-14T14:20:00Z",
    "stats": {
      "content_count": 42,
      "last_content_date": "2023-06-14T18:30:00Z"
    }
  }
]
```

## エラー

**Error**: e.g. `400 Bad Request` (無効なフォーマット)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid format. Must be one of: csv, json"
  }
}
```

**Error**: e.g. `400 Bad Request` (無効なフィルター)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid filter format. Must be a valid JSON object"
  }
}
```

## sources/import.md

# ソースインポート API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/sources/import`
- **機能概要**: CSVまたはJSONファイルからソースを一括インポート
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `multipart/form-data`
- `file`: CSVまたはJSONファイル
- `options`: インポートオプション（JSON文字列）

**インポートオプション**
```ts
export interface IAdminSourceImportOptions {
  skip_validation?: boolean;
  update_existing?: boolean;
  default_active_state?: boolean;
}
```

**CSVファイル形式例**
```
name,type,url,feed_url,active
テックニュースブログ,rss,https://example.com/tech-blog,https://example.com/tech-blog/feed,true
AIリサーチチャンネル,youtube,https://youtube.com/channel/ai-research,,true
```

**JSONファイル形式例**
```jsonc
[
  {
    "name": "テックニュースブログ",
    "type": "rss",
    "url": "https://example.com/tech-blog",
    "feed_url": "https://example.com/tech-blog/feed",
    "active": true
  },
  {
    "name": "AIリサーチチャンネル",
    "type": "youtube",
    "url": "https://youtube.com/channel/ai-research",
    "active": true
  }
]
```

## レスポンス

**Response**: `IAdminSourceImportResponse`
```ts
export interface IAdminSourceImportResponse {
  message: string;
  import_results: {
    total: number;
    imported: number;
    updated: number;
    skipped: number;
    failed: number;
    errors: {
      row: number;
      message: string;
    }[];
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Import completed",
  "import_results": {
    "total": 10,
    "imported": 8,
    "updated": 0,
    "skipped": 0,
    "failed": 2,
    "errors": [
      {
        "row": 3,
        "message": "Invalid URL format"
      },
      {
        "row": 7,
        "message": "Missing required field: name"
      }
    ]
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request` (ファイルが提供されていない)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "No file provided"
  }
}
```

**Error**: e.g. `400 Bad Request` (サポートされていないファイル形式)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Unsupported file format. Only CSV and JSON are supported"
  }
}
```

## sources/list.md

# ソース一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/sources`
- **機能概要**: 監視対象ソース（YouTube、RSS、arXivなど）の一覧を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request Query**:
```ts
export interface IAdminGetSourcesQuery {
  type?: "youtube" | "rss" | "arxiv" | "other";
  active?: boolean;
  page?: number;
  pageSize?: number;
}
```

**例**
```
GET /api/admin/sources?type=youtube&active=true&page=1&pageSize=10
```

## レスポンス

**Response**:
```ts
export interface ISourceItem {
  id: number;
  name: string;
  type: "youtube" | "rss" | "arxiv" | "other";
  active: boolean;
  last_checked?: string;
  created_at: string;
  updated_at: string;

  // ソースタイプに応じた情報（一覧表示用に簡略化）
  youtube_info?: {
    channel_id: string;
    channel_url: string;
    subscriber_count?: number;
    thumbnail_url?: string;
  };

  rss_info?: {
    site_url: string;
    feed_url: string;
  };

  arxiv_info?: {
    category: string;
  };

  // 統計情報
  content_count?: number;
}

export interface IAdminGetSourcesResponse {
  data: ISourceItem[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "data": [
    {
      "id": 1,
      "name": "テックチャンネル",
      "type": "youtube",
      "active": true,
      "last_checked": "2025-03-15T07:30:00Z",
      "created_at": "2025-01-01T00:00:00Z",
      "updated_at": "2025-03-15T07:30:00Z",
      "youtube_info": {
        "channel_id": "UC12345",
        "channel_url": "https://www.youtube.com/channel/UC12345",
        "subscriber_count": 100000,
        "thumbnail_url": "https://yt3.googleusercontent.com/ytc/123456789"
      },
      "content_count": 156
    },
    {
      "id": 2,
      "name": "プログラミングブログ",
      "type": "rss",
      "active": true,
      "last_checked": "2025-03-15T07:30:00Z",
      "created_at": "2025-01-02T00:00:00Z",
      "updated_at": "2025-03-15T07:30:00Z",
      "rss_info": {
        "site_url": "https://example.com/programming-blog",
        "feed_url": "https://example.com/programming-blog/feed"
      },
      "content_count": 78
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 10,
    "total": 25
  }
}
```

## エラー

**Error**: e.g. `403 Forbidden` (権限エラー)
```jsonc
{
  "error": {
    "code": "E4030",
    "message": "Admin permission required"
  }
}
```

## sources/stats.md

# ソース統計情報取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/sources/stats`
- **機能概要**: ソースの統計情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Request**: クエリパラメータ
- `period`: 期間（例: `day`, `week`, `month`, `year`）
- `type`: ソースタイプでフィルター（例: `rss`, `youtube`, `arxiv`）

## レスポンス

**Response**: `IAdminSourceStatsResponse`
```ts
export interface IAdminSourceStatsResponse {
  total_sources: number;
  active_sources: number;
  sources_by_type: {
    type: string;
    count: number;
  }[];
  content_stats: {
    total_content: number;
    content_last_24h: number;
    content_last_week: number;
    content_last_month: number;
  };
  source_activity: {
    date: string;
    content_count: number;
  }[];
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "total_sources": 25,
  "active_sources": 20,
  "sources_by_type": [
    {
      "type": "rss",
      "count": 12
    },
    {
      "type": "youtube",
      "count": 8
    },
    {
      "type": "arxiv",
      "count": 5
    }
  ],
  "content_stats": {
    "total_content": 5280,
    "content_last_24h": 42,
    "content_last_week": 315,
    "content_last_month": 1250
  },
  "source_activity": [
    {
      "date": "2023-06-15",
      "content_count": 42
    },
    {
      "date": "2023-06-14",
      "content_count": 38
    },
    {
      "date": "2023-06-13",
      "content_count": 45
    },
    {
      "date": "2023-06-12",
      "content_count": 40
    },
    {
      "date": "2023-06-11",
      "content_count": 35
    },
    {
      "date": "2023-06-10",
      "content_count": 50
    },
    {
      "date": "2023-06-09",
      "content_count": 65
    }
  ]
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効なクエリパラメータ)
```jsonc
{
  "error": {
    "code": "E4003",
    "message": "Invalid period parameter. Must be one of: day, week, month, year"
  }
}
```

## sources/sync.md

# ソース同期 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/sources/[id]/sync`
- **機能概要**: 特定のソースのコンテンツを手動で同期
- **認証要否**: **要**(admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

**例**
```
POST /api/admin/sources/5/sync
```

## レスポンス

**Response**: `IAdminSyncSourceResponse`
```ts
export interface IAdminSyncSourceResponse {
  message: string;
  source_id: number;
  sync_status: "started" | "completed" | "failed";
  sync_details?: {
    new_content_count: number;
    updated_content_count: number;
    error_count: number;
  };
  job_id?: string;
}
```

**例 (レスポンスJSON - 同期開始)**
```jsonc
{
  "message": "Source sync job started",
  "source_id": 5,
  "sync_status": "started",
  "job_id": "sync-job-12345"
}
```

**例 (レスポンスJSON - 同期完了、即時実行の場合)**
```jsonc
{
  "message": "Source sync completed successfully",
  "source_id": 5,
  "sync_status": "completed",
  "sync_details": {
    "new_content_count": 12,
    "updated_content_count": 3,
    "error_count": 0
  }
}
```

## エラー

**Error**: e.g. `404 Not Found` (ソースが見つからない)
```jsonc
{
  "error": {
    "code": "E4044",
    "message": "Source not found"
  }
}
```

**Error**: e.g. `409 Conflict` (同期処理が既に実行中)
```jsonc
{
  "error": {
    "code": "E4090",
    "message": "Sync already in progress for this source",
    "details": {
      "job_id": "sync-job-12345",
      "started_at": "2023-06-15T10:30:00Z"
    }
  }
}
```

## sources/update.md

# ソース更新 API

- **HTTPメソッド**: `PUT`
- **エンドポイント**: `/api/admin/sources/[id]`
- **機能概要**: 既存のソース情報を更新
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminUpdateSourceRequest`
```ts
export interface IAdminUpdateSourceRequest {
  name?: string;
  active?: boolean;

  // YouTube固有情報
  youtube_info?: {
    channel_url?: string;
    feed_url?: string;
    subscriber_count?: number;
    thumbnail_url?: string;
  };

  // RSS固有情報
  rss_info?: {
    site_url?: string;
  feed_url?: string;
    language?: string;
    favicon_url?: string;
  };

  // arXiv固有情報
  arxiv_info?: {
    category?: string;
    query?: string;
  };

  // その他のメタデータ
  metadata?: Record<string, any>;
}
```

**例 (リクエストJSON - YouTube)**
```jsonc
{
  "name": "更新後のチャンネル名",
  "active": false,
  "youtube_info": {
    "subscriber_count": 120000,
    "thumbnail_url": "https://yt3.googleusercontent.com/ytc/updated-thumbnail"
  }
}
```

**例 (リクエストJSON - RSS)**
```jsonc
{
  "name": "更新後のブログ名",
  "rss_info": {
    "feed_url": "https://example.com/updated-blog/feed",
    "language": "en"
  }
}
```

## レスポンス

**Response**: `IAdminUpdateSourceResponse`
```ts
export interface IAdminUpdateSourceResponse {
  id: number;
  name: string;
  type: "youtube" | "rss" | "arxiv" | "other";
  active: boolean;
  last_checked: string | null;
  created_at: string;
  updated_at: string;

  // ソースタイプに応じた情報
  youtube_info?: {
    channel_id: string;
    channel_url: string;
    feed_url: string;
    subscriber_count: number;
    thumbnail_url: string;
  };

  rss_info?: {
    site_url: string;
    feed_url: string;
    language: string;
    favicon_url: string;
  };

  arxiv_info?: {
    category: string;
    query: string;
  };
}
```

**例 (レスポンスJSON - YouTube)**
```jsonc
{
  "id": 1,
  "name": "更新後のチャンネル名",
  "type": "youtube",
  "active": false,
  "last_checked": "2025-03-15T07:30:00Z",
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-03-16T10:45:00Z",
  "youtube_info": {
    "channel_id": "UC12345",
    "channel_url": "https://www.youtube.com/channel/UC12345",
    "feed_url": "https://www.youtube.com/feeds/videos.xml?channel_id=UC12345",
    "subscriber_count": 120000,
    "thumbnail_url": "https://yt3.googleusercontent.com/ytc/updated-thumbnail"
  }
}
```

## エラー

**Error**: e.g. `404 Not Found` (ソースが見つからない)
```jsonc
{
  "error": {
    "code": "E4044",
    "message": "Source not found"
  }
}
```

**Error**: e.g. `400 Bad Request` (無効なリクエストデータ)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid source data",
    "details": {
      "youtube_info": "YouTube info can only be updated for YouTube sources"
    }
  }
}
```

## sources/validate.md

# ソース検証 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/sources/validate`
- **機能概要**: ソースURLの有効性を検証（ソース作成/更新前の事前チェック）
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminValidateSourceRequest`
```ts
export interface IAdminValidateSourceRequest {
  type: string;
  url: string;
  feed_url?: string;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "type": "rss",
  "url": "https://example.com/tech-blog",
  "feed_url": "https://example.com/tech-blog/feed"
}
```

## レスポンス

**Response**: `IAdminValidateSourceResponse`
```ts
export interface IAdminValidateSourceResponse {
  valid: boolean;
  message: string;
  details?: {
    detected_feed_url?: string;
    content_sample?: {
      title: string;
      published_at: string;
    }[];
    metadata?: Record<string, any>;
  };
  errors?: string[];
}
```

**例 (レスポンスJSON - 有効なソース)**
```jsonc
{
  "valid": true,
  "message": "Source validated successfully",
  "details": {
    "detected_feed_url": "https://example.com/tech-blog/feed",
    "content_sample": [
      {
        "title": "最新のAI技術トレンド",
        "published_at": "2023-06-14T15:30:00Z"
      },
      {
        "title": "プログラミング言語の比較",
        "published_at": "2023-06-12T09:45:00Z"
      }
    ],
    "metadata": {
      "title": "テックニュースブログ",
      "description": "最新の技術トレンドを発信するブログ",
      "language": "ja",
      "update_frequency": "daily"
    }
  }
}
```

**例 (レスポンスJSON - 無効なソース)**
```jsonc
{
  "valid": false,
  "message": "Source validation failed",
  "errors": [
    "Feed URL is not accessible",
    "Could not detect valid RSS or Atom format"
  ]
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効なリクエストデータ)
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid request data",
    "details": {
      "type": "Source type is required",
      "url": "URL must be a valid URL"
    }
  }
}
```

## system/logs.md

# システムログ取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/system/logs`
- **機能概要**: システムログを取得
- **認証要否**: **要**(admin)

## リクエスト

**Query Parameters**:
- `level`: ログレベル（"error", "warn", "info", "debug"）、デフォルトは "error"
- `start_date`: 開始日時（ISO 8601形式）
- `end_date`: 終了日時（ISO 8601形式）、デフォルトは現在時刻
- `component`: コンポーネント名でフィルタリング（例: "database", "auth", "ai"）
- `search`: ログメッセージ内の検索キーワード
- `page`: ページ番号（1から開始）、デフォルトは1
- `per_page`: 1ページあたりの件数、デフォルトは50、最大100

## レスポンス

**Response**: `IAdminGetSystemLogsResponse`
```ts
export interface IAdminGetSystemLogsResponse {
  logs: {
    id: string;
    timestamp: string;
    level: "error" | "warn" | "info" | "debug";
    component: string;
    message: string;
    details?: any;
    request_id?: string;
    user_id?: number;
  }[];
  pagination: {
    total: number;
    page: number;
    per_page: number;
    total_pages: number;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "logs": [
    {
      "id": "log_12345",
      "timestamp": "2025-03-15T14:22:15Z",
      "level": "error",
      "component": "ai_service",
      "message": "AI model connection timeout",
      "details": {
        "model_id": 2,
        "model_name": "Claude 3 Opus",
        "timeout_ms": 30000,
        "request_payload_size": 15240
      },
      "request_id": "req_abcdef123456",
      "user_id": 42
    },
    {
      "id": "log_12344",
      "timestamp": "2025-03-15T14:20:05Z",
      "level": "error",
      "component": "database",
      "message": "Database query failed",
      "details": {
        "query_type": "SELECT",
        "table": "contents",
        "error_code": "23505"
      },
      "request_id": "req_abcdef123455"
    }
  ],
  "pagination": {
    "total": 128,
    "page": 1,
    "per_page": 50,
    "total_pages": 3
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid query parameters",
    "details": {
      "level": "Unknown log level: 'critical'"
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。
   - ログには機密情報が含まれる可能性があるため、認可チェックは厳格に行ってください。

2. **クエリパラメータの検証**:
   - `level` パラメータが指定された場合、有効な値（"error", "warn", "info", "debug"）であることを確認してください。
   - 日付パラメータ（`start_date`, `end_date`）が指定された場合、有効なISO 8601形式であることを確認してください。
   - `end_date` が `start_date` より後の日時であることを確認してください。
   - `page` と `per_page` は正の整数であることを確認してください。
   - `per_page` の最大値（100）を超えないようにしてください。

3. **日付範囲の制限**:
   - パフォーマンスとセキュリティの観点から、取得可能なログの日付範囲に制限を設けることを検討してください（例：最大30日間）。
   - 日付範囲が指定されていない場合のデフォルト範囲を設定してください（例：過去24時間）。

4. **ログストレージの考慮**:
   - ログの保存方法に応じて、適切なクエリを実装してください:
     - データベース（RDB）に保存している場合: SQLクエリでフィルタリングと検索を実装
     - 専用のログサービス（CloudWatch, Datadog等）を使用している場合: そのサービスのAPIを使用
     - ファイルシステムに保存している場合: ファイル読み込みとパース処理を実装
   - 大量のログデータがある場合、インデックスの活用やクエリの最適化を検討してください。

5. **機密情報の取り扱い**:
   - ログ内の機密情報（パスワード、トークン、個人情報など）は適切にマスクまたは除外してください。
   - `details` フィールドには機密情報が含まれないように注意してください。
   - 必要に応じて、ログデータを返す前に追加のフィルタリングを実装してください。

6. **パフォーマンス最適化**:
   - ログデータは大量になる可能性があるため、クエリのパフォーマンスに注意してください。
   - 以下の最適化を検討してください:
     - 適切なインデックスの使用（timestamp, level, component など）
     - 必要最小限のフィールドのみを取得
     - 検索条件の最適化（部分一致よりも前方一致を優先するなど）
     - 結果のキャッシュ（短時間のTTLで）

7. **ページネーション実装**:
   - 大量のログデータを効率的に取得するために、適切なページネーションを実装してください。
   - オフセットベースのページネーション（LIMIT/OFFSET）よりも、カーソルベースのページネーションを検討してください。
   - 特に日付範囲が広い場合や、検索条件が緩い場合は、結果セットが大きくなる可能性があります。

8. **検索機能の実装**:
   - `search` パラメータによる検索は、ログメッセージ内の部分一致として実装してください。
   - 大文字/小文字を区別しない検索を実装してください。
   - 検索パフォーマンスを向上させるために、全文検索インデックスの使用を検討してください。

9. **コンポーネントフィルタリング**:
   - 有効なコンポーネント名のリストを定義し、`component` パラメータの検証に使用することを検討してください。
   - コンポーネント名は一貫性を持って記録されるようにしてください。

10. **エラーハンドリング**:
    - ログストレージへのアクセスエラーは適切に処理し、明確なエラーメッセージを返してください。
    - 内部エラーの詳細はユーザーに公開せず、エラーログに記録してください。

11. **レスポンスサイズの制限**:
    - 大量のログデータがある場合、レスポンスサイズが大きくなる可能性があります。
    - `per_page` パラメータの最大値を適切に設定し、レスポンスサイズを制限してください。
    - 必要に応じて、詳細情報（`details` フィールド）のサイズを制限することを検討してください。

12. **日付フォーマット**:
    - すべての日時フィールド（timestamp）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
    - タイムゾーンは UTC を使用してください。

13. **ログレベルの階層的フィルタリング**:
    - ログレベルは階層的に考慮することを検討してください（例：`level=error` を指定した場合、error レベルのログのみを返す）。
    - オプションとして、階層的フィルタリングをサポートすることも検討してください（例：`level=warn` を指定した場合、warn と error レベルのログを返す）。

14. **リクエストIDによる関連ログの取得**:
    - オプションとして、特定の `request_id` に関連するすべてのログを取得する機能を検討してください。
    - これにより、特定のリクエストに関連する問題のトラブルシューティングが容易になります。

## system/monitor.md

# システムモニター実行 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/system/monitor`
- **機能概要**: システムの健全性チェックを手動で実行
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminRunSystemMonitorRequest`
```ts
export interface IAdminRunSystemMonitorRequest {
  components?: ("database" | "cache" | "queue" | "storage" | "ai_services" | "all")[];
  detailed?: boolean; // 詳細な診断情報を取得するか
  timeout_ms?: number; // 各コンポーネントのチェックタイムアウト（ミリ秒）
}
```

**例 (リクエストJSON)**
```jsonc
{
  "components": ["database", "ai_services"],
  "detailed": true,
  "timeout_ms": 5000
}
```

## レスポンス

**Response**: `IAdminRunSystemMonitorResponse`
```ts
export interface IAdminRunSystemMonitorResponse {
  job_id: string;
  status: "queued" | "running" | "completed";
  started_at: string;
  completed_at?: string;
  results?: {
    overall_status: "healthy" | "degraded" | "unhealthy";
    components: {
      [key: string]: {
        status: "healthy" | "degraded" | "unhealthy";
        message?: string;
        details?: Record<string, any>;
        checks?: {
          name: string;
          status: "passed" | "warning" | "failed";
          message?: string;
          value?: any;
          threshold?: any;
        }[];
        duration_ms: number;
      };
    };
  };
}
```

**例 (レスポンスJSON - 即時完了)**
```jsonc
{
  "job_id": "monitor_20250315_153045",
  "status": "completed",
  "started_at": "2025-03-15T15:30:45Z",
  "completed_at": "2025-03-15T15:30:48Z",
  "results": {
    "overall_status": "healthy",
    "components": {
      "database": {
        "status": "healthy",
        "message": "Database is operating normally",
        "details": {
          "version": "PostgreSQL 15.3",
          "connections": 12,
          "max_connections": 100
        },
        "checks": [
          {
            "name": "connection",
            "status": "passed",
            "message": "Connected successfully"
          },
          {
            "name": "query_latency",
            "status": "passed",
            "message": "Query latency within acceptable range",
            "value": 4.2,
            "threshold": 50
          },
          {
            "name": "connection_pool",
            "status": "passed",
            "message": "Connection pool usage normal",
            "value": 12,
            "threshold": 80
          }
        ],
        "duration_ms": 120
      },
      "ai_services": {
        "status": "healthy",
        "message": "All AI services are responding",
        "details": {
          "active_models": 3,
          "api_keys_configured": 3,
          "recent_errors": 0
        },
        "checks": [
          {
            "name": "openai_api",
            "status": "passed",
            "message": "OpenAI API responding"
          },
          {
            "name": "anthropic_api",
            "status": "passed",
            "message": "Anthropic API responding"
          },
          {
            "name": "google_api",
            "status": "passed",
            "message": "Google AI API responding"
          }
        ],
        "duration_ms": 2100
      }
    }
  }
}
```

**例 (レスポンスJSON - 非同期実行)**
```jsonc
{
  "job_id": "monitor_20250315_153045",
  "status": "queued",
  "started_at": "2025-03-15T15:30:45Z"
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4009",
    "message": "Invalid monitor request",
    "details": {
      "components": "Unknown component specified"
    }
  }
}
```

**Error**: e.g. `500 Internal Server Error`
```jsonc
{
  "error": {
    "code": "E5001",
    "message": "Failed to initiate system monitor"
  }
}
```

## system/run-monitor.md

# 監視処理手動実行 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/system/run-monitor`
- **機能概要**: 監視処理を手動で実行
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminRunMonitorRequest`
```ts
export interface IAdminRunMonitorRequest {
  sourceId?: number; // 特定のソースのみ実行する場合
  steps?: ("detection" | "text_extraction" | "summarization" | "notification")[];
}
```

**例 (リクエストJSON)**
```jsonc
{
  "sourceId": 1,
  "steps": ["detection", "text_extraction", "summarization"]
}
```

## レスポンス

**Response**: `IAdminRunMonitorResponse`
```ts
export interface IAdminRunMonitorResponse {
  message: string;
  job_id: string;
  started_at: string;
  estimated_completion?: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Monitor job started",
  "job_id": "monitor_20250315_123456",
  "started_at": "2025-03-15T11:30:00Z",
  "estimated_completion": "2025-03-15T11:35:00Z"
}
```

## エラー

**Error**: e.g. `404 Not Found` (ソースが見つからない)
```jsonc
{
  "error": {
    "code": "E4044",
    "message": "Source not found"
  }
}
```

## system/settings.md

# アプリケーション設定取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/system/settings`
- **機能概要**: システム全体の設定情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Query Parameters**:
- `category`: 取得する設定カテゴリ (`general`, `notifications`, `ai`, `sources`, `security`, `all`) (デフォルト: `all`)

## レスポンス

**Response**: `IAdminGetSystemSettingsResponse`
```ts
export interface IAdminGetSystemSettingsResponse {
  settings: {
    general?: {
      site_name: string;
      site_description?: string;
      default_language: string;
      timezone: string;
      date_format: string;
      enable_public_access: boolean;
    };
    notifications?: {
      enable_email: boolean;
      enable_slack: boolean;
      enable_discord: boolean;
      default_notification_channel: string;
      notification_frequency: "immediate" | "hourly" | "daily" | "weekly";
      digest_time?: string; // HH:MM形式
      digest_day?: number; // 週次ダイジェストの曜日 (0-6, 0=日曜)
    };
    ai?: {
      default_summarization_model_id: number;
      default_tagging_model_id: number;
      default_extraction_model_id: number;
      enable_auto_tagging: boolean;
      enable_auto_summarization: boolean;
      max_tokens_per_request: number;
      content_safety_filter: "none" | "low" | "medium" | "high";
    };
    sources?: {
      default_check_interval: number; // 分単位
      max_content_age: number; // 日単位
      auto_deactivate_failing_sources: boolean;
      max_failures_before_deactivation: number;
      content_fetch_timeout: number; // 秒単位
    };
    security?: {
      session_timeout: number; // 分単位
      max_login_attempts: number;
      require_2fa_for_admins: boolean;
      password_policy: {
        min_length: number;
        require_uppercase: boolean;
        require_lowercase: boolean;
        require_numbers: boolean;
        require_special_chars: boolean;
      };
      api_rate_limits: {
        enabled: boolean;
        requests_per_minute: number;
        requests_per_hour: number;
      };
    };
  };
  last_updated: string;
  updated_by?: string;
}
```

**例 (レスポンスJSON - 全カテゴリ)**
```jsonc
{
  "settings": {
    "general": {
      "site_name": "DigeClip",
      "site_description": "AIを活用したコンテンツ収集・要約システム",
      "default_language": "ja",
      "timezone": "Asia/Tokyo",
      "date_format": "YYYY-MM-DD",
      "enable_public_access": false
    },
    "notifications": {
      "enable_email": true,
      "enable_slack": true,
      "enable_discord": false,
      "default_notification_channel": "email",
      "notification_frequency": "daily",
      "digest_time": "09:00"
    },
    "ai": {
      "default_summarization_model_id": 2,
      "default_tagging_model_id": 2,
      "default_extraction_model_id": 1,
      "enable_auto_tagging": true,
      "enable_auto_summarization": true,
      "max_tokens_per_request": 4000,
      "content_safety_filter": "medium"
    },
    "sources": {
      "default_check_interval": 60,
      "max_content_age": 30,
      "auto_deactivate_failing_sources": true,
      "max_failures_before_deactivation": 5,
      "content_fetch_timeout": 30
    },
    "security": {
      "session_timeout": 120,
      "max_login_attempts": 5,
      "require_2fa_for_admins": true,
      "password_policy": {
        "min_length": 10,
        "require_uppercase": true,
        "require_lowercase": true,
        "require_numbers": true,
        "require_special_chars": true
      },
      "api_rate_limits": {
        "enabled": true,
        "requests_per_minute": 60,
        "requests_per_hour": 1000
      }
    }
  },
  "last_updated": "2025-03-10T08:45:30Z",
  "updated_by": "admin@example.com"
}
```

**例 (レスポンスJSON - 特定カテゴリのみ)**
```jsonc
{
  "settings": {
    "ai": {
      "default_summarization_model_id": 2,
      "default_tagging_model_id": 2,
      "default_extraction_model_id": 1,
      "enable_auto_tagging": true,
      "enable_auto_summarization": true,
      "max_tokens_per_request": 4000,
      "content_safety_filter": "medium"
    }
  },
  "last_updated": "2025-03-10T08:45:30Z",
  "updated_by": "admin@example.com"
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4010",
    "message": "Invalid settings category"
  }
}
```

## system/status.md

# システムステータス取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/system/status`
- **機能概要**: システムの現在の状態と統計情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Query Parameters**:
- `include`: 含める情報（カンマ区切りで複数指定可）
  - `all`: すべての情報を含める（デフォルト）
  - `system`: システム基本情報のみ
  - `contents`: コンテンツ統計のみ
  - `sources`: ソース統計のみ
  - `ai`: AI使用統計のみ
  - `users`: ユーザー統計のみ

## レスポンス

**Response**: `IAdminGetSystemStatusResponse`
```ts
export interface IAdminGetSystemStatusResponse {
  system: {
    status: "healthy" | "degraded" | "maintenance";
    version: string;
    uptime: number; // 秒単位
    last_backup: string;
    environment: string;
    current_time: string;
  };
  contents?: {
    total: number;
    by_status: {
      pending: number;
      summarized: number;
      error: number;
    };
    by_type: {
      video: number;
      article: number;
      paper: number;
      other: number;
    };
    recent_activity: {
      last_24h: number;
      last_7d: number;
      last_30d: number;
    };
  };
  sources?: {
    total: number;
    active: number;
    by_type: {
      rss: number;
      youtube: number;
      twitter: number;
      custom: number;
    };
    sync_status: {
      up_to_date: number;
      needs_sync: number;
      error: number;
    };
  };
  ai?: {
    models: {
      id: number;
      name: string;
      requests_count: number;
      tokens_used: number;
      average_response_time: number;
    }[];
    total_tokens: number;
    estimated_cost: number;
  };
  users?: {
    total: number;
    active_last_30d: number;
    by_role: {
      admin: number;
      user: number;
    };
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "system": {
    "status": "healthy",
    "version": "1.2.3",
    "uptime": 1209600,
    "last_backup": "2025-03-14T03:00:00Z",
    "environment": "production",
    "current_time": "2025-03-15T12:30:45Z"
  },
  "contents": {
    "total": 1250,
    "by_status": {
      "pending": 15,
      "summarized": 1200,
      "error": 35
    },
    "by_type": {
      "video": 450,
      "article": 720,
      "paper": 50,
      "other": 30
    },
    "recent_activity": {
      "last_24h": 42,
      "last_7d": 180,
      "last_30d": 520
    }
  },
  "sources": {
    "total": 25,
    "active": 22,
    "by_type": {
      "rss": 15,
      "youtube": 8,
      "twitter": 2,
      "custom": 0
    },
    "sync_status": {
      "up_to_date": 20,
      "needs_sync": 2,
      "error": 3
    }
  },
  "ai": {
    "models": [
      {
        "id": 1,
        "name": "GPT-4",
        "requests_count": 3500,
        "tokens_used": 7500000,
        "average_response_time": 2.8
      },
      {
        "id": 2,
        "name": "Claude 3 Opus",
        "requests_count": 1250,
        "tokens_used": 3750000,
        "average_response_time": 2.3
      }
    ],
    "total_tokens": 11250000,
    "estimated_cost": 225.5
  },
  "users": {
    "total": 150,
    "active_last_30d": 120,
    "by_role": {
      "admin": 5,
      "user": 145
    }
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid include parameter",
    "details": {
      "include": "Unknown value: 'invalid_section'"
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **クエリパラメータの検証**:
   - `include` パラメータが指定された場合、有効な値（"all", "system", "contents", "sources", "ai", "users"）であることを確認してください。
   - 無効な値が含まれる場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **パフォーマンス最適化**:
   - このAPIは複数のテーブルから集計データを取得するため、クエリのパフォーマンスに注意してください。
   - 特に大量のデータがある場合、集計クエリが重くなる可能性があります。
   - 必要に応じて、以下の最適化を検討してください:
     - 集計データをキャッシュする
     - 定期的にバックグラウンドジョブで集計を更新する
     - `include` パラメータに基づいて必要な集計のみを実行する
     - 大規模なテーブルに対しては、近似集計を使用する

4. **システム状態の判定**:
   - `system.status` の値（"healthy", "degraded", "maintenance"）は、以下のような基準で判断してください:
     - "healthy": すべてのサービスが正常に動作している
     - "degraded": 一部のサービスに問題があるが、システム全体は動作している
     - "maintenance": 計画的なメンテナンス中
   - 状態判定のロジックを明確に定義し、一貫して実装してください。

5. **バージョン情報**:
   - `system.version` はアプリケーションのバージョンを返します。
   - 環境変数やビルド時に設定された値を使用するか、パッケージ情報から取得してください。

6. **稼働時間の計算**:
   - `system.uptime` はサーバーの稼働時間を秒単位で返します。
   - アプリケーションの起動時刻を記録し、現在時刻との差分を計算してください。
   - サーバーレス環境では、この値が意味を持たない場合があります。その場合は、最後のデプロイからの経過時間などの代替値を検討してください。

7. **日付フォーマット**:
   - すべての日時フィールド（last_backup, current_time）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

8. **コンテンツ統計**:
   - `contents` セクションの統計情報は、`contents` テーブルから集計します。
   - 状態別、タイプ別の集計には GROUP BY クエリを使用してください。
   - 最近のアクティビティは、created_at または updated_at フィールドに基づいて計算してください。

9. **ソース統計**:
   - `sources` セクションの統計情報は、`sources` テーブルから集計します。
   - アクティブなソースは、`active` フラグまたは最終同期日時に基づいて判断してください。
   - 同期ステータスは、最終同期日時と同期間隔の設定に基づいて計算してください。

10. **AI使用統計**:
    - `ai` セクションの統計情報は、`ai_models` テーブルと使用ログから集計します。
    - トークン使用量とコスト見積もりは、記録された使用履歴に基づいて計算してください。
    - コスト計算には、各モデルの料金設定を考慮してください。

11. **ユーザー統計**:
    - `users` セクションの統計情報は、`users` テーブルから集計します。
    - アクティブユーザー数は、最終ログイン日時に基づいて計算してください。

12. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - 一部の統計情報の取得に失敗した場合でも、可能な限り他の情報は返すようにしてください。

13. **キャッシュ戦略**:
    - このAPIは頻繁に呼び出される可能性があり、計算コストが高いため、適切なキャッシュ戦略を実装することを強く推奨します。
    - キャッシュの有効期限（TTL）を設定し、定期的に更新するようにしてください（例：5分間隔）。
    - 特定のイベント（新しいコンテンツの追加、ソースの更新など）が発生した場合にキャッシュを無効化することも検討してください。

14. **セキュリティ考慮事項**:
    - このAPIは管理者向けの機密情報を含むため、適切な認証と認可を徹底してください。
    - レスポンスには機密情報（APIキー、パスワードなど）を含めないでください。

## system/update-settings.md

# アプリケーション設定更新 API

- **HTTPメソッド**: `PUT`
- **エンドポイント**: `/api/admin/system/settings`
- **機能概要**: アプリケーション設定を更新
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminUpdateSettingsRequest`
```ts
export interface IAdminUpdateSettingsRequest {
  settings: Record<string, any>;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "settings": {
    "monitor_interval": 1800,
    "default_summary_length": 600,
    "log_level": "debug"
  }
}
```

## レスポンス

**Response**: `IAdminUpdateSettingsResponse`
```ts
export interface IAdminUpdateSettingsResponse {
  message: string;
  updated_settings: string[];
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Settings updated successfully",
  "updated_settings": [
    "monitor_interval",
    "default_summary_length",
    "log_level"
  ]
}
```

## エラー

**Error**: e.g. `400 Bad Request` (無効な設定値)
```jsonc
{
  "error": {
    "code": "E4004",
    "message": "Invalid setting value: monitor_interval must be >= 300"
  }
}
```

## system/update_settings.md

# アプリケーション設定更新 API

- **HTTPメソッド**: `PUT`
- **エンドポイント**: `/api/admin/system/settings`
- **機能概要**: システム全体の設定情報を更新
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminUpdateSystemSettingsRequest`
```ts
export interface IAdminUpdateSystemSettingsRequest {
  settings: {
    general?: {
      site_name?: string;
      site_description?: string;
      default_language?: string;
      timezone?: string;
      date_format?: string;
      enable_public_access?: boolean;
    };
    notifications?: {
      enable_email?: boolean;
      enable_slack?: boolean;
      enable_discord?: boolean;
      default_notification_channel?: string;
      notification_frequency?: "immediate" | "hourly" | "daily" | "weekly";
      digest_time?: string; // HH:MM形式
      digest_day?: number; // 週次ダイジェストの曜日 (0-6, 0=日曜)
    };
    ai?: {
      default_summarization_model_id?: number;
      default_tagging_model_id?: number;
      default_extraction_model_id?: number;
      enable_auto_tagging?: boolean;
      enable_auto_summarization?: boolean;
      max_tokens_per_request?: number;
      content_safety_filter?: "none" | "low" | "medium" | "high";
    };
    sources?: {
      default_check_interval?: number; // 分単位
      max_content_age?: number; // 日単位
      auto_deactivate_failing_sources?: boolean;
      max_failures_before_deactivation?: number;
      content_fetch_timeout?: number; // 秒単位
    };
    security?: {
      session_timeout?: number; // 分単位
      max_login_attempts?: number;
      require_2fa_for_admins?: boolean;
      password_policy?: {
        min_length?: number;
        require_uppercase?: boolean;
        require_lowercase?: boolean;
        require_numbers?: boolean;
        require_special_chars?: boolean;
      };
      api_rate_limits?: {
        enabled?: boolean;
        requests_per_minute?: number;
        requests_per_hour?: number;
      };
    };
  };
}
```

**例 (リクエストJSON - 複数カテゴリの更新)**
```jsonc
{
  "settings": {
    "general": {
      "site_name": "DigeClip Pro",
      "site_description": "エンタープライズ向けAIコンテンツ管理システム"
    },
    "ai": {
      "default_summarization_model_id": 3,
      "max_tokens_per_request": 8000,
      "content_safety_filter": "low"
    },
    "security": {
      "session_timeout": 60,
      "api_rate_limits": {
        "requests_per_minute": 120
      }
    }
  }
}
```

## レスポンス

**Response**: `IAdminUpdateSystemSettingsResponse`
```ts
export interface IAdminUpdateSystemSettingsResponse {
  success: boolean;
  updated_settings: string[]; // 更新された設定カテゴリのリスト
  settings: {
    // 更新後の全設定（GetSystemSettingsResponseと同じ構造）
    // ...
  };
  last_updated: string;
  updated_by: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "success": true,
  "updated_settings": ["general", "ai", "security"],
  "settings": {
    "general": {
      "site_name": "DigeClip Pro",
      "site_description": "エンタープライズ向けAIコンテンツ管理システム",
      "default_language": "ja",
      "timezone": "Asia/Tokyo",
      "date_format": "YYYY-MM-DD",
      "enable_public_access": false
    },
    "notifications": {
      "enable_email": true,
      "enable_slack": true,
      "enable_discord": false,
      "default_notification_channel": "email",
      "notification_frequency": "daily",
      "digest_time": "09:00"
    },
    "ai": {
      "default_summarization_model_id": 3,
      "default_tagging_model_id": 2,
      "default_extraction_model_id": 1,
      "enable_auto_tagging": true,
      "enable_auto_summarization": true,
      "max_tokens_per_request": 8000,
      "content_safety_filter": "low"
    },
    "sources": {
      "default_check_interval": 60,
      "max_content_age": 30,
      "auto_deactivate_failing_sources": true,
      "max_failures_before_deactivation": 5,
      "content_fetch_timeout": 30
    },
    "security": {
      "session_timeout": 60,
      "max_login_attempts": 5,
      "require_2fa_for_admins": true,
      "password_policy": {
        "min_length": 10,
        "require_uppercase": true,
        "require_lowercase": true,
        "require_numbers": true,
        "require_special_chars": true
      },
      "api_rate_limits": {
        "enabled": true,
        "requests_per_minute": 120,
        "requests_per_hour": 1000
      }
    }
  },
  "last_updated": "2025-03-15T16:30:45Z",
  "updated_by": "admin@example.com"
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4011",
    "message": "Invalid settings data",
    "details": {
      "settings.ai.max_tokens_per_request": "Value must be between 100 and 10000",
      "settings.security.session_timeout": "Value must be greater than 0"
    }
  }
}
```

**Error**: e.g. `409 Conflict`
```jsonc
{
  "error": {
    "code": "E4091",
    "message": "Settings update conflict",
    "details": {
      "message": "Settings were updated by another user. Please refresh and try again."
    }
  }
}

## tags/batch.md

# タグ一括操作 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/tags/batch`
- **機能概要**: 複数のタグに対して一括操作を実行
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminBatchTagsRequest`
```ts
export interface IAdminBatchTagsRequest {
  operation: "create" | "update" | "delete";
  tags: {
    id?: number; // 更新・削除時は必須
    name?: string; // 作成時は必須、更新時はオプション
    description?: string;
    color?: string;
    auto_tag?: boolean;
  }[];
}
```

**例 (リクエストJSON - 作成)**
```jsonc
{
  "operation": "create",
  "tags": [
    {
      "name": "クラウド",
      "description": "クラウドコンピューティングに関する記事",
      "color": "#3366CC",
      "auto_tag": true
    },
    {
      "name": "セキュリティ",
      "description": "情報セキュリティに関する記事",
      "color": "#CC3366",
      "auto_tag": false
    }
  ]
}
```

**例 (リクエストJSON - 更新)**
```jsonc
{
  "operation": "update",
  "tags": [
    {
      "id": 3,
      "color": "#33CC66"
    },
    {
      "id": 4,
      "description": "更新された説明文",
      "auto_tag": false
    }
  ]
}
```

**例 (リクエストJSON - 削除)**
```jsonc
{
  "operation": "delete",
  "tags": [
    {
      "id": 5
    },
    {
      "id": 6
    }
  ]
}
```

## レスポンス

**Response**: `IAdminBatchTagsResponse`
```ts
export interface IAdminBatchTagsResponse {
  success: boolean;
  operation: string;
  results: {
    id?: number;
    name?: string;
    status: "success" | "error";
    message?: string;
  }[];
  summary: {
    total: number;
    successful: number;
    failed: number;
  };
}
```

**例 (レスポンスJSON - 作成成功)**
```jsonc
{
  "success": true,
  "operation": "create",
  "results": [
    {
      "id": 7,
      "name": "クラウド",
      "status": "success"
    },
    {
      "id": 8,
      "name": "セキュリティ",
      "status": "success"
    }
  ],
  "summary": {
    "total": 2,
    "successful": 2,
    "failed": 0
  }
}
```

**例 (レスポンスJSON - 部分的成功)**
```jsonc
{
  "success": true,
  "operation": "update",
  "results": [
    {
      "id": 3,
      "status": "success"
    },
    {
      "id": 4,
      "status": "error",
      "message": "Tag not found"
    }
  ],
  "summary": {
    "total": 2,
    "successful": 1,
    "failed": 1
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid batch operation",
    "details": {
      "operation": "Unsupported operation type"
    }
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **入力検証**:
   - `operation` フィールドが有効な値（"create", "update", "delete"）であることを確認してください。
   - `tags` 配列が空でないことを確認してください。
   - 各操作タイプに応じた必須フィールドの存在を確認してください:
     - "create": `name` が必須
     - "update", "delete": `id` が必須
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **バッチサイズ制限**:
   - 一度に処理するタグの数に上限を設けることを検討してください（例：最大100件）。
   - 大量のタグを処理する場合は、パフォーマンスとタイムアウトに注意してください。

4. **トランザクション処理**:
   - バッチ操作全体を単一のトランザクションで処理するか、個別のトランザクションで処理するかを決定してください。
   - 単一トランザクションの場合、一部のエラーで全体が失敗します（一貫性は高い）。
   - 個別トランザクションの場合、一部成功・一部失敗の状態が発生します（部分的な成功を許容）。
   - 推奨: 個別トランザクションで処理し、結果を詳細に報告する方式。

5. **重複チェック**:
   - "create" 操作では、同じ名前のタグが既に存在しないか確認してください。
   - バッチ内での重複（同じ名前のタグを複数作成しようとする）も検出してください。

6. **使用中チェック**:
   - "delete" 操作では、削除対象のタグがコンテンツに関連付けられているかどうかを確認することを検討してください。
   - 使用中のタグを削除する場合の方針を決定してください（エラーを返す、関連付けも削除する、など）。

7. **エラーハンドリング**:
   - 各タグの処理結果を個別に記録し、部分的な失敗を許容する実装を検討してください。
   - 全体の成功/失敗の判断基準を明確にしてください（例：1つでも失敗したら `success: false` とするか、部分的成功も `success: true` とするか）。
   - データベース接続エラーなどの致命的なエラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。

8. **パフォーマンス最適化**:
   - 大量のタグを処理する場合は、バルクインサート/アップデート/デリートを使用してパフォーマンスを向上させることを検討してください。
   - ただし、バルク操作では個別のエラーハンドリングが難しくなる点に注意してください。

9. **監査ログ**:
   - 誰がいつどのタグに対してどのような一括操作を行ったかを記録する監査ログを実装してください。
   - ログには少なくとも、操作者ID、操作日時、操作タイプ、対象タグID/名前、結果を含めてください。

10. **キャッシュ管理**:
    - タグ情報のキャッシュがある場合、バッチ操作後にキャッシュを無効化または更新してください。

11. **非同期処理の検討**:
    - 大量のタグを処理する場合は、バックグラウンドジョブとして非同期処理することを検討してください。
    - その場合、ジョブIDを返し、別のエンドポイントで処理状況を確認できるようにすることが望ましいです。

12. **冪等性の確保**:
    - 同じリクエストが複数回送信された場合でも安全に処理できるよう、冪等性を確保してください。
    - 特に "create" 操作では、一意の制約を活用して重複作成を防止してください。

13. **日付フォーマット**:
    - 作成・更新時の日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で設定してください。
    - タイムゾーンは UTC を使用してください。

## tags/create.md

# タグ作成 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/admin/tags`
- **機能概要**: 新しいタグを作成
- **認証要否**: **要**(admin)

## リクエスト

**Request**: `IAdminCreateTagRequest`
```ts
export interface IAdminCreateTagRequest {
  name: string;
  description?: string;
  color?: string;
  auto_tag?: boolean;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "name": "ブロックチェーン",
  "description": "ブロックチェーン技術に関する記事",
  "color": "#3366FF",
  "auto_tag": true
}
```

## レスポンス

**Response**: `IAdminCreateTagResponse`
```ts
export interface IAdminCreateTagResponse {
  id: number;
  name: string;
  description?: string;
  color?: string;
  auto_tag: boolean;
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 5,
  "name": "ブロックチェーン",
  "description": "ブロックチェーン技術に関する記事",
  "color": "#3366FF",
  "auto_tag": true,
  "created_at": "2025-03-15T10:30:00Z",
  "updated_at": "2025-03-15T10:30:00Z"
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid tag data",
    "details": {
      "name": "Tag name is required"
    }
  }
}
```

**Error**: e.g. `409 Conflict`
```jsonc
{
  "error": {
    "code": "E4091",
    "message": "Tag with this name already exists"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **入力検証**:
   - `name` フィールドは必須であり、空でないことを確認してください。
   - `name` の長さに制限を設けることを検討してください（例：最大50文字）。
   - `color` が指定された場合、有効なカラーコード形式（例：`#RRGGBB`）であることを確認してください。
   - `description` が指定された場合、長さに制限を設けることを検討してください（例：最大200文字）。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **重複チェック**:
   - 同じ `name` を持つタグが既に存在しないか確認してください。
   - 大文字・小文字を区別しない比較を行うことを推奨します（例：`LOWER(name) = LOWER(?)`）。
   - 重複がある場合は `409 Conflict` エラーを返してください。

4. **データベース操作**:
   - タグ情報は `tags` テーブルに挿入します。
   - `created_at` と `updated_at` フィールドには現在のUTC時刻を設定してください。
   - `auto_tag` が指定されていない場合は、デフォルト値（例：`false`）を設定してください。

5. **トランザクション処理**:
   - データベースへの挿入操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に将来的に関連テーブルへの挿入が必要になる場合は、トランザクションが重要です。

6. **日付フォーマット**:
   - すべての日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

7. **エラーハンドリング**:
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

8. **監査ログ**:
   - 誰がいつどのタグを作成したかを記録する監査ログを実装してください。
   - ログには少なくとも、操作者ID、操作日時、作成されたタグIDを含めてください。

9. **キャッシュ管理**:
   - タグリストのキャッシュがある場合、新しいタグ作成後にキャッシュを無効化または更新してください。

10. **セキュリティ考慮事項**:
    - `name` や `description` フィールドにユーザー入力が含まれるため、XSS攻撃を防ぐために適切にエスケープ処理を行ってください。
    - 特に、これらのフィールドがUIに表示される場合は注意が必要です。

11. **自動タグ付け機能**:
    - `auto_tag` が `true` に設定された場合、将来的に自動タグ付けルールの設定が必要になる可能性があります。
    - 現時点では基本的なフラグとして実装し、拡張性を考慮した設計にしてください。

## tags/delete.md

# タグ削除 API

- **HTTPメソッド**: `DELETE`
- **エンドポイント**: `/api/admin/tags/[id]`
- **機能概要**: 特定のタグを削除
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: 削除するタグのID (必須)

## レスポンス

**Response**: `IAdminDeleteTagResponse`
```ts
export interface IAdminDeleteTagResponse {
  message: string;
  id: number;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Tag deleted successfully",
  "id": 5
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Tag not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **タグ存在確認**:
   - 指定された `id` のタグが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **使用中チェック**:
   - 削除対象のタグがコンテンツに関連付けられているかどうかを確認することを検討してください。
   - 使用中のタグを削除する場合の方針を決定してください:
     - 関連付けも一緒に削除する（カスケード削除）
     - 使用中の場合はエラーを返す
     - 使用中でも削除を許可するが、クエリパラメータで明示的な確認を求める（例：`?force=true`）

5. **トランザクション処理**:
   - 削除操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に関連テーブル（例：`content_tags`）からの削除も必要な場合は、トランザクションが重要です。

6. **関連データの処理**:
   - タグに関連するデータ（例：`content_tags` テーブルのエントリ）も適切に処理してください。
   - 外部キー制約がある場合は、それに従って関連データを処理してください。

7. **ソフトデリート検討**:
   - 完全に削除するのではなく、`deleted_at` フラグを設定するソフトデリートの実装を検討してください。
   - これにより、誤削除からの復旧や履歴の保持が容易になります。

8. **監査ログ**:
   - 誰がいつどのタグを削除したかを記録する監査ログを実装してください。
   - ログには少なくとも、操作者ID、操作日時、削除されたタグID、タグ名を含めてください。

9. **キャッシュ管理**:
   - タグ情報のキャッシュがある場合、削除後にキャッシュを無効化してください。
   - 特にタグリストや関連コンテンツのキャッシュが影響を受ける可能性があります。

10. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

11. **自動タグ付け機能への影響**:
    - 削除するタグが自動タグ付け機能で使用されている場合、その影響を考慮してください。
    - 必要に応じて、自動タグ付けルールの更新や関連設定の調整を行ってください。

## tags/detail.md

# タグ詳細取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/tags/[id]`
- **機能概要**: 特定のタグの詳細情報を取得
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: タグのID (必須)

## レスポンス

**Response**: `IAdminGetTagDetailResponse`
```ts
export interface IAdminGetTagDetailResponse {
  id: number;
  name: string;
  description?: string;
  color?: string;
  usage_count: number;
  auto_tag: boolean;
  created_at: string;
  updated_at: string;
  recent_contents?: {
    id: number;
    title: string;
    created_at: string;
  }[];
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 1,
  "name": "AI",
  "description": "人工知能に関する記事",
  "color": "#FF5733",
  "usage_count": 42,
  "auto_tag": true,
  "created_at": "2025-01-10T08:15:30Z",
  "updated_at": "2025-03-12T14:22:10Z",
  "recent_contents": [
    {
      "id": 123,
      "title": "AIの最新動向 2025年版",
      "created_at": "2025-03-10T14:45:00Z"
    },
    {
      "id": 120,
      "title": "機械学習フレームワークの比較",
      "created_at": "2025-03-08T09:30:15Z"
    }
  ]
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Tag not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **タグ存在確認**:
   - 指定された `id` のタグが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **データベースアクセス**:
   - タグの基本情報は `tags` テーブルから取得します。
   - `usage_count` は関連テーブル（例：`content_tags`）からの集計が必要です。
   - `recent_contents` は `contents` テーブルと `content_tags` テーブルを結合して取得します。
   - 最近のコンテンツは作成日時の降順で取得し、数を制限してください（例：最新5件）。

5. **パフォーマンス最適化**:
   - 複数のテーブル結合が必要になるため、クエリのパフォーマンスに注意してください。
   - 特に `content_tags` テーブルには、`tag_id` と `content_id` の複合インデックスを作成することを推奨します。
   - `recent_contents` の取得は別クエリとして実行し、メインのタグ情報取得と分離することも検討してください。

6. **日付フォーマット**:
   - すべての日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

7. **エラーハンドリング**:
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

8. **キャッシュ戦略**:
   - タグ詳細情報は頻繁に変更されない可能性があるため、適切なキャッシュ戦略を実装することでパフォーマンスを向上させることができます。
   - キャッシュの有効期限（TTL）を設定し、タグが更新された際にキャッシュを無効化する仕組みを検討してください。
   - ただし、`usage_count` や `recent_contents` は変動する可能性が高いため、キャッシュ戦略を慎重に設計してください。

9. **NULL値の処理**:
   - `description` や `color` などのオプションフィールドが NULL の場合、JSON レスポンスでは `null` として返すか、フィールド自体を省略するかを一貫して実装してください。
   - TypeScript インターフェースでは、これらのフィールドをオプショナル（`?`）として定義しています。

10. **セキュリティ考慮事項**:
    - `description` フィールドにユーザー入力が含まれる場合、XSS攻撃を防ぐために適切にエスケープ処理を行ってください。
    - `color` フィールドが有効なカラーコード形式（例：`#RRGGBB`）であることを確認してください。

## tags/list.md

# タグ一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/admin/tags`
- **機能概要**: システムで利用可能なタグの一覧を取得
- **認証要否**: **要**(admin)

## リクエスト

**Query Parameters**:
- `page`: ページ番号 (デフォルト: 1)
- `per_page`: 1ページあたりの件数 (デフォルト: 20, 最大: 100)
- `sort_by`: ソート項目 (`name`, `created_at`, `usage_count`) (デフォルト: `name`)
- `sort_order`: ソート順 (`asc`, `desc`) (デフォルト: `asc`)
- `search`: 検索キーワード (タグ名で部分一致検索)

## レスポンス

**Response**: `IAdminGetTagsResponse`
```ts
export interface IAdminGetTagsResponse {
  tags: IAdminTag[];
  pagination: {
    total: number;
    page: number;
    per_page: number;
    total_pages: number;
  };
}

export interface IAdminTag {
  id: number;
  name: string;
  description?: string;
  color?: string;
  usage_count: number;
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "tags": [
    {
      "id": 1,
      "name": "AI",
      "description": "人工知能に関する記事",
      "color": "#FF5733",
      "usage_count": 42,
      "created_at": "2025-01-15T12:00:00Z",
      "updated_at": "2025-02-20T15:30:45Z"
    },
    {
      "id": 2,
      "name": "テクノロジー",
      "description": "最新技術動向",
      "color": "#33A1FF",
      "usage_count": 28,
      "created_at": "2025-01-20T09:15:30Z",
      "updated_at": "2025-01-20T09:15:30Z"
    }
  ],
  "pagination": {
    "total": 15,
    "page": 1,
    "per_page": 20,
    "total_pages": 1
  }
}
```

## エラー

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid pagination parameters"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **クエリパラメータの検証**:
   - `page` と `per_page` は正の整数であることを確認してください。
   - `per_page` は最大値（100）を超えないようにしてください。
   - `sort_by` は許可された値（`name`, `created_at`, `usage_count`）のいずれかであることを確認してください。
   - `sort_order` は許可された値（`asc`, `desc`）のいずれかであることを確認してください。
   - パラメータが無効な場合は適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **データベースアクセス**:
   - タグ情報はデータベースの `tags` テーブルから取得します。
   - `usage_count` は関連テーブル（例：`content_tags`）からの集計が必要です。
   - パフォーマンスを考慮し、必要に応じてインデックスを作成してください。
   - 特に `name` 列と `created_at` 列にはインデックスを設定することを推奨します。

4. **ページネーション実装**:
   - オフセットベースのページネーションを実装してください（例：`OFFSET (page - 1) * per_page LIMIT per_page`）。
   - 大量のデータがある場合は、カーソルベースのページネーションを検討してください。
   - 総件数（`total`）の取得は別クエリで行い、パフォーマンスに注意してください。

5. **検索機能**:
   - `search` パラメータが指定された場合、タグ名の部分一致検索を実装してください。
   - 大文字・小文字を区別しない検索を実装してください（例：`LOWER(name) LIKE LOWER('%search%')`）。
   - 検索クエリのパフォーマンスに注意し、必要に応じて全文検索インデックスの使用を検討してください。

6. **ソート機能**:
   - `sort_by` と `sort_order` パラメータに基づいて適切なソートを実装してください。
   - SQL インジェクションを防ぐため、ソート項目は許可リストで検証してください。
   - `usage_count` でのソートは集計が必要なため、パフォーマンスに注意してください。

7. **日付フォーマット**:
   - すべての日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

8. **エラーハンドリング**:
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

9. **キャッシュ戦略**:
   - タグリストは頻繁に変更されない可能性があるため、適切なキャッシュ戦略を実装することでパフォーマンスを向上させることができます。
   - キャッシュの有効期限（TTL）を設定し、タグが更新された際にキャッシュを無効化する仕組みを検討してください。

10. **パフォーマンス考慮事項**:
    - 大量のタグがある場合は、ページネーションの実装が特に重要です。
    - `usage_count` の計算は重い操作になる可能性があるため、定期的に更新される別のカラムに保存することを検討してください。
    - レスポンスサイズが大きくなる場合は、圧縮を検討してください。


## tags/update.md

# タグ更新 API

- **HTTPメソッド**: `PUT`
- **エンドポイント**: `/api/admin/tags/[id]`
- **機能概要**: 既存のタグを更新
- **認証要否**: **要**(admin)

## リクエスト

**Path Parameter**:
- `id`: 更新するタグのID (必須)

**Request**: `IAdminUpdateTagRequest`
```ts
export interface IAdminUpdateTagRequest {
  name?: string;
  description?: string;
  color?: string;
  auto_tag?: boolean;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "name": "ブロックチェーン技術",
  "description": "ブロックチェーンとWeb3技術に関する記事",
  "color": "#4B0082",
  "auto_tag": false
}
```

## レスポンス

**Response**: `IAdminUpdateTagResponse`
```ts
export interface IAdminUpdateTagResponse {
  id: number;
  name: string;
  description?: string;
  color?: string;
  auto_tag: boolean;
  created_at: string;
  updated_at: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 5,
  "name": "ブロックチェーン技術",
  "description": "ブロックチェーンとWeb3技術に関する記事",
  "color": "#4B0082",
  "auto_tag": false,
  "created_at": "2025-03-15T10:30:00Z",
  "updated_at": "2025-03-15T14:22:35Z"
}
```

## エラー

**Error**: e.g. `404 Not Found`
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Tag not found"
  }
}
```

**Error**: e.g. `400 Bad Request`
```jsonc
{
  "error": {
    "code": "E4001",
    "message": "Invalid tag data",
    "details": {
      "color": "Invalid color format"
    }
  }
}
```

**Error**: e.g. `409 Conflict`
```jsonc
{
  "error": {
    "code": "E4091",
    "message": "Tag with this name already exists"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - 管理者権限を持つユーザーのみアクセス可能なエンドポイントです。
   - リクエスト処理前に必ず認証トークンを検証し、管理者権限を確認してください。

2. **パスパラメータの検証**:
   - `id` パラメータは数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **タグ存在確認**:
   - 指定された `id` のタグが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。

4. **入力検証**:
   - `name` が指定された場合、空でないことを確認してください。
   - `name` の長さに制限を設けることを検討してください（例：最大50文字）。
   - `color` が指定された場合、有効なカラーコード形式（例：`#RRGGBB`）であることを確認してください。
   - `description` が指定された場合、長さに制限を設けることを検討してください（例：最大200文字）。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

5. **重複チェック**:
   - `name` を変更する場合、同じ名前を持つ別のタグが既に存在しないか確認してください。
   - 大文字・小文字を区別しない比較を行うことを推奨します（例：`LOWER(name) = LOWER(?) AND id != ?`）。
   - 重複がある場合は `409 Conflict` エラーを返してください。

6. **部分更新の処理**:
   - このAPIは部分更新（PATCH的な動作）を行います。リクエストに含まれるフィールドのみを更新してください。
   - リクエストに含まれていないフィールドは現在の値を維持してください。
   - 特に `null` 値が明示的に指定された場合の処理方針（フィールドをクリアするか無視するか）を決定し、一貫して実装してください。

7. **データベース操作**:
   - タグ情報は `tags` テーブルで更新します。
   - `updated_at` フィールドには現在のUTC時刻を設定してください。
   - `created_at` フィールドは変更しないでください。

8. **トランザクション処理**:
   - データベースの更新操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に将来的に関連テーブルの更新が必要になる場合は、トランザクションが重要です。

9. **楽観的ロック**:
   - 同時更新の競合を防ぐため、楽観的ロック（バージョン番号や更新タイムスタンプによる）の実装を検討してください。
   - 競合が検出された場合は `409 Conflict` エラーを返してください。

10. **日付フォーマット**:
    - すべての日時フィールド（created_at, updated_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
    - タイムゾーンは UTC を使用してください。

11. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報（DB接続文字列など）を含めないよう注意してください。

12. **監査ログ**:
    - 誰がいつどのタグをどのように更新したかを記録する監査ログを実装してください。
    - ログには少なくとも、操作者ID、操作日時、対象タグID、変更されたフィールドを含めてください。

13. **キャッシュ管理**:
    - タグ情報のキャッシュがある場合、更新後にキャッシュを無効化または更新してください。
    - 特にタグ名が変更された場合は、関連するキャッシュも更新する必要があります。

14. **関連コンテンツへの影響**:
    - タグ名を変更した場合、そのタグが付けられたコンテンツの表示にも影響する可能性があります。
    - 必要に応じて、関連するコンテンツのキャッシュも更新してください。

15. **自動タグ付け機能の変更**:
    - `auto_tag` の値を変更する場合、既存のコンテンツに対する再処理が必要かどうかを検討してください。
    - 特に `true` から `false` に変更する場合、既存の自動タグ付けを維持するか削除するかの方針を決定してください。

## auth/README.md

# 認証系 API ( `/api/auth/...` )

認証関連のエンドポイントを提供します。ユーザー登録、ログイン、ログアウト、パスワード管理などの機能を含みます。

## API一覧

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/auth/register](./register.md) | POST | ユーザー登録 | 不要(guest) |
| [/api/auth/login](./login.md) | POST | メール&パスワードログイン | 不要(guest) |
| [/api/auth/google-callback](./google-callback.md) | GET | Google OAuth ログイン | 不要(guest) |
| [/api/auth/logout](./logout.md) | POST | ログアウト | 要(user/admin) |
| [/api/auth/reset-password](./reset-password.md) | POST | パスワードリセットリクエスト | 不要(guest) |
| [/api/auth/change-password](./change-password.md) | POST | パスワード変更 | 要(user/admin) |

## auth/change-password.md

# パスワード変更 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/auth/change-password`
- **機能概要**: ログイン中ユーザーがパスワードを変更
- **認証要否**: **要**(user/admin)

## リクエスト

**Request**: `IAuthChangePasswordRequest`
```ts
export interface IAuthChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "currentPassword": "MySecret123",
  "newPassword": "NewSecret456"
}
```

## レスポンス

**Response**: `IAuthChangePasswordResponse`
```ts
export interface IAuthChangePasswordResponse {
  message: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Password changed successfully"
}
```

## エラー

**Error**: e.g. `401 Unauthorized` (currentPassword が違う)
```jsonc
{
  "error": {
    "code": "E4014",
    "message": "Current password is incorrect"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。
   - 認証されたユーザーのIDを取得し、そのユーザーのパスワードのみを変更できるようにしてください。

2. **入力検証**:
   - `currentPassword` と `newPassword` フィールドが空でないことを確認してください。
   - `newPassword` がパスワード強度の要件を満たしていることを確認してください（例：最小8文字、大文字・小文字・数字を含むなど）。
   - `currentPassword` と `newPassword` が同じでないことを確認してください（変更の意味がない）。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **現在のパスワード検証**:
   - データベースから取得したユーザーの現在のパスワードハッシュと、入力された `currentPassword` を安全に比較してください。
   - パスワードハッシュの比較には、タイミング攻撃を防ぐため、定数時間比較を使用してください。
   - 現在のパスワードが一致しない場合は、`401 Unauthorized` エラーを返してください。

4. **パスワード履歴チェック（オプション）**:
   - セキュリティポリシーに応じて、過去に使用したパスワードの再利用を禁止することを検討してください。
   - パスワード履歴を保存している場合、新しいパスワードが過去のパスワードと一致しないことを確認してください。
   - 履歴と一致する場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

5. **パスワードハッシュ化**:
   - 新しいパスワードは平文で保存せず、必ず強力なハッシュアルゴリズム（bcrypt, Argon2など）を使用してハッシュ化してください。
   - 適切なソルトを使用し、十分な計算コスト（ワークファクター）を設定してください。
   - ハッシュ化されたパスワードとソルトをデータベースに保存してください。

6. **データベース更新**:
   - ユーザーのパスワードハッシュを新しい値で更新してください。
   - `updated_at` フィールドを現在のUTC時刻に更新してください。
   - 更新操作はトランザクション内で実行し、エラー時にはロールバックしてください。

7. **セッション管理（オプション）**:
   - セキュリティポリシーに応じて、パスワード変更後に以下のいずれかの処理を検討してください:
     - 現在のセッションを維持（デフォルト）
     - 現在のセッションを除くすべてのセッションを無効化
     - すべてのセッションを無効化し、再ログインを要求
   - セッションを無効化する場合、関連するトークンをブラックリストに追加するか、データベースから削除してください。

8. **ログ記録**:
   - パスワード変更イベントを記録してください。
   - ログには少なくとも、タイムスタンプ、ユーザーID、IPアドレス、ユーザーエージェントを含めてください。
   - 個人情報保護のため、ログにパスワード（現在のものも新しいものも）を記録しないでください。

9. **通知**:
   - パスワードが正常に変更された後、確認メールをユーザーに送信することを検討してください。
   - これにより、ユーザーは不正なパスワード変更に気付くことができます。

10. **レート制限**:
    - 短時間に多数のパスワード変更リクエストを送信する攻撃を防ぐため、レート制限の実装を検討してください。
    - 制限に達した場合は、`429 Too Many Requests` エラーを返してください。

11. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

12. **セキュリティヘッダー**:
    - レスポンスに適切なセキュリティヘッダーを含めてください:
      - `Cache-Control: no-store`
      - `Pragma: no-cache`
      - `X-Content-Type-Options: nosniff`

## auth/google-callback.md

# Google OAuth ログイン API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/auth/google-callback`
- **機能概要**: Google OAuth 2.0 コールバックを受け取り、成功ならJWT発行
- **認証要否**: **不要**(guest)

## リクエスト

**Request**:
- クエリに `code` 等含む (Google OAuth からリダイレクトパラメータ)

```ts
export interface IAuthGoogleCallbackQuery {
  code: string;     // Google OAuth code
  state?: string;   // CSRF対策など
}
```

**例 (GoogleからのリダイレクトURL)**
```
GET /api/auth/google-callback?code=4/0AX4XfW...
```

## レスポンス

**Response**: `IAuthGoogleCallbackResponse`
```ts
export interface IAuthGoogleCallbackResponse {
  userId: number;
  role: "user" | "admin";
  token: string;       // JWT
  expiresIn: number;   // 有効期限 (秒)
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "userId": 567,
  "role": "user",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI...",
  "expiresIn": 3600
}
```

## エラー

**Error**: e.g. `401 Unauthorized` (Google認証失敗)
```jsonc
{
  "error": {
    "code": "E4012",
    "message": "Google OAuth failed or was canceled"
  }
}
```

## 実装上の注意事項

1. **OAuth設定**:
   - Google Cloud Consoleで適切なOAuthクライアントIDとシークレットを設定してください。
   - 承認済みのリダイレクトURIに、このコールバックエンドポイントのURLを登録してください。
   - 必要なスコープ（最低限 `email` と `profile`）を設定してください。

2. **クエリパラメータの検証**:
   - `code` パラメータが存在し、空でないことを確認してください。
   - `state` パラメータが使用されている場合、セッションに保存された値と一致することを確認してください（CSRF対策）。
   - パラメータが無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **認証コードの交換**:
   - 受け取った `code` を使用して、Google OAuth APIにアクセストークンをリクエストしてください。
   - このリクエストには、クライアントID、クライアントシークレット、リダイレクトURI、認証コードを含めてください。
   - アクセストークンの取得に失敗した場合は、`401 Unauthorized` エラーを返してください。

4. **ユーザー情報の取得**:
   - 取得したアクセストークンを使用して、Google APIからユーザー情報（メールアドレス、名前など）を取得してください。
   - ユーザー情報の取得に失敗した場合は、`401 Unauthorized` エラーを返してください。

5. **ユーザーアカウントの処理**:
   - 取得したメールアドレスに対応するユーザーがデータベースに存在するか確認してください。
   - 存在する場合は、そのユーザーアカウントを使用してログイン処理を行ってください。
   - 存在しない場合は、新しいユーザーアカウントを作成してください（自動登録）。
   - 新規ユーザー作成時は、Google APIから取得した情報（名前、プロフィール画像URLなど）を使用してプロフィールを初期化してください。

6. **JWTの生成**:
   - セキュアな秘密鍵を使用してJWTを生成してください。
   - JWTには少なくとも以下の情報を含めてください:
     - ユーザーID
     - ユーザーロール
     - 発行時刻（iat）
     - 有効期限（exp）
     - 認証方法（例：`auth_provider: "google"`）
   - 有効期限は適切に設定してください（例：1時間）。

7. **セッション管理（オプション）**:
   - リフレッシュトークンを使用する場合、Googleから取得したリフレッシュトークンを安全に保存してください。
   - これにより、ユーザーが再度ログインしなくても、アクセストークンを更新できます。

8. **エラーハンドリング**:
   - Google APIとの通信エラーを適切に処理してください。
   - ネットワークエラー、タイムアウト、APIレート制限などの一時的な問題に対しては、リトライロジックの実装を検討してください。
   - 永続的なエラー（無効なクライアントIDなど）は、詳細なエラーログを記録し、適切なエラーメッセージを返してください。

9. **リダイレクト処理**:
   - このAPIは通常、フロントエンドアプリケーションへのリダイレクトを伴います。
   - 認証成功時は、JWTを含むURLにリダイレクトしてください（例：`https://example.com/auth/callback?token=...`）。
   - 認証失敗時は、エラー情報を含むURLにリダイレクトしてください（例：`https://example.com/auth/callback?error=...`）。
   - セキュリティ上の理由から、JWTをURLパラメータとして渡す代わりに、一時的なコードを発行し、そのコードをフロントエンドが別のAPIエンドポイントで交換する方式も検討してください。

10. **ログ記録**:
    - 認証イベントを記録してください。
    - ログには少なくとも、タイムスタンプ、IPアドレス、ユーザーエージェント、認証結果（成功/失敗）、ユーザーID（成功時）を含めてください。
    - 個人情報保護のため、ログにトークンやユーザーの詳細情報を記録しないでください。

11. **セキュリティ考慮事項**:
    - `state` パラメータを使用してCSRF攻撃を防止してください。
    - OAuth認証フローを開始する前に、ランダムな値を生成し、セッションに保存してください。
    - コールバック時に、クエリパラメータの `state` とセッションの値を比較してください。

12. **エラーレスポンス**:
    - ユーザーフレンドリーなエラーメッセージを返してください。
    - 技術的な詳細はログに記録し、ユーザーには一般的なメッセージを表示してください。
    - 特に、Google APIからのエラーレスポンスをそのまま転送しないでください。

## auth/login.md

# メール&パスワード ログイン API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/auth/login`
- **機能概要**: ログインし、JWT発行
- **認証要否**: **不要**(guest)

## リクエスト

**Request**: `IAuthLoginRequest`
```ts
export interface IAuthLoginRequest {
  email: string;
  password: string;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "email": "john@example.com",
  "password": "MySecret123"
}
```

## レスポンス

**Response**: `IAuthLoginResponse`
```ts
export interface IAuthLoginResponse {
  userId: number;
  role: "user" | "admin";
  token: string;       // JWT
  expiresIn: number;   // 有効期限 (秒)
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "userId": 123,
  "role": "user",
  "token": "eyJhbGciOiJIUz...",
  "expiresIn": 3600
}
```

## エラー

**Error**: e.g. `401 Unauthorized` (認証失敗)
```jsonc
{
  "error": {
    "code": "E4011",
    "message": "Invalid email or password"
  }
}
```

## 実装上の注意事項

1. **入力検証**:
   - `email` フィールドが有効なメールアドレス形式であることを確認してください。
   - `password` フィールドが空でないことを確認してください。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

2. **認証処理**:
   - メールアドレスに対応するユーザーが存在するか確認してください。
   - パスワードハッシュを安全に比較してください（タイミング攻撃を防ぐため、定数時間比較を使用）。
   - 認証に失敗した場合は、具体的な理由（メールが存在しない、パスワードが間違っているなど）を明かさず、一般的なエラーメッセージを返してください。

3. **アカウント状態の確認**:
   - ユーザーアカウントが有効な状態（未削除、未停止）であることを確認してください。
   - メール確認が必要なシステムの場合、メール確認済みかどうかを確認してください。
   - アカウントが無効な場合は、適切なエラーコードとメッセージを返してください。

4. **JWTの生成**:
   - セキュアな秘密鍵を使用してJWTを生成してください。
   - JWTには少なくとも以下の情報を含めてください:
     - ユーザーID
     - ユーザーロール
     - 発行時刻（iat）
     - 有効期限（exp）
   - 有効期限は適切に設定してください（例：1時間）。

5. **ログイン試行の制限**:
   - ブルートフォース攻撃を防ぐため、同一IPアドレスまたは同一メールアドレスからの連続失敗ログイン試行を制限してください。
   - 制限に達した場合は、一時的なロックアウトを実装し、`429 Too Many Requests` エラーを返してください。

6. **ログ記録**:
   - 成功したログインと失敗したログイン試行を記録してください。
   - ログには少なくとも、タイムスタンプ、IPアドレス、ユーザーエージェント、成功/失敗の結果を含めてください。
   - 個人情報保護のため、ログにパスワードを記録しないでください。

7. **セキュリティヘッダー**:
   - レスポンスに適切なセキュリティヘッダーを含めてください:
     - `Cache-Control: no-store`
     - `Pragma: no-cache`
     - `X-Content-Type-Options: nosniff`

8. **リフレッシュトークン（オプション）**:
   - 長期間のセッション維持が必要な場合は、JWTと共にリフレッシュトークンを発行することを検討してください。
   - リフレッシュトークンはデータベースに保存し、使用時に検証してください。

9. **多要素認証（オプション）**:
   - 多要素認証が有効なユーザーの場合、追加の認証ステップを要求するレスポンスを返してください。
   - この場合、完全なJWTではなく、一時的なトークンを発行し、多要素認証完了後に正式なJWTを発行してください。

10. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

## auth/logout.md

# ログアウト API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/auth/logout`
- **機能概要**: セッション無効化/JWTブラックリスト化 or Cookie削除
- **認証要否**: **要**(user/admin)

## リクエスト

**Request**: `IAuthLogoutRequest`
```ts
export interface IAuthLogoutRequest {
  // 特になし(リクエストボディ不要でも可)
}
```
**例 (リクエストJSON)**
```jsonc
{}
```

## レスポンス

**Response**: `IAuthLogoutResponse`
```ts
export interface IAuthLogoutResponse {
  message: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Logged out successfully"
}
```

## エラー

**Error**: e.g. `401 Unauthorized` (トークン無効)
```jsonc
{
  "error": {
    "code": "E4013",
    "message": "Invalid or expired token"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。

2. **トークン無効化**:
   - JWT認証を使用している場合、以下のいずれかの方法でトークンを無効化してください:
     - トークンをブラックリストに追加（Redis等のキャッシュを使用）
     - トークンの有効期限を現在時刻に更新（データベースにトークン情報を保存している場合）
   - ブラックリストに追加する場合、元のトークンの有効期限までブラックリスト情報を保持してください。

3. **セッション管理**:
   - セッションベースの認証を使用している場合、ユーザーのセッションを無効化してください。
   - セッションストアからセッション情報を削除してください。
   - セッションCookieが使用されている場合、Cookieを削除するようにレスポンスヘッダーを設定してください。

4. **リフレッシュトークン処理**:
   - リフレッシュトークンを使用している場合、関連するリフレッシュトークンも無効化してください。
   - データベースからリフレッシュトークンを削除するか、無効フラグを設定してください。

5. **複数デバイス対応**:
   - 複数デバイスでのログインをサポートしている場合、以下のいずれかの方法を検討してください:
     - 現在のデバイスのみからログアウト（デフォルト）
     - すべてのデバイスからログアウト（オプションパラメータで指定）
   - すべてのデバイスからログアウトする場合、ユーザーに関連するすべてのトークンを無効化してください。

6. **ログ記録**:
   - ログアウトイベントを記録してください。
   - ログには少なくとも、タイムスタンプ、ユーザーID、IPアドレス、ユーザーエージェントを含めてください。

7. **レスポンスヘッダー**:
   - レスポンスに適切なセキュリティヘッダーを含めてください:
     - `Cache-Control: no-store`
     - `Pragma: no-cache`
   - Cookie認証を使用している場合、認証Cookieを削除するための `Set-Cookie` ヘッダーを設定してください。

8. **クライアント側の処理**:
   - クライアント側でもローカルストレージやセッションストレージからトークンを削除するよう指示してください。
   - これはAPIの実装ではなくクライアント側の責任ですが、ドキュメントに記載しておくと良いでしょう。

9. **エラーハンドリング**:
   - トークンブラックリストへの追加やセッション削除に失敗した場合でも、クライアントにはエラーを返さず、成功レスポンスを返すことを検討してください。
   - 内部エラーはログに記録し、必要に応じて監視システムに通知してください。

10. **レート制限**:
    - 短時間に多数のログアウトリクエストを送信する攻撃を防ぐため、レート制限の実装を検討してください。
    - 制限に達した場合は、`429 Too Many Requests` エラーを返してください。

## auth/register.md

# ユーザー登録 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/auth/register`
- **機能概要**: 新規ユーザーを登録し、JWT発行(自動ログイン)する
- **認証要否**: **不要**(guest)

## リクエスト

**Request**: `IAuthRegisterRequest`
```ts
export interface IAuthRegisterRequest {
  email: string;
  password: string;
  name?: string; // 任意ユーザー名
}
```

**例 (リクエストJSON)**
```jsonc
{
  "email": "john@example.com",
  "password": "MySecret123",
  "name": "John Smith"
}
```

## レスポンス

**Response**: `IAuthRegisterResponse`
```ts
export interface IAuthRegisterResponse {
  userId: number;
  role: "user" | "admin";
  token: string;           // JWT
  expiresIn: number;       // 有効期限 (秒)
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "userId": 123,
  "role": "user",
  "token": "eyJhbGciOiJIUz...",
  "expiresIn": 3600
}
```

## エラー

**Error**: e.g. `409 Conflict` (既にメールが登録済み)
```jsonc
{
  "error": {
    "code": "E4091",
    "message": "Email already in use"
  }
}
```

## 実装上の注意事項

1. **入力検証**:
   - `email` フィールドが有効なメールアドレス形式であることを確認してください。
   - `password` フィールドが空でないことと、パスワード強度の要件を満たしていることを確認してください（例：最小8文字、大文字・小文字・数字を含むなど）。
   - `name` フィールドが指定された場合、長さ制限（例：最大50文字）や禁止文字（例：制御文字）をチェックしてください。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

2. **重複チェック**:
   - 同じ `email` を持つユーザーが既に存在しないか確認してください。
   - 大文字・小文字を区別しない比較を行うことを推奨します（例：`LOWER(email) = LOWER(?)`）。
   - 重複がある場合は `409 Conflict` エラーを返してください。

3. **パスワードハッシュ化**:
   - パスワードは平文で保存せず、必ず強力なハッシュアルゴリズム（bcrypt, Argon2など）を使用してハッシュ化してください。
   - 適切なソルトを使用し、十分な計算コスト（ワークファクター）を設定してください。
   - ハッシュ化されたパスワードとソルトをデータベースに保存してください。

4. **ユーザーロールの設定**:
   - 新規ユーザーには通常 "user" ロールを割り当ててください。
   - "admin" ロールは特別な方法（例：既存の管理者による招待）でのみ割り当てるようにしてください。

5. **メール確認（オプション）**:
   - メール確認が必要なシステムの場合、ユーザーアカウントを「未確認」状態で作成し、確認メールを送信してください。
   - 確認トークンを生成し、安全に保存してください。
   - 確認メールには、確認用のリンクとトークンを含めてください。

6. **JWTの生成**:
   - セキュアな秘密鍵を使用してJWTを生成してください。
   - JWTには少なくとも以下の情報を含めてください:
     - ユーザーID
     - ユーザーロール
     - 発行時刻（iat）
     - 有効期限（exp）
   - 有効期限は適切に設定してください（例：1時間）。
   - メール確認が必要なシステムの場合、JWT内にメール確認状態を含めることを検討してください。

7. **データベース操作**:
   - ユーザー情報の挿入操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - `created_at` と `updated_at` フィールドには現在のUTC時刻を設定してください。

8. **ログ記録**:
   - 新規ユーザー登録を記録してください。
   - ログには少なくとも、タイムスタンプ、IPアドレス、ユーザーエージェント、登録されたメールアドレス（個人情報保護に注意）を含めてください。
   - 個人情報保護のため、ログにパスワードを記録しないでください。

9. **セキュリティヘッダー**:
   - レスポンスに適切なセキュリティヘッダーを含めてください:
     - `Cache-Control: no-store`
     - `Pragma: no-cache`
     - `X-Content-Type-Options: nosniff`

10. **スパム対策**:
    - 同一IPアドレスからの連続登録試行を制限することを検討してください。
    - 必要に応じて、CAPTCHA や reCAPTCHA などの追加の検証を実装してください。

11. **プロフィール初期化**:
    - ユーザープロフィールの初期設定を行ってください（例：デフォルトのプロフィール画像、表示設定など）。
    - 必要に応じて、ユーザー固有の初期データを作成してください（例：デフォルトのコレクションなど）。

12. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

13. **GDPR対応（該当する場合）**:
    - ユーザーの同意を得て、プライバシーポリシーへの同意記録を保存してください。
    - データ処理の目的と保持期間を明確にしてください。

## auth/reset-password.md

# パスワードリセットリクエスト API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/auth/reset-password`
- **機能概要**: ユーザーが「パスワードを忘れた」際、メールでリセットリンクを送るなど
- **認証要否**: **不要**(guest)

## リクエスト

**Request**: `IAuthResetPasswordRequest`
```ts
export interface IAuthResetPasswordRequest {
  email: string;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "email": "john@example.com"
}
```

## レスポンス

**Response**: `IAuthResetPasswordResponse`
```ts
export interface IAuthResetPasswordResponse {
  message: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Password reset link sent to john@example.com"
}
```

## エラー

**Error**: e.g. `404 Not Found` (メール未登録)
```jsonc
{
  "error": {
    "code": "E4041",
    "message": "Email not found in system"
  }
}
```

## 実装上の注意事項

1. **入力検証**:
   - `email` フィールドが有効なメールアドレス形式であることを確認してください。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

2. **ユーザー存在確認**:
   - 指定されたメールアドレスに対応するユーザーが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。
   - ただし、セキュリティ上の理由から、メールアドレスが存在しない場合でも成功レスポンスを返すことを検討してください（情報漏洩防止のため）。

3. **リセットトークンの生成**:
   - 安全でランダムな一意のリセットトークンを生成してください（例：UUID v4 + ランダム文字列）。
   - トークンの有効期限を設定してください（例：24時間）。
   - トークンとその有効期限をデータベースに保存してください（ユーザーレコードに関連付けて）。
   - 既存のリセットトークンがある場合は、新しいトークンで上書きしてください。

4. **リセットリンクの作成**:
   - リセットトークンを含むパスワードリセットページへのリンクを作成してください。
   - リンク例: `https://example.com/reset-password?token=abc123def456`
   - リンクにはトークンだけでなく、ユーザーIDやメールアドレスのハッシュなど、追加の検証情報を含めることを検討してください。

5. **メール送信**:
   - リセットリンクを含むメールをユーザーに送信してください。
   - メールには以下の情報を含めてください:
     - パスワードリセットリンク
     - リンクの有効期限
     - リセットをリクエストしていない場合の連絡先
   - メール送信エラーを適切に処理し、ログに記録してください。
   - HTMLとプレーンテキストの両方の形式でメールを送信することを検討してください。

6. **レート制限**:
   - 同一メールアドレスまたは同一IPアドレスからの連続リセットリクエストを制限してください。
   - 制限に達した場合は、一時的な待機時間を設けるか、`429 Too Many Requests` エラーを返してください。
   - これにより、パスワードリセット機能を悪用した攻撃（メールボム等）を防止できます。

7. **ログ記録**:
   - パスワードリセットリクエストを記録してください。
   - ログには少なくとも、タイムスタンプ、IPアドレス、リクエストされたメールアドレス（個人情報保護に注意）を含めてください。
   - 成功したメール送信と失敗したメール送信を区別して記録してください。

8. **セキュリティ考慮事項**:
   - リセットトークンは十分な長さと複雑さを持つようにしてください（最低64ビットのエントロピー）。
   - トークンの有効期限は短く設定してください（24時間以内が推奨）。
   - 一度使用されたトークンは即座に無効化してください。
   - 複数回失敗したトークン検証の試行を検出し、必要に応じてトークンを無効化してください。

9. **エラーハンドリング**:
   - メール送信サービスの障害など、内部エラーが発生した場合は `500 Internal Server Error` を返し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

10. **フロントエンド連携**:
    - フロントエンドアプリケーションと連携して、リセットリンクがクリックされた際の処理を実装してください。
    - リセットリンクは新しいパスワード入力フォームに誘導し、トークンを検証するための別のAPIエンドポイント（例：`/api/auth/verify-reset-token`）を呼び出すようにしてください。

11. **新しいパスワード設定API**:
    - パスワードリセットプロセスを完了するための別のAPIエンドポイント（例：`/api/auth/set-new-password`）を実装してください。
    - このAPIでは、リセットトークンと新しいパスワードを受け取り、検証後にパスワードを更新します。

12. **通知**:
    - パスワードが正常に変更された後、確認メールをユーザーに送信することを検討してください。
    - これにより、ユーザーは不正なパスワード変更に気付くことができます。

## common/README.md

# API 共通仕様

## 1. ディレクトリ構成 (Next.js 例)

```
/api
  ├─ /auth
  │    ├─ google-callback.ts
  │    ├─ login.ts
  │    ├─ logout.ts
  │    ├─ register.ts
  │    ├─ reset-password.ts
  │    └─ change-password.ts
  ├─ /user
  │    ├─ contents
  │    ├─ tags
  │    ├─ system
  │    └─ ...
  └─ /admin
       ├─ sources
       ├─ contents
       ├─ ai-models
       ├─ notifications
       ├─ tags
       ├─ system
       └─ ...
```

1. **`/api/auth`** : 認証関連 (JWT/Google OAuth 用のエンドポイント)
2. **`/api/user`** : 一般ユーザーが利用する機能
3. **`/api/admin`** : 管理者のみが操作する機能

## 2. 認証・認可 概要

- **JWT** : メール & パスワードで登録/login するユーザー向け
  - ログイン成功時に JWT を発行し、Cookie もしくは `Authorization: Bearer <token>` で利用
  - ログインフロー:
    1. **Googleログイン** or **email+pwログイン**
    2. APIが認証成功 → JWT発行 → Cookie/LocalStorage 保存
    3. 以後 `/api/user/...` など呼び出し時、JWTを付与 → ミドルウェア検証 → `role=user` ならOK
    4. `/api/admin/...` は `role=admin` のみ可
- **Googleアカウント OAuth** : ボタン押下 → `/api/auth/google-callback` にコールバック → 成功時にログインセッション確立
  - 同様に JWT を発行し、内部的に userId & googleId を紐づける
- **未ログイン(guest)** : コンテンツの一部閲覧のみ可能(必要なら)

**ログインフロー**:
1. **Googleログイン** or **email+pwログイン**
2. APIが認証成功 → JWT発行 → Cookie/LocalStorage 保存
3. 以後 `/api/user/...` など呼び出し時、JWTを付与 → ミドルウェア検証 → `role=user` ならOK
4. `/api/admin/...` は `role=admin` のみ可

**ログアウト**:
- Cookie削除 or JWT 無効化(サーバ側でブラックリスト管理 or 短い有効期限+リフレッシュトークン管理)

## 3. Request/Response 共通仕様

### 3.1 認証(HTTP Header)

- **Authorization** : `Bearer <JWT>`
  - 例: `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`

### 3.2 エラーレスポンス

- フォーマット
```jsonc
{
  "error": {
    "code": "E400x",          // 一意のエラーコード
    "message": "Description", // ユーザーに伝えるエラーメッセージ
    "details": { }            // 任意の追加情報
  }
}
```
- HTTPステータス: 4xx / 5xx を適切に返す。

### 3.3 ロール判定

- JWTペイロードに `role: "admin"|"user"` を含める
- **Next.js ミドルウェア**で `/api/admin/` にアクセス時は `role==="admin"` か検証

## common/implementation_patterns.md

# API実装パターン集

> **前提**
> - このドキュメントは、DigeClipのバックエンドAPI実装における共通パターンを定義します。
> - 目的は「**同じようなコードを何度も書かなくて済む**」ようにすることです。
> - 「**どんなエンジニアでも間違うことなく実装できる**」ことを重視しつつ、「**実装が複雑すぎず時間がかからない**」方法を採用します。

---

## 1. 基本的なAPIエンドポイント実装パターン

### 1.1 一覧取得 (GET /api/[role]/[resource])

```typescript
// /api/user/contents/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.contentSearch, req.query);

  // サービス呼び出し
  const { items, total } = await contentService.searchContents(query);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: query.page,
      limit: query.limit,
      pages: Math.ceil(total / query.limit)
    }
  });
};

// ミドルウェア適用（認証＋エラーハンドリング）
export default withApiHandler(handler, { role: 'user' });
```

### 1.2 詳細取得 (GET /api/[role]/[resource]/[id])

```typescript
// /api/user/contents/[id].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { contentService } from '../../../lib/services/content/contentService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // サービス呼び出し
  const content = await contentService.getContentById(id);

  // 存在チェック
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // レスポンス
  return res.status(200).json({ data: content });
};

export default withApiHandler(handler, { role: 'user' });
```

### 1.3 新規作成 (POST /api/[role]/[resource])

```typescript
// /api/admin/sources/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceCreate, req.body);

  // サービス呼び出し
  const source = await sourceService.createSource(data);

  // レスポンス
  return res.status(201).json({ data: source });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 1.4 更新 (PUT /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (PUT部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'PUT') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.sourceUpdate, req.body);

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  const updatedSource = await sourceService.updateSource(id, data);

  // レスポンス
  return res.status(200).json({ data: updatedSource });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 1.5 削除 (DELETE /api/[role]/[resource]/[id])

```typescript
// /api/admin/sources/[id].ts (DELETE部分)
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { sourceService } from '../../../lib/services/source/sourceService';
import { errors } from '../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const existingSource = await sourceService.getSourceById(id);
  if (!existingSource) {
    throw errors.notFound('ソース');
  }

  // サービス呼び出し
  await sourceService.deleteSource(id);

  // レスポンス (204 No Content)
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'admin' });
```

---

## 2. 複合リソース操作パターン

### 2.1 リレーション取得 (GET /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/summaries.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'GET') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // クエリパラメータのバリデーション
  const query = await validate(schemas.summarySearch, req.query);

  // サービス呼び出し
  const summaries = await contentService.getContentSummaries(id, query);

  // レスポンス
  return res.status(200).json({ data: summaries });
};

export default withApiHandler(handler, { role: 'user' });
```

### 2.2 リレーション追加 (POST /api/[role]/[resource]/[id]/[relation])

```typescript
// /api/user/contents/[id]/tags.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.tagAdd, req.body);

  // サービス呼び出し
  const updatedContent = await contentService.addTagToContent(id, data.tagId);

  // レスポンス
  return res.status(200).json({ data: updatedContent });
};

export default withApiHandler(handler, { role: 'user' });
```

### 2.3 リレーション削除 (DELETE /api/[role]/[resource]/[id]/[relation]/[relationId])

```typescript
// /api/user/contents/[id]/tags/[tagId].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../../lib/utils/middleware';
import { contentService } from '../../../../../lib/services/content/contentService';
import { errors } from '../../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id, tagId } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string' || !tagId || typeof tagId !== 'string') {
    throw errors.validation({
      id: !id || typeof id !== 'string' ? 'コンテンツIDが不正です' : undefined,
      tagId: !tagId || typeof tagId !== 'string' ? 'タグIDが不正です' : undefined
    });
  }

  // メソッドチェック
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // サービス呼び出し
  await contentService.removeTagFromContent(id, tagId);

  // レスポンス
  return res.status(204).end();
};

export default withApiHandler(handler, { role: 'user' });
```

---

## 3. 特殊操作パターン

### 3.1 一括操作 (POST /api/[role]/[resource]/batch)

```typescript
// /api/admin/contents/batch.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.contentBatchOperation, req.body);

  // 操作タイプに応じた処理
  let result;

  switch (data.operation) {
    case 'delete':
      result = await contentService.batchDelete(data.ids);
      break;
    case 'tag':
      result = await contentService.batchAddTag(data.ids, data.tagId);
      break;
    case 'untag':
      result = await contentService.batchRemoveTag(data.ids, data.tagId);
      break;
    default:
      throw errors.validation({ operation: '不明な操作タイプです' });
  }

  // レスポンス
  return res.status(200).json({ data: result });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 3.2 アクション実行 (POST /api/[role]/[resource]/[id]/[action])

```typescript
// /api/admin/contents/[id]/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../../lib/utils/middleware';
import { validate, schemas } from '../../../../lib/utils/validation';
import { contentService } from '../../../../lib/services/content/contentService';
import { aiService } from '../../../../lib/services/ai/aiService';
import { errors } from '../../../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { id } = req.query;

  // IDのバリデーション
  if (!id || typeof id !== 'string') {
    throw errors.validation({ id: 'IDが不正です' });
  }

  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // 存在チェック
  const content = await contentService.getContentById(id);
  if (!content) {
    throw errors.notFound('コンテンツ');
  }

  // リクエストボディのバリデーション
  const data = await validate(schemas.summarizeOptions, req.body);

  // サービス呼び出し
  const summary = await aiService.summarizeContent(id, data.modelId, data.type);

  // レスポンス
  return res.status(200).json({ data: summary });
};

export default withApiHandler(handler, { role: 'admin' });
```

### 3.3 検索 (POST /api/[role]/[resource]/search)

```typescript
// /api/user/contents/search.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../../lib/utils/middleware';
import { validate, schemas } from '../../../lib/utils/validation';
import { contentService } from '../../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const searchParams = await validate(schemas.contentAdvancedSearch, req.body);

  // サービス呼び出し
  const { items, total } = await contentService.advancedSearch(searchParams);

  // レスポンス
  return res.status(200).json({
    data: items,
    meta: {
      total,
      page: searchParams.page,
      limit: searchParams.limit,
      pages: Math.ceil(total / searchParams.limit)
    }
  });
};

export default withApiHandler(handler, { role: 'user' });
```

---

## 4. 認証関連パターン

### 4.1 ログイン (POST /api/auth/login)

```typescript
// /api/auth/login.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const credentials = await validate(schemas.login, req.body);

  // 認証
  try {
    const { user, token } = await authService.login(credentials.email, credentials.password);

    // JWTをCookieにセット
    res.setHeader('Set-Cookie', `auth-token=${token}; Path=/; HttpOnly; SameSite=Strict; ${process.env.NODE_ENV === 'production' ? 'Secure;' : ''} Max-Age=86400`);

    // レスポンス
    return res.status(200).json({
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      }
    });
  } catch (error) {
    // 認証エラー
    return res.status(401).json({
      error: {
        code: 'E401',
        message: 'メールアドレスまたはパスワードが正しくありません'
      }
    });
  }
};

export default withErrorHandling(handler);
```

### 4.2 ログアウト (POST /api/auth/logout)

```typescript
// /api/auth/logout.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // Cookieを削除
  res.setHeader('Set-Cookie', 'auth-token=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0');

  // レスポンス
  return res.status(200).json({ data: { message: 'ログアウトしました' } });
};

export default withApiHandler(handler);
```

### 4.3 ユーザー登録 (POST /api/auth/register)

```typescript
// /api/auth/register.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withErrorHandling } from '../../lib/utils/middleware';
import { validate, schemas } from '../../lib/utils/validation';
import { authService } from '../../lib/services/auth/authService';
import { errors } from '../../lib/utils/error';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // メソッドチェック
  if (req.method !== 'POST') {
    return res.status(405).json({ error: { code: 'E405', message: 'Method Not Allowed' } });
  }

  // リクエストボディのバリデーション
  const userData = await validate(schemas.register, req.body);

  // メールアドレスの重複チェック
  const existingUser = await authService.getUserByEmail(userData.email);
  if (existingUser) {
    return res.status(400).json({
      error: {
        code: 'E400',
        message: 'このメールアドレスは既に登録されています'
      }
    });
  }

  // ユーザー登録
  const user = await authService.register(userData);

  // レスポンス
  return res.status(201).json({
    data: {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    }
  });
};

export default withErrorHandling(handler);
```

---

## 5. 定期実行ジョブパターン

### 5.1 コンテンツ取得ジョブ (GET /api/cron/fetch-contents)

```typescript
// /api/cron/fetch-contents.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { sourceService } from '../../lib/services/source/sourceService';
import { contentService } from '../../lib/services/content/contentService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // アクティブなソース一覧を取得
  const sources = await sourceService.getActiveSources();

  // 各ソースから新しいコンテンツを取得
  const results = await Promise.allSettled(
    sources.map(async (source) => {
      try {
        const newContents = await sourceService.fetchNewContents(source.id);

        // 新しいコンテンツごとに処理
        for (const content of newContents) {
          // コンテンツを保存
          await contentService.createContent({
            title: content.title,
            sourceId: source.id,
            originalUrl: content.url,
            publishedAt: content.publishedAt,
            // その他の必要なデータ
          });
        }

        return { sourceId: source.id, count: newContents.length };
      } catch (error) {
        console.error(`Error fetching contents from source ${source.id}:`, error);
        return { sourceId: source.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: 'コンテンツ取得ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

### 5.2 要約ジョブ (GET /api/cron/summarize)

```typescript
// /api/cron/summarize.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { withApiHandler } from '../../lib/utils/middleware';
import { contentService } from '../../lib/services/content/contentService';
import { aiService } from '../../lib/services/ai/aiService';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: { code: 'E401', message: '不正なアクセスです' } });
  }

  // 要約が必要なコンテンツを取得
  const contents = await contentService.getContentsNeedingSummary();

  // 各コンテンツを要約
  const results = await Promise.allSettled(
    contents.map(async (content) => {
      try {
        // デフォルトAIモデルを取得
        const defaultModel = await aiService.getDefaultModel();

        // 要約を実行
        const summary = await aiService.summarizeContent(content.id, defaultModel.id);

        return { contentId: content.id, success: true };
      } catch (error) {
        console.error(`Error summarizing content ${content.id}:`, error);
        return { contentId: content.id, error: error.message };
      }
    })
  );

  return res.status(200).json({
    message: '要約ジョブが完了しました',
    results
  });
};

// 認証不要（Cronからの呼び出し）
export default withApiHandler(handler);
```

---

## 6. まとめ

このドキュメントで紹介した実装パターンを活用することで、以下のメリットが得られます：

1. **コードの一貫性**: 同じパターンで実装することで、コードの可読性と保守性が向上します。

2. **開発効率の向上**: 既存のパターンを再利用することで、新しいAPIエンドポイントを迅速に実装できます。

3. **エラー削減**: 共通のバリデーションやエラーハンドリングを使用することで、バグの発生を減らせます。

4. **学習コスト削減**: 明確なパターンがあることで、新しいエンジニアの学習コストが下がります。

これらのパターンは、DigeClipのバックエンド開発において「**機能追加しやすく、何度も同じようなコードを書かなくていい**」アーキテクチャを実現するための基盤となります。

## common/reusable_components.md

# 再利用可能なコンポーネント集

> **前提**
> - このドキュメントは、DigeClipのバックエンド実装における再利用可能なコンポーネントを定義します。
> - 目的は「**何度も同じようなコンポーネントを作成しなくていい**」ようにすることです。
> - 「**どんなエンジニアでも間違うことなく実装できる**」ことを重視しつつ、「**実装が複雑すぎず時間がかからない**」方法を採用します。

---

## 1. ミドルウェア

### 1.1 認証ミドルウェア

```typescript
// /lib/utils/middleware.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { verifyToken } from './auth';

export type NextApiHandler = (req: NextApiRequest, res: NextApiResponse) => Promise<void>;

// 認証ミドルウェア
export const withAuth = (handler: NextApiHandler, requiredRole?: 'admin' | 'user'): NextApiHandler => {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    try {
      // トークン検証
      const user = await verifyToken(req);

      // ロールチェック
      if (requiredRole && user.role !== requiredRole) {
        return res.status(403).json({
          error: {
            code: 'E403',
            message: '権限がありません'
          }
        });
      }

      // リクエストにユーザー情報を追加
      req.user = user;

      // 本来のハンドラを実行
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({
        error: {
          code: 'E401',
          message: '認証に失敗しました'
        }
      });
    }
  };
};
```

### 1.2 エラーハンドリングミドルウェア

```typescript
// /lib/utils/middleware.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { AppError } from './error';

// エラーハンドリングミドルウェア
export const withErrorHandling = (handler: NextApiHandler): NextApiHandler => {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    try {
      return await handler(req, res);
    } catch (error) {
      console.error(error);

      // AppErrorの場合
      if (error instanceof AppError) {
        return res.status(error.statusCode).json({
          error: {
            code: error.code,
            message: error.message,
            details: error.details
          }
        });
      }

      // ValidationErrorの場合
      if (error.name === 'ValidationError') {
        return res.status(400).json({
          error: {
            code: 'E400',
            message: 'バリデーションエラー',
            details: error.details || error.errors
          }
        });
      }

      // その他のエラー
      return res.status(500).json({
        error: {
          code: 'E500',
          message: 'サーバーエラーが発生しました'
        }
      });
    }
  };
};
```

### 1.3 複合ミドルウェア

```typescript
// /lib/utils/middleware.ts
import { NextApiRequest, NextApiResponse } from 'next';

// 複数ミドルウェアの組み合わせ
export const withApiHandler = (handler: NextApiHandler, options?: { role?: 'admin' | 'user' }): NextApiHandler => {
  return withErrorHandling(
    options?.role ? withAuth(handler, options.role) : handler
  );
};
```

---

## 2. バリデーション

### 2.1 共通バリデーションスキーマ

```typescript
// /lib/utils/validation.ts
import * as z from 'zod';

// 再利用可能なバリデーションスキーマ
export const schemas = {
  // ID検証用スキーマ
  id: z.string().uuid('IDの形式が正しくありません'),

  // ページネーション用スキーマ
  pagination: z.object({
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().positive().max(100).default(20)
  }),

  // 日付範囲用スキーマ
  dateRange: z.object({
    startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, '日付形式はYYYY-MM-DDで入力してください').optional(),
    endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, '日付形式はYYYY-MM-DDで入力してください').optional()
  }),

  // ソート用スキーマ
  sorting: z.object({
    sortBy: z.string().optional(),
    sortOrder: z.enum(['asc', 'desc']).default('desc')
  }),

  // ソース登録用スキーマ
  sourceCreate: z.object({
    name: z.string().min(1, '名前は必須です').max(100),
    url: z.string().url('有効なURLを入力してください'),
    type: z.enum(['youtube', 'blog', 'paper'], {
      errorMap: () => ({ message: '種別は youtube/blog/paper のいずれかを選択してください' })
    }),
    isActive: z.boolean().default(true)
  }),

  // ソース更新用スキーマ
  sourceUpdate: z.object({
    name: z.string().min(1, '名前は必須です').max(100).optional(),
    url: z.string().url('有効なURLを入力してください').optional(),
    isActive: z.boolean().optional()
  }),

  // コンテンツ検索用スキーマ
  contentSearch: z.object({
    keyword: z.string().optional(),
    sourceId: z.string().optional(),
    tags: z.array(z.string()).optional(),
    startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, '日付形式はYYYY-MM-DDで入力してください').optional(),
    endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, '日付形式はYYYY-MM-DDで入力してください').optional(),
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().positive().max(100).default(20)
  }),

  // タグ追加用スキーマ
  tagAdd: z.object({
    tagId: z.string().uuid('タグIDの形式が正しくありません')
  }),

  // タグ作成用スキーマ
  tagCreate: z.object({
    name: z.string().min(1, '名前は必須です').max(20),
    color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'カラーコードの形式が正しくありません').optional()
  }),

  // ログイン用スキーマ
  login: z.object({
    email: z.string().email('有効なメールアドレスを入力してください'),
    password: z.string().min(8, 'パスワードは8文字以上で入力してください')
  }),

  // ユーザー登録用スキーマ
  register: z.object({
    name: z.string().min(1, '名前は必須です').max(50),
    email: z.string().email('有効なメールアドレスを入力してください'),
    password: z.string().min(8, 'パスワードは8文字以上で入力してください')
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'パスワードは大文字、小文字、数字を含める必要があります')
  }),

  // AIモデル設定用スキーマ
  aiModelSettings: z.object({
    modelId: z.string().uuid('モデルIDの形式が正しくありません'),
    apiKey: z.string().min(1, 'APIキーは必須です'),
    isDefault: z.boolean().optional()
  }),

  // 通知設定用スキーマ
  notificationSettings: z.object({
    webhookUrl: z.string().url('有効なWebhook URLを入力してください'),
    embedTitle: z.string().max(256, 'タイトルは256文字以内で入力してください'),
    embedDescription: z.string().max(4096, '説明は4096文字以内で入力してください'),
    embedColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'カラーコードの形式が正しくありません').optional(),
    embedThumbnailUrl: z.string().url('有効なサムネイルURLを入力してください').optional(),
    embedFooter: z.string().max(2048, 'フッターは2048文字以内で入力してください').optional()
  })
};
```

### 2.2 バリデーション実行関数

```typescript
// /lib/utils/validation.ts
import * as z from 'zod';

// バリデーション実行関数
export const validate = async <T>(schema: z.ZodSchema<T>, data: any): Promise<T> => {
  try {
    return await schema.parseAsync(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const details = {};

      for (const issue of error.issues) {
        const path = issue.path.join('.');
        details[path] = issue.message;
      }

      error.details = details;
    }

    error.name = 'ValidationError';
    throw error;
  }
};
```

---

## 3. エラーハンドリング

### 3.1 カスタムエラークラス

```typescript
// /lib/utils/error.ts
export class AppError extends Error {
  code: string;
  statusCode: number;
  details?: any;

  constructor(message: string, code: string, statusCode: number, details?: any) {
    super(message);
    this.name = 'AppError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}
```

### 3.2 共通エラー生成関数

```typescript
// /lib/utils/error.ts
export const errors = {
  notFound: (resource: string) =>
    new AppError(`${resource}が見つかりません`, 'E404', 404),

  unauthorized: () =>
    new AppError('認証に失敗しました', 'E401', 401),

  forbidden: () =>
    new AppError('権限がありません', 'E403', 403),

  validation: (details: any) =>
    new AppError('入力値が不正です', 'E400', 400, details),

  internal: (message?: string) =>
    new AppError(message || 'サーバーエラーが発生しました', 'E500', 500),

  conflict: (message: string) =>
    new AppError(message, 'E409', 409),

  badRequest: (message: string) =>
    new AppError(message, 'E400', 400),

  serviceUnavailable: (message: string) =>
    new AppError(message, 'E503', 503)
};
```

---

## 4. データベース操作

### 4.1 DB接続クライアント

```typescript
// /lib/db/client.ts
import { PrismaClient } from '@prisma/client';

// グローバルスコープでPrismaClientのインスタンスを保持
// 開発環境でのホットリロード時に複数のインスタンスが作成されるのを防ぐ
const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const db = globalForPrisma.prisma || new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db;
```

### 4.2 リポジトリベースクラス

```typescript
// /lib/db/repositories/baseRepository.ts
import { db } from '../client';

export class BaseRepository<T, CreateInput, UpdateInput> {
  protected model: any;

  constructor(modelName: string) {
    this.model = db[modelName];
  }

  async findById(id: string): Promise<T | null> {
    return this.model.findUnique({
      where: { id }
    });
  }

  async findAll(options?: { where?: any; orderBy?: any; skip?: number; take?: number }): Promise<T[]> {
    return this.model.findMany(options);
  }

  async count(where?: any): Promise<number> {
    return this.model.count({ where });
  }

  async create(data: CreateInput): Promise<T> {
    return this.model.create({ data });
  }

  async update(id: string, data: UpdateInput): Promise<T> {
    return this.model.update({
      where: { id },
      data
    });
  }

  async delete(id: string): Promise<T> {
    return this.model.delete({
      where: { id }
    });
  }

  async findFirst(where: any): Promise<T | null> {
    return this.model.findFirst({ where });
  }
}
```

### 4.3 トランザクション処理

```typescript
// /lib/db/transaction.ts
import { db } from './client';

// トランザクション実行関数
export const withTransaction = async <T>(callback: (tx: any) => Promise<T>): Promise<T> => {
  return db.$transaction(callback);
};
```

---

## 5. 認証関連

### 5.1 トークン検証

```typescript
// /lib/utils/auth.ts
import { NextApiRequest } from 'next';
import jwt from 'jsonwebtoken';
import { AppError } from './error';

// JWTシークレット
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// トークン検証関数
export const verifyToken = async (req: NextApiRequest): Promise<any> => {
  // Cookieからトークンを取得
  const token = req.cookies['auth-token'];

  // Authorizationヘッダーからトークンを取得（Cookieがない場合）
  const authHeader = req.headers.authorization;
  const bearerToken = authHeader && authHeader.startsWith('Bearer ')
    ? authHeader.substring(7)
    : null;

  // トークンがない場合はエラー
  if (!token && !bearerToken) {
    throw new AppError('認証トークンがありません', 'E401', 401);
  }

  try {
    // トークンを検証
    const decoded = jwt.verify(token || bearerToken, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new AppError('無効な認証トークンです', 'E401', 401);
  }
};
```

### 5.2 トークン生成

```typescript
// /lib/utils/auth.ts
import jwt from 'jsonwebtoken';

// JWTシークレット
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// トークン有効期限（1日）
const TOKEN_EXPIRY = '1d';

// トークン生成関数
export const generateToken = (payload: any): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: TOKEN_EXPIRY });
};
```

### 5.3 パスワードハッシュ化

```typescript
// /lib/utils/auth.ts
import bcrypt from 'bcryptjs';

// パスワードハッシュ化関数
export const hashPassword = async (password: string): Promise<string> => {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
};

// パスワード検証関数
export const verifyPassword = async (password: string, hashedPassword: string): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword);
};
```

---

## 6. 外部サービス連携

### 6.1 HTTP通信クライアント

```typescript
// /lib/utils/http.ts
import fetch from 'node-fetch';
import { AppError } from './error';

// HTTPリクエスト関数
export const httpRequest = async <T>(
  url: string,
  options?: {
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    headers?: Record<string, string>;
    body?: any;
    timeout?: number;
  }
): Promise<T> => {
  const { method = 'GET', headers = {}, body, timeout = 10000 } = options || {};

  try {
    // AbortControllerでタイムアウト設定
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      body: body ? JSON.stringify(body) : undefined,
      signal: controller.signal
    });

    // タイムアウトをクリア
    clearTimeout(timeoutId);

    // レスポンスのJSONを取得
    const data = await response.json();

    // エラーレスポンスの場合
    if (!response.ok) {
      throw new AppError(
        data.error?.message || `HTTPリクエストエラー: ${response.status}`,
        `E${response.status}`,
        response.status,
        data.error?.details
      );
    }

    return data as T;
  } catch (error) {
    // AbortControllerによるタイムアウトの場合
    if (error.name === 'AbortError') {
      throw new AppError('リクエストがタイムアウトしました', 'E408', 408);
    }

    // AppErrorの場合はそのまま再スロー
    if (error instanceof AppError) {
      throw error;
    }

    // その他のエラー
    throw new AppError(
      `HTTPリクエストエラー: ${error.message}`,
      'E500',
      500
    );
  }
};
```

### 6.2 キャッシュユーティリティ

```typescript
// /lib/utils/cache.ts
import { createClient } from 'redis';
import { AppError } from './error';

// Redisクライアント
let redisClient;

// Redisクライアント初期化
const getRedisClient = async () => {
  if (!redisClient) {
    redisClient = createClient({
      url: process.env.REDIS_URL
    });

    redisClient.on('error', (err) => {
      console.error('Redis error:', err);
    });

    await redisClient.connect();
  }

  return redisClient;
};

// キャッシュ取得関数
export const getCache = async <T>(key: string): Promise<T | null> => {
  try {
    const client = await getRedisClient();
    const data = await client.get(key);

    return data ? JSON.parse(data) : null;
  } catch (error) {
    console.error('Cache get error:', error);
    return null;
  }
};

// キャッシュ設定関数
export const setCache = async <T>(key: string, data: T, expireSeconds?: number): Promise<void> => {
  try {
    const client = await getRedisClient();

    await client.set(key, JSON.stringify(data));

    if (expireSeconds) {
      await client.expire(key, expireSeconds);
    }
  } catch (error) {
    console.error('Cache set error:', error);
  }
};

// キャッシュ削除関数
export const deleteCache = async (key: string): Promise<void> => {
  try {
    const client = await getRedisClient();
    await client.del(key);
  } catch (error) {
    console.error('Cache delete error:', error);
  }
};

// キャッシュ付きデータ取得関数
export const withCache = async <T>(
  key: string,
  fetchData: () => Promise<T>,
  options?: { expireSeconds?: number; forceRefresh?: boolean }
): Promise<T> => {
  const { expireSeconds = 3600, forceRefresh = false } = options || {};

  // 強制リフレッシュの場合はキャッシュをスキップ
  if (!forceRefresh) {
    // キャッシュからデータを取得
    const cachedData = await getCache<T>(key);

    if (cachedData) {
      return cachedData;
    }
  }

  // データを取得
  const data = await fetchData();

  // キャッシュに保存
  await setCache(key, data, expireSeconds);

  return data;
};
```

---

## 7. ロギング

### 7.1 ロガー

```typescript
// /lib/utils/logger.ts
import { db } from '../db/client';

// ログレベル
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

// ログ関数
export const log = async (
  level: LogLevel,
  message: string,
  metadata?: any
): Promise<void> => {
  // コンソールにログを出力
  console[level](message, metadata);

  // 重要なログのみDBに保存
  if (level === 'error' || level === 'warn') {
    try {
      await db.log.create({
        data: {
          level,
          message,
          metadata: metadata ? JSON.stringify(metadata) : null,
          timestamp: new Date()
        }
      });
    } catch (error) {
      console.error('Failed to save log to database:', error);
    }
  }
};

// 各ログレベルの関数
export const logger = {
  debug: (message: string, metadata?: any) => log('debug', message, metadata),
  info: (message: string, metadata?: any) => log('info', message, metadata),
  warn: (message: string, metadata?: any) => log('warn', message, metadata),
  error: (message: string, metadata?: any) => log('error', message, metadata)
};
```

---

## 8. ユーティリティ関数

### 8.1 日付操作

```typescript
// /lib/utils/date.ts
import { format, parseISO, isValid } from 'date-fns';
import { ja } from 'date-fns/locale';

// 日付フォーマット関数
export const formatDate = (
  date: Date | string,
  formatStr: string = 'yyyy/MM/dd HH:mm'
): string => {
  try {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;

    if (!isValid(dateObj)) {
      return '無効な日付';
    }

    return format(dateObj, formatStr, { locale: ja });
  } catch (error) {
    console.error('Date format error:', error);
    return '無効な日付';
  }
};

// 日付バリデーション関数
export const isValidDate = (dateStr: string): boolean => {
  try {
    const date = parseISO(dateStr);
    return isValid(date);
  } catch (error) {
    return false;
  }
};
```

### 8.2 文字列操作

```typescript
// /lib/utils/string.ts
// 文字列の切り詰め関数
export const truncate = (str: string, maxLength: number): string => {
  if (str.length <= maxLength) {
    return str;
  }

  return str.substring(0, maxLength) + '...';
};

// HTMLタグ除去関数
export const stripHtml = (html: string): string => {
  return html.replace(/<[^>]*>/g, '');
};

// スラッグ生成関数
export const generateSlug = (text: string): string => {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
};
```

---

## 9. まとめ

このドキュメントで紹介した再利用可能なコンポーネントを活用することで、以下のメリットが得られます：

1. **コードの一貫性**: 同じコンポーネントを使用することで、コードの可読性と保守性が向上します。

2. **開発効率の向上**: 既存のコンポーネントを再利用することで、新しい機能を迅速に実装できます。

3. **バグの削減**: テスト済みのコンポーネントを使用することで、バグの発生を減らせます。

4. **学習コスト削減**: 標準化されたコンポーネントがあることで、新しいエンジニアの学習コストが下がります。

これらのコンポーネントは、DigeClipのバックエンド開発において「**機能追加しやすく、何度も同じようなコンポーネントを作成しなくていい**」アーキテクチャを実現するための基盤となります。

## user/README.md

# ユーザーロール API ( `/api/user/...` )

一般ユーザーが利用する機能のエンドポイントを提供します。コンテンツの閲覧、タグ管理、システム状態確認などの機能を含みます。

## API一覧

| エンドポイント | メソッド | 説明 | 認証要否 |
|--------------|---------|------|---------|
| [/api/user/contents](./contents/list.md) | GET | コンテンツ一覧取得 | 要(user/admin) |
| [/api/user/contents/[id]](./contents/detail.md) | GET | コンテンツ詳細取得 | 要(user/admin) |
| [/api/user/contents/[id]/tags](./contents/add-tag.md) | POST | タグ追加 | 要(user/admin) |
| [/api/user/contents/[id]/tags/[tagName]](./contents/delete-tag.md) | DELETE | タグ削除 | 要(user/admin) |
| [/api/user/tags](./tags/list.md) | GET | タグ一覧取得 | 要(user/admin) |
| [/api/user/system/status](./system/status.md) | GET | システム状態取得 | 要(user/admin) |

## contents/add-tag.md

# タグ追加 API

- **HTTPメソッド**: `POST`
- **エンドポイント**: `/api/user/contents/[id]/tags`
- **機能概要**: コンテンツにタグを追加
- **認証要否**: **要**(user/admin)

## リクエスト

**Request**: `IUserAddTagRequest`
```ts
export interface IUserAddTagRequest {
  tagName: string;
}
```

**例 (リクエストJSON)**
```jsonc
{
  "tagName": "AI"
}
```

## レスポンス

**Response**: `IUserAddTagResponse`
```ts
export interface IUserAddTagResponse {
  message: string;
  contentId: number;
  tagName: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Tag added to content",
  "contentId": 203,
  "tagName": "AI"
}
```

## エラー

**Error**: e.g. `404 Not Found` (コンテンツが見つからない)
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Content not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。
   - ユーザーが自分のコンテンツのみにタグを追加できるように、認証されたユーザーIDとコンテンツの所有者IDを照合してください。
   - 管理者ユーザーの場合は、すべてのコンテンツへのタグ追加を許可することを検討してください。

2. **パスパラメータの検証**:
   - `id` パラメータが数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **入力検証**:
   - `tagName` フィールドが空でないことを確認してください。
   - `tagName` の長さに制限を設けることを検討してください（例：最大50文字）。
   - 入力が無効な場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

4. **コンテンツ存在確認**:
   - 指定された `id` のコンテンツが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。
   - 存在するが、ユーザーがアクセス権を持たない場合は `403 Forbidden` エラーを返してください。

5. **タグ存在確認**:
   - 指定された `tagName` のタグがシステムに存在するか確認してください。
   - 存在しない場合は、新しいタグを作成するか、エラーを返すかのポリシーを決定してください。
   - 新しいタグを作成する場合は、`tags` テーブルに挿入してください。スキーマ設計では、`tags` テーブルには `name`, `color`, `created_at` カラムがあります。

6. **重複チェック**:
   - 指定されたコンテンツに既に同じタグが付けられていないか確認してください。
   - 重複がある場合は、成功レスポンスを返すか、エラーを返すかのポリシーを決定してください。
   - 推奨: 重複の場合でも成功レスポンスを返し、冪等性を確保する。

7. **データベース操作**:
   - コンテンツとタグの関連付けは `content_tags` テーブルに挿入してください。スキーマ設計では、`content_tags` テーブルには `content_id`, `tag_id`, `created_at` カラムがあります。
   - 挿入操作はトランザクション内で実行し、エラー時にはロールバックしてください。
   - 特に新しいタグを作成する場合は、トランザクションが重要です。

8. **タグ数の制限**:
   - 1つのコンテンツに付けられるタグの最大数に制限を設けることを検討してください（例：最大10個）。
   - 制限に達した場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

9. **タグの正規化**:
   - タグ名の先頭と末尾の空白を削除してください。
   - 大文字・小文字の扱いを統一してください（例：すべて小文字に変換）。
   - 特殊文字の扱いに関するポリシーを決定してください。

10. **ログ記録**:
    - タグ追加操作を記録してください。
    - ログには少なくとも、タイムスタンプ、ユーザーID、コンテンツID、追加されたタグ名を含めてください。

11. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

12. **パフォーマンス考慮事項**:
    - タグの追加は比較的軽量な操作ですが、高頻度で実行される可能性があります。
    - 必要に応じて、キャッシュの無効化や更新を行ってください。

13. **自動タグ付けとの連携**:
    - システムに自動タグ付け機能がある場合、手動で追加されたタグと自動タグの区別を検討してください。
    - 例えば、`content_tags` テーブルに `is_auto_tagged` フラグを追加するなど。ただし、現在のスキーマ設計ではこのカラムは定義されていないため、必要に応じてスキーマを拡張してください。

14. **レスポンス形式**:
    - 成功時のレスポンスには、追加されたタグの情報を含めてください。
    - これにより、クライアント側での状態更新が容易になります。

15. **ユーザーとコンテンツの関連付け**:
    - スキーマ設計では `contents` テーブルに `user_id` カラムが明示的に定義されていないため、コンテンツとユーザーの関連付けを適切に管理するための追加テーブルまたはカラムを検討してください。
    - 例えば、`user_contents` という中間テーブルを作成するか、`contents` テーブルに `user_id` カラムを追加することを検討してください。

## contents/delete-tag.md

# タグ削除 API

- **HTTPメソッド**: `DELETE`
- **エンドポイント**: `/api/user/contents/[id]/tags/[tagName]`
- **機能概要**: コンテンツからタグを削除
- **認証要否**: **要**(user/admin)

## リクエスト

**Request**: パスパラメータとして `id` と `tagName` を含む

## レスポンス

**Response**: `IUserDeleteTagResponse`
```ts
export interface IUserDeleteTagResponse {
  message: string;
  contentId: number;
  tagName: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "message": "Tag removed from content",
  "contentId": 203,
  "tagName": "AI"
}
```

## エラー

**Error**: e.g. `404 Not Found` (タグが見つからない)
```jsonc
{
  "error": {
    "code": "E4043",
    "message": "Tag not found on this content"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。
   - ユーザーが自分のコンテンツのみからタグを削除できるように、認証されたユーザーIDとコンテンツの所有者IDを照合してください。
   - 管理者ユーザーの場合は、すべてのコンテンツからのタグ削除を許可することを検討してください。

2. **パスパラメータの検証**:
   - `id` パラメータが数値であることを確認してください。
   - `tagName` パラメータが空でないことを確認してください。
   - URLエンコードされた `tagName` を適切にデコードしてください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **コンテンツ存在確認**:
   - 指定された `id` のコンテンツが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。
   - 存在するが、ユーザーがアクセス権を持たない場合は `403 Forbidden` エラーを返してください。

4. **タグ関連付け確認**:
   - 指定されたコンテンツに指定された `tagName` のタグが関連付けられているか確認してください。
   - 関連付けが存在しない場合は `404 Not Found` エラーを返してください。
   - ただし、冪等性を確保するため、タグが既に削除されている場合でも成功レスポンスを返すことを検討してください。

5. **自動タグの保護（オプション）**:
   - システムによって自動的に付けられたタグ（`is_auto_tagged=true`）の削除を制限することを検討してください。
   - 自動タグを削除しようとした場合は、適切なエラーメッセージと共に `403 Forbidden` を返すか、特別な権限（管理者のみなど）を要求してください。
   - ただし、現在のスキーマ設計では `is_auto_tagged` カラムは定義されていないため、必要に応じてスキーマを拡張してください。

6. **データベース操作**:
   - コンテンツとタグの関連付けを `content_tags` テーブルから削除してください。スキーマ設計では、`content_tags` テーブルには `content_id`, `tag_id`, `created_at` カラムがあります。
   - 削除操作はトランザクション内で実行し、エラー時にはロールバックしてください。

7. **孤立タグの処理（オプション）**:
   - タグ削除後、そのタグが他のコンテンツに関連付けられていない場合（孤立タグ）、タグ自体を削除するかどうかのポリシーを決定してください。
   - 孤立タグを削除する場合は、`tags` テーブルからも削除してください。

8. **ログ記録**:
   - タグ削除操作を記録してください。
   - ログには少なくとも、タイムスタンプ、ユーザーID、コンテンツID、削除されたタグ名を含めてください。

9. **エラーハンドリング**:
   - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
   - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

10. **パフォーマンス考慮事項**:
    - タグの削除は比較的軽量な操作ですが、高頻度で実行される可能性があります。
    - 必要に応じて、キャッシュの無効化や更新を行ってください。

11. **レスポンス形式**:
    - 成功時のレスポンスには、削除されたタグの情報を含めてください。
    - これにより、クライアント側での状態更新が容易になります。

12. **一括削除の検討**:
    - 将来的に複数のタグを一度に削除する機能が必要になる可能性があります。
    - その場合は、別のエンドポイント（例：`POST /api/user/contents/[id]/tags/batch-delete`）を検討してください。

13. **ユーザーとコンテンツの関連付け**:
    - スキーマ設計では `contents` テーブルに `user_id` カラムが明示的に定義されていないため、コンテンツとユーザーの関連付けを適切に管理するための追加テーブルまたはカラムを検討してください。
    - 例えば、`user_contents` という中間テーブルを作成するか、`contents` テーブルに `user_id` カラムを追加することを検討してください。

## contents/detail.md

# コンテンツ詳細取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/user/contents/[id]`
- **機能概要**: 特定コンテンツの詳細情報と要約を取得
- **認証要否**: **要**(user/admin)

## リクエスト

**Request**: パスパラメータとして `id` を含む

## レスポンス

**Response**:
```ts
export interface ISummaryItem {
  aiModelId: number;
  stage: string;  // e.g. "overview" / "heading" / "detail"
  summaryText: string;
}

export interface IUserGetContentDetailResponse {
  id: number;
  title: string;
  url: string;
  raw_text?: string;
  metadata?: {
    thumbnail?: string;
    [key: string]: any;
  };
  tags: string[];
  status: string;
  summaries: ISummaryItem[];
  notifiedAt?: string;
  published_at?: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "id": 42,
  "title": "AIの最新動向 2025年版",
  "url": "https://www.youtube.com/watch?v=abc123",
  "raw_text": "本日は2025年のAI業界の最新動向についてお話しします...(省略)...",
  "metadata": {
    "thumbnail": "https://i.ytimg.com/vi/abc123/maxresdefault.jpg",
    "duration": 1234,
    "channelName": "テックチャンネル"
  },
  "tags": ["AI", "テクノロジー"],
  "status": "summarized",
  "summaries": [
    {
      "aiModelId": 1,
      "stage": "overview",
      "summaryText": "この動画は2025年におけるAI業界の主要な発展について解説している。特に生成AIの進化、自律システムの普及、倫理的枠組みの標準化について重点的に触れている。"
    },
    {
      "aiModelId": 1,
      "stage": "detail",
      "summaryText": "1. 生成AIの進化: マルチモーダルモデルが標準となり...(省略)...\n2. 自律システムの普及: 家庭用ロボットの普及率が先進国で20%を突破...(省略)...\n3. 倫理的枠組み: ISO/IEC 42001がグローバルスタンダードとして...(省略)..."
    }
  ],
  "notifiedAt": "2025-03-10T15:00:00Z",
  "published_at": "2025-03-10T14:30:00Z"
}
```

## エラー

**Error**: e.g. `404 Not Found` (コンテンツが見つからない)
```jsonc
{
  "error": {
    "code": "E4042",
    "message": "Content not found"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。
   - ユーザーが自分のコンテンツのみにアクセスできるように、認証されたユーザーIDとコンテンツの所有者IDを照合してください。
   - 管理者ユーザーの場合は、すべてのコンテンツへのアクセスを許可することを検討してください。

2. **パスパラメータの検証**:
   - `id` パラメータが数値であることを確認してください。
   - 不正な形式の場合は `400 Bad Request` を返してください。

3. **コンテンツ存在確認**:
   - 指定された `id` のコンテンツが存在するか確認してください。
   - 存在しない場合は `404 Not Found` エラーを返してください。
   - 存在するが、ユーザーがアクセス権を持たない場合は `403 Forbidden` エラーを返してください。

4. **データベースアクセス**:
   - コンテンツの基本情報は `contents` テーブルから取得してください。
   - タグ情報は `content_tags` テーブルと `tags` テーブルを結合して取得してください。
   - 要約情報は `summaries` テーブルから取得してください。
   - 複数のテーブルからデータを取得する場合、効率的なクエリを設計してください。

5. **要約データの処理**:
   - 要約データは `stage` ごとに整理して返してください。スキーマ設計では、`stage` カラムに "overview", "heading", "detail" などの値が想定されています。
   - 複数のAIモデルによる要約がある場合、最新または最も品質の高いものを優先することを検討してください。
   - 要約テキストが非常に長い場合、適切な長さに制限することを検討してください。

6. **生テキストの処理**:
   - `raw_text` フィールドは非常に大きくなる可能性があります。必要に応じて、長さを制限するか、別のエンドポイントで取得できるようにすることを検討してください。
   - テキストエンコーディングの問題に注意し、UTF-8エンコーディングを使用してください。

7. **メタデータの処理**:
   - メタデータは `metadata` カラムにJSONBとして保存されています。データベースから取得後、適切にパースしてください。
   - メタデータのスキーマはソースタイプによって異なる可能性があるため、柔軟な処理を実装してください。
   - クライアントに返すメタデータは、必要最小限の情報に制限することを検討してください（特に大きなメタデータの場合）。

8. **日付フォーマット**:
   - すべての日時フィールド（published_at, notifiedAt）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

9. **ステータスチェック**:
   - コンテンツのステータスが "summarized" でない場合、`summaries` フィールドが空になる可能性があります。
   - ステータスに応じて適切なレスポンスを返してください（例：処理中の場合は進捗情報を含めるなど）。

10. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

11. **パフォーマンス最適化**:
    - 複数のテーブルからデータを取得する必要があるため、クエリのパフォーマンスに注意してください。
    - 必要に応じて、以下の最適化を検討してください:
      - 適切なインデックスを使用する
      - 結果をキャッシュする（短時間のTTLで）
      - 大きなテキストフィールドは必要な場合のみ取得する

12. **セキュリティ考慮事項**:
    - URLやメタデータに含まれる可能性のある悪意のあるスクリプトに対して、適切なエスケープ処理を行ってください。
    - 特に `raw_text` フィールドには、ユーザー生成コンテンツが含まれる可能性があるため、XSS攻撃を防ぐための対策を講じてください。

13. **アクセスログ**:
    - コンテンツへのアクセスを記録し、ユーザーの閲覧履歴や人気コンテンツの分析に使用することを検討してください。
    - ログには少なくとも、タイムスタンプ、ユーザーID、コンテンツID、アクセス元IPアドレスを含めてください。

14. **ユーザーとコンテンツの関連付け**:
    - スキーマ設計では `contents` テーブルに `user_id` カラムが明示的に定義されていないため、コンテンツとユーザーの関連付けを適切に管理するための追加テーブルまたはカラムを検討してください。
    - 例えば、`user_contents` という中間テーブルを作成するか、`contents` テーブルに `user_id` カラムを追加することを検討してください。

## contents/list.md

# コンテンツ一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/user/contents`
- **機能概要**: ユーザー向けにコンテンツの一覧を取得（フィルタリング可能）
- **認証要否**: **要**(user/admin)

## リクエスト

**Request Query**:
```ts
export interface IUserGetContentsQuery {
  page?: number;
  pageSize?: number;
  tag?: string;        // タグ絞り込み
  source?: string;     // "youtube" / "rss" / "arxiv"
}
```

**例**
```
GET /api/user/contents?page=2&pageSize=10&tag=AI
```

## レスポンス

**Response**:
```ts
export interface IContentItem {
  id: number;
  title: string;
  url: string;
  published_at?: string;
  metadata?: {
    thumbnail?: string;
    [key: string]: any;
  };
  tags: string[];
  status: string; // "summarized" / "pending" / "error"
}

export interface IUserGetContentsResponse {
  data: IContentItem[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "data": [
    {
      "id": 42,
      "title": "AIの最新動向 2025年版",
      "url": "https://www.youtube.com/watch?v=abc123",
      "published_at": "2025-03-10T14:30:00Z",
      "metadata": {
        "thumbnail": "https://i.ytimg.com/vi/abc123/maxresdefault.jpg",
        "duration": 1234
      },
      "tags": ["AI", "テクノロジー"],
      "status": "summarized"
    },
    {
      "id": 43,
      "title": "新しいプログラミング言語の解説",
      "url": "https://www.youtube.com/watch?v=def456",
      "published_at": "2025-03-09T10:15:00Z",
      "metadata": {
        "thumbnail": "https://i.ytimg.com/vi/def456/maxresdefault.jpg",
        "duration": 987
      },
      "tags": ["プログラミング"],
      "status": "summarized"
    }
  ],
  "pagination": {
    "page": 2,
    "pageSize": 10,
    "total": 42
  }
}
```

## エラー

**Error**: e.g. `401 Unauthorized` (認証エラー)
```jsonc
{
  "error": {
    "code": "E4010",
    "message": "Authentication required"
  }
}
```

## 実装上の注意事項

1. **認証・認可**:
   - リクエスト処理前に必ず認証トークンを検証してください。
   - 無効なトークンや期限切れのトークンの場合は、`401 Unauthorized` エラーを返してください。
   - ユーザーが自分のコンテンツのみにアクセスできるように、認証されたユーザーIDに基づいてデータをフィルタリングしてください。

2. **クエリパラメータの検証**:
   - `page` と `pageSize` は正の整数であることを確認してください。
   - `page` のデフォルト値は 1 とし、`pageSize` のデフォルト値は適切な値（例：20）に設定してください。
   - `pageSize` には最大値（例：100）を設定し、大量のデータ取得によるパフォーマンス問題を防止してください。
   - `tag` と `source` が指定された場合、有効な値であることを確認してください。
   - 無効なパラメータが指定された場合は、適切なエラーメッセージと共に `400 Bad Request` を返してください。

3. **データベースアクセス**:
   - コンテンツデータは `contents` テーブルから取得し、ユーザーIDでフィルタリングしてください。
   - タグによるフィルタリングは、`content_tags` テーブルと `tags` テーブルを結合して行ってください。
   - ソースによるフィルタリングは、`contents` テーブルの `type` 列を使用してください（スキーマ設計では `source_type` ではなく `type` が定義されています）。
   - パフォーマンスを考慮し、必要に応じてインデックスを作成してください（特に `user_id`, `type`, `status` 列）。

4. **ページネーション実装**:
   - オフセットベースのページネーションを実装してください（例：`OFFSET (page - 1) * pageSize LIMIT pageSize`）。
   - 大量のデータがある場合は、カーソルベースのページネーションを検討してください。
   - 総件数（`total`）の取得は別クエリで行い、パフォーマンスに注意してください。

5. **タグ情報の取得**:
   - 各コンテンツのタグ情報は、`content_tags` テーブルと `tags` テーブルを結合して取得してください。
   - N+1クエリ問題を避けるため、一度のクエリで複数のコンテンツのタグを取得することを検討してください。

6. **メタデータの処理**:
   - メタデータは `metadata` カラムにJSONBとして保存されています。データベースから取得後、適切にパースしてください。
   - メタデータのスキーマはソースタイプによって異なる可能性があるため、柔軟な処理を実装してください。
   - クライアントに返すメタデータは、必要最小限の情報に制限することを検討してください（特に大きなメタデータの場合）。

7. **日付フォーマット**:
   - すべての日時フィールド（published_at）は ISO 8601 形式（YYYY-MM-DDThh:mm:ssZ）で返してください。
   - タイムゾーンは UTC を使用してください。

8. **ステータスフィルタリング**:
   - デフォルトでは、ステータスが "summarized" のコンテンツのみを返すことを検討してください。
   - 必要に応じて、ステータスによるフィルタリングをクエリパラメータとして追加することも検討してください。

9. **パフォーマンス最適化**:
   - 大量のコンテンツがある場合、クエリのパフォーマンスに注意してください。
   - 必要に応じて、以下の最適化を検討してください:
     - 必要なカラムのみを選択する（SELECT *の使用を避ける）
     - 適切なインデックスを使用する
     - 結果をキャッシュする（短時間のTTLで）

10. **エラーハンドリング**:
    - データベース接続エラーなどの内部エラーは `500 Internal Server Error` として処理し、詳細なエラーログを記録してください。
    - エラーメッセージにはセキュリティ上の機密情報を含めないよう注意してください。

11. **セキュリティ考慮事項**:
    - SQLインジェクションを防ぐため、パラメータ化クエリを使用してください。
    - クロスサイトスクリプティング（XSS）攻撃を防ぐため、レスポンスデータを適切にエスケープしてください。

12. **レスポンスサイズの制限**:
    - レスポンスサイズが大きくなりすぎないよう、`pageSize` の最大値を適切に設定してください。
    - 必要に応じて、レスポンスの圧縮を検討してください。

13. **ユーザーとコンテンツの関連付け**:
    - スキーマ設計では `contents` テーブルに `user_id` カラムが明示的に定義されていないため、コンテンツとユーザーの関連付けを適切に管理するための追加テーブルまたはカラムを検討してください。
    - 例えば、`user_contents` という中間テーブルを作成するか、`contents` テーブルに `user_id` カラムを追加することを検討してください。

## system/status.md

# システム状態取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/user/system/status`
- **機能概要**: ユーザー向けシステム状態の簡易情報を取得
- **認証要否**: **要**(user/admin)

## レスポンス

**Response**: `IUserSystemStatusResponse`
```ts
export interface IUserSystemStatusResponse {
  status: "operational" | "degraded" | "maintenance";
  message?: string;
  lastUpdated: string;
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "status": "operational",
  "lastUpdated": "2025-03-15T08:30:00Z"
}
```

## tags/list.md

# タグ一覧取得 API

- **HTTPメソッド**: `GET`
- **エンドポイント**: `/api/user/tags`
- **機能概要**: 利用可能なタグの一覧を取得
- **認証要否**: **要**(user/admin)

## レスポンス

**Response**: `IUserGetTagsResponse`
```ts
export interface ITagItem {
  id: number;
  name: string;
  color?: string;
}

export interface IUserGetTagsResponse {
  tags: ITagItem[];
}
```

**例 (レスポンスJSON)**
```jsonc
{
  "tags": [
    {
      "id": 1,
      "name": "AI",
      "color": "#FF5733"
    },
    {
      "id": 2,
      "name": "プログラミング",
      "color": "#33A8FF"
    },
    {
      "id": 3,
      "name": "ビジネス",
      "color": "#33FF57"
    }
  ]
}
```

## 2_backend_functional_requirements/3_Backend_Testing.md

# バックエンドテスト仕様

## 概要

このドキュメントでは、DigeClipプロジェクトのバックエンド部分に特化したテスト仕様を定義します。共通のテスト戦略については[共通テスト戦略](../../0_common/5_Testing_Strategy.md)を参照してください。

## 1. バックエンド特有のテスト目標

- APIエンドポイントの正確性と信頼性の確保
- データベース操作の整合性検証
- 認証・認可メカニズムの安全性確認
- パフォーマンスとスケーラビリティの検証
- エラーハンドリングの適切な実装確認

## 2. APIテスト

### 2.1 エンドポイントテスト

- **対象**: 個別のAPIエンドポイント
- **ツール**: Supertest、Jest
- **検証項目**:
  - ステータスコードの正確性
  - レスポンス形式の一貫性
  - エラーハンドリング
  - 認証・認可の適切な実装

### 2.2 テスト例

```typescript
// articles.test.ts
import request from 'supertest';
import { app } from '../app';
import { createTestToken } from '../utils/test-helpers';

describe('GET /api/articles', () => {
  it('should return 200 and articles list', async () => {
    const response = await request(app)
      .get('/api/articles')
      .expect('Content-Type', /json/)
      .expect(200);

    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body[0]).toHaveProperty('id');
    expect(response.body[0]).toHaveProperty('title');
  });

  it('should return 401 when not authenticated', async () => {
    await request(app)
      .post('/api/articles')
      .send({ title: 'New Article', content: 'Content' })
      .expect(401);
  });

  it('should create article when authenticated', async () => {
    const token = createTestToken({ id: 1, role: 'user' });

    const response = await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .send({ title: 'New Article', content: 'Content' })
      .expect(201);

    expect(response.body).toHaveProperty('id');
    expect(response.body.title).toBe('New Article');
  });
});
```

## 3. データベーステスト

### 3.1 リポジトリレイヤーテスト

- **対象**: データベースアクセスロジック
- **ツール**: Jest、テスト用DBクライアント
- **検証項目**:
  - CRUD操作の正確性
  - トランザクション処理
  - エラー処理
  - クエリパフォーマンス

### 3.2 テスト例

```typescript
// articleRepository.test.ts
import { ArticleRepository } from './articleRepository';
import { db } from '../db';

// テスト前にテストデータベースをセットアップ
beforeAll(async () => {
  await db.migrate.latest();
  await db.seed.run();
});

// テスト後にクリーンアップ
afterAll(async () => {
  await db.destroy();
});

describe('ArticleRepository', () => {
  const repo = new ArticleRepository(db);

  it('should find all articles', async () => {
    const articles = await repo.findAll();
    expect(articles.length).toBeGreaterThan(0);
    expect(articles[0]).toHaveProperty('id');
    expect(articles[0]).toHaveProperty('title');
  });

  it('should create a new article', async () => {
    const newArticle = {
      title: 'Test Article',
      content: 'Test Content',
      userId: 1
    };

    const created = await repo.create(newArticle);
    expect(created).toHaveProperty('id');
    expect(created.title).toBe(newArticle.title);

    // 作成したデータが取得できることを確認
    const found = await repo.findById(created.id);
    expect(found).toMatchObject(newArticle);
  });

  it('should update an article', async () => {
    const article = await repo.findAll().then(articles => articles[0]);
    const updated = await repo.update(article.id, { title: 'Updated Title' });

    expect(updated.title).toBe('Updated Title');
    expect(updated.id).toBe(article.id);
  });

  it('should delete an article', async () => {
    const article = await repo.create({
      title: 'To Be Deleted',
      content: 'Content',
      userId: 1
    });

    await repo.delete(article.id);
    const found = await repo.findById(article.id);
    expect(found).toBeNull();
  });
});
```

## 4. サービスレイヤーテスト

### 4.1 ビジネスロジックテスト

- **対象**: サービスクラス/関数
- **ツール**: Jest
- **検証項目**:
  - ビジネスルールの適用
  - 例外処理
  - 依存サービスとの連携
  - 認可ロジック

### 4.2 テスト例

```typescript
// articleService.test.ts
import { ArticleService } from './articleService';
import { mockArticleRepository } from '../__mocks__/articleRepository';
import { mockUserService } from '../__mocks__/userService';
import { NotFoundError, UnauthorizedError } from '../errors';

describe('ArticleService', () => {
  const articleRepo = mockArticleRepository();
  const userService = mockUserService();
  const service = new ArticleService(articleRepo, userService);

  it('should get articles with author information', async () => {
    const articles = await service.getArticles();

    expect(articles[0]).toHaveProperty('author');
    expect(articles[0].author).toHaveProperty('name');
  });

  it('should throw NotFoundError when article not found', async () => {
    articleRepo.findById.mockResolvedValue(null);

    await expect(service.getArticleById(999)).rejects.toThrow(NotFoundError);
  });

  it('should check permissions before updating article', async () => {
    const article = { id: 1, userId: 2, title: 'Test' };
    articleRepo.findById.mockResolvedValue(article);

    // 別のユーザーIDでアクセス
    await expect(
      service.updateArticle(1, { title: 'Updated' }, { id: 3, role: 'user' })
    ).rejects.toThrow(UnauthorizedError);

    // 管理者は更新可能
    articleRepo.update.mockResolvedValue({ ...article, title: 'Updated' });
    const result = await service.updateArticle(
      1,
      { title: 'Updated' },
      { id: 3, role: 'admin' }
    );

    expect(result.title).toBe('Updated');
  });
});
```

## 5. 認証・認可テスト

### 5.1 認証テスト

- **対象**: 認証ミドルウェア、認証サービス
- **ツール**: Jest、Supertest
- **検証項目**:
  - トークン検証
  - 認証失敗時の適切なエラー
  - セッション管理
  - パスワードハッシュ化

### 5.2 テスト例

```typescript
// auth.test.ts
import request from 'supertest';
import { app } from '../app';
import { createUser, deleteUser } from '../utils/test-helpers';

describe('Authentication', () => {
  const testUser = {
    email: 'test@example.com',
    password: 'Password123!'
  };

  beforeAll(async () => {
    await createUser(testUser);
  });

  afterAll(async () => {
    await deleteUser(testUser.email);
  });

  it('should login with valid credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send(testUser)
      .expect(200);

    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('user');
    expect(response.body.user.email).toBe(testUser.email);
  });

  it('should reject invalid credentials', async () => {
    await request(app)
      .post('/api/auth/login')
      .send({
        email: testUser.email,
        password: 'wrongpassword'
      })
      .expect(401);
  });

  it('should verify token and return user data', async () => {
    // まずログイン
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send(testUser);

    const token = loginResponse.body.token;

    // トークンを使用して保護されたエンドポイントにアクセス
    const response = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body).toHaveProperty('id');
    expect(response.body.email).toBe(testUser.email);
  });
});
```

## 6. 統合テスト

### 6.1 APIフローテスト

- **対象**: 複数のAPIエンドポイントを組み合わせたフロー
- **ツール**: Supertest、Jest
- **検証項目**:
  - エンドツーエンドのユーザーフロー
  - データの整合性
  - エラー状態からの回復

### 6.2 テスト例

```typescript
// article-workflow.test.ts
import request from 'supertest';
import { app } from '../app';
import { createTestToken, createUser, deleteUser } from '../utils/test-helpers';

describe('Article Workflow', () => {
  let token;
  let userId;
  let articleId;

  beforeAll(async () => {
    // テストユーザー作成
    const user = await createUser({
      email: 'workflow@example.com',
      password: 'Password123!'
    });
    userId = user.id;
    token = createTestToken({ id: userId, role: 'user' });
  });

  afterAll(async () => {
    await deleteUser('workflow@example.com');
  });

  it('should create a new article', async () => {
    const response = await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .send({
        title: 'Workflow Test',
        content: 'This is a test article'
      })
      .expect(201);

    articleId = response.body.id;
    expect(response.body.title).toBe('Workflow Test');
  });

  it('should update the article', async () => {
    await request(app)
      .put(`/api/articles/${articleId}`)
      .set('Authorization', `Bearer ${token}`)
      .send({
        title: 'Updated Workflow Test'
      })
      .expect(200);

    // 更新されたことを確認
    const response = await request(app)
      .get(`/api/articles/${articleId}`)
      .expect(200);

    expect(response.body.title).toBe('Updated Workflow Test');
  });

  it('should add a comment to the article', async () => {
    const response = await request(app)
      .post(`/api/articles/${articleId}/comments`)
      .set('Authorization', `Bearer ${token}`)
      .send({
        content: 'This is a test comment'
      })
      .expect(201);

    expect(response.body).toHaveProperty('id');
    expect(response.body.content).toBe('This is a test comment');

    // コメントが記事に関連付けられていることを確認
    const articleResponse = await request(app)
      .get(`/api/articles/${articleId}?include=comments`)
      .expect(200);

    expect(articleResponse.body.comments).toBeDefined();
    expect(articleResponse.body.comments.length).toBeGreaterThan(0);
    expect(articleResponse.body.comments[0].content).toBe('This is a test comment');
  });

  it('should delete the article', async () => {
    await request(app)
      .delete(`/api/articles/${articleId}`)
      .set('Authorization', `Bearer ${token}`)
      .expect(204);

    // 削除されたことを確認
    await request(app)
      .get(`/api/articles/${articleId}`)
      .expect(404);
  });
});
```

## 7. パフォーマンステスト

### 7.1 負荷テスト

- **対象**: 主要APIエンドポイント
- **ツール**: k6、Artillery
- **検証項目**:
  - レスポンスタイム
  - スループット
  - エラー率
  - リソース使用率

### 7.2 テスト例

```javascript
// k6-load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 20 }, // 20ユーザーまでランプアップ
    { duration: '1m', target: 20 },  // 1分間負荷を維持
    { duration: '30s', target: 0 },  // ランプダウン
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95%のリクエストが500ms以内に完了すること
    http_req_failed: ['rate<0.01'],   // エラー率1%未満
  },
};

export default function() {
  const BASE_URL = 'http://localhost:3000/api';

  // 記事一覧の取得
  const articlesResponse = http.get(`${BASE_URL}/articles`);
  check(articlesResponse, {
    'articles status is 200': (r) => r.status === 200,
    'articles response time < 200ms': (r) => r.timings.duration < 200,
  });

  // 個別記事の取得（IDは1〜10からランダム）
  const articleId = Math.floor(Math.random() * 10) + 1;
  const articleResponse = http.get(`${BASE_URL}/articles/${articleId}`);
  check(articleResponse, {
    'article status is 200': (r) => r.status === 200,
    'article response time < 150ms': (r) => r.timings.duration < 150,
  });

  sleep(1);
}
```

## 8. セキュリティテスト

### 8.1 脆弱性テスト

- **対象**: APIエンドポイント、認証システム
- **ツール**: OWASP ZAP、Jest
- **検証項目**:
  - SQLインジェクション対策
  - XSS対策
  - CSRF対策
  - 認証バイパス対策

### 8.2 テスト例

```typescript
// security.test.ts
import request from 'supertest';
import { app } from '../app';

describe('Security Tests', () => {
  it('should prevent SQL injection in query parameters', async () => {
    const maliciousQuery = "1'; DROP TABLE users; --";

    // SQLインジェクションが防止されていれば、エラーは発生するが
    // サーバーはクラッシュせず、適切なエラーレスポンスを返す
    const response = await request(app)
      .get(`/api/articles/${maliciousQuery}`)
      .expect(400); // または404、どちらにせよ500ではない

    expect(response.body).toHaveProperty('error');
  });

  it('should set secure headers', async () => {
    const response = await request(app)
      .get('/api/articles')
      .expect(200);

    // セキュリティヘッダーの確認
    expect(response.headers).toHaveProperty('x-content-type-options', 'nosniff');
    expect(response.headers).toHaveProperty('x-xss-protection', '1; mode=block');
    expect(response.headers).toHaveProperty('x-frame-options', 'DENY');
  });

  it('should require CSRF token for state-changing operations', async () => {
    // ログイン
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'Password123!'
      });

    const token = loginResponse.body.token;

    // CSRFトークンなしでPOSTリクエスト
    await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .set('Cookie', loginResponse.headers['set-cookie'])
      .send({
        title: 'Test Article',
        content: 'Content'
      })
      .expect(403); // CSRFトークンがないため拒否される
  });
});
```

## 9. バックエンド特有のテスト環境設定

### 9.1 Jest設定

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testPathIgnorePatterns: ['<rootDir>/node_modules/'],
  collectCoverageFrom: [
    'src/**/*.{js,ts}',
    '!src/**/*.d.ts',
    '!src/migrations/**',
    '!src/seeds/**',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

### 9.2 テストデータベース設定

```javascript
// knexfile.js
module.exports = {
  test: {
    client: 'pg',
    connection: {
      host: process.env.TEST_DB_HOST || 'localhost',
      user: process.env.TEST_DB_USER || 'postgres',
      password: process.env.TEST_DB_PASSWORD || 'postgres',
      database: process.env.TEST_DB_NAME || 'digeclip_test',
    },
    migrations: {
      directory: './digeclip/src/migrations',
    },
    seeds: {
      directory: './digeclip/src/seeds/test',
    },
  },
};
```

## 10. CI/CDパイプラインでのバックエンドテスト

### 10.1 GitHub Actions設定例

```yaml
# .github/workflows/backend-tests.yml
name: Backend Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'package.json'
      - 'jest.config.js'
      - 'knexfile.js'

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: digeclip_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v2

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm ci

      - name: Run migrations
        run: npm run migrate:test
        env:
          TEST_DB_HOST: localhost
          TEST_DB_USER: postgres
          TEST_DB_PASSWORD: postgres
          TEST_DB_NAME: digeclip_test

      - name: Run tests
        run: npm test
        env:
          TEST_DB_HOST: localhost
          TEST_DB_USER: postgres
          TEST_DB_PASSWORD: postgres
          TEST_DB_NAME: digeclip_test

      - name: Upload coverage
        uses: codecov/codecov-action@v2
```

## 11. バックエンドテストの優先順位

1. **最優先**: 認証・認可システム、データ整合性に関わるAPI
2. **高優先度**: 主要なビジネスロジック、データアクセスレイヤー
3. **中優先度**: 二次的なAPIエンドポイント、ユーティリティ関数
4. **低優先度**: エラーメッセージ、ログ機能

## 12. バックエンド特有のテストデータ

### 12.1 シードデータ

- ユーザーアカウント
- 記事データ
- タグ・カテゴリ
- 設定データ

### 12.2 データ管理

- マイグレーションとシードスクリプトの活用
- テスト用ファクトリー関数
- テスト間のデータ分離

## 13. バックエンドテストのトラブルシューティング

### 13.1 よくある問題と解決策

- **テストデータベース接続エラー**: 環境変数とコネクション設定を確認
- **非同期テストのタイムアウト**: テストタイムアウト設定の調整
- **テスト間の依存関係**: 各テストでデータをクリーンアップ
- **モックの不整合**: モックの戻り値と実際の実装の一致を確認

### 13.2 デバッグ方法

- `console.log` を使用したデバッグ出力
- Jest の `--verbose` フラグでより詳細な出力
- データベースクエリのログ記録
- トランザクションを使用したテストデータの分離

