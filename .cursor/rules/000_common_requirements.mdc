---
description: 共通要件
globs: ["**/*.{tsx,jsx,ts,js,md}"]
alwaysApply: false
---
# 共通要件

## 0_common/0_common_requirements.md

# 共通要件

## 0_common/0_common_tech_stack.md

5. **ngrok**
   - ローカル開発環境を外部公開
   - 外部サービスからのコールバックテストに有効
   - 認証フローのテストに便利

## 5. データベース環境の切り替え

DigeClipでは開発環境と本番環境で異なるデータベースを使用しています。環境を切り替えるには以下のコマンドを使用します。

### 環境の構成

- **開発環境**: `digeclip-dev` Supabaseプロジェクト
  - 開発・テスト用のデータベース
  - テストデータを含む
  - `.env.development`ファイルで設定

- **本番環境**: `digeclip-prod` Supabaseプロジェクト
  - 本番用のデータベース
  - 実際のユーザーデータのみ
  - `.env.production`ファイルで設定

### 環境の切り替えコマンド

```bash
# 開発環境の設定を有効にする
npm run use:dev

# 開発環境のデータベースにシードデータを適用する
npm run seed:dev

# 開発環境のデータベースをPrisma Studioで確認する
npm run studio:dev
```

### 本番環境

```bash
# 本番環境の設定を有効にする
npm run use:prod

# 本番環境のデータベースにシードデータを適用する
npm run seed:prod

# 本番環境のデータベースをPrisma Studioで確認する
npm run studio:prod
```

各環境の設定は`.env.development`と`.env.production`ファイルで管理されています。

## 6. デプロイ

## 0_common/0_common_tech_stack.md

5. **ngrok**
   - ローカル開発環境を外部公開
   - 外部サービスからのコールバックテストに有効
   - 認証フローのテストに便利

## 5. データベース環境の切り替え

DigeClipでは開発環境と本番環境で異なるSupabaseプロジェクト（データベース）を使用しており、環境ごとに独立したデータ管理を行っています。

### 環境分離の設定

1. **環境変数ファイル**：
   - `.env.development`: 開発環境の設定
   - `.env.production`: 本番環境の設定

2. **環境の切り替え**：
   次のコマンドを使って開発環境と本番環境を切り替えることができます。

```bash
# 開発環境の設定を有効にする
npm run use:dev

# 本番環境の設定を有効にする
npm run use:prod
```

3. **データベース操作**：
```bash
# 環境に応じたデータベースにシードデータを適用する
npm run seed:dev    # 開発環境用
npm run seed:prod   # 本番環境用

# Prisma Studioでデータベースを確認する
npm run studio:dev  # 開発環境用
npm run studio:prod # 本番環境用
```

### 実装の詳細

環境分離は `constants.ts` の環境検出関数と `supabase.ts` の初期化ロジックによって実現されています：

- `isDevEnvironment()`: 開発環境かどうかを判定
- `isProdEnvironment()`: 本番環境かどうかを判定
- `getSupabaseEnvironmentInfo()`: 現在の環境名を返却

Supabaseクライアントは環境に応じて適切な接続先を選択します。

### CI/CDとの連携

GitHub Actionsワークフローでは、環境に応じた秘密情報をリポジトリシークレットとして管理：

- 開発環境: `DEV_SUPABASE_URL`, `DEV_SUPABASE_ANON_KEY`
- 本番環境: `PROD_SUPABASE_URL`, `PROD_SUPABASE_ANON_KEY`

デプロイ時に適切な環境変数が自動的に設定されます。

## 6. デプロイ

## 1_common_requirements/1_technology_stack.md

# 共通技術スタック

> **注意:** コーディング規約については [4_Coding_Conventions.md](4_Coding_Conventions.md) を参照してください。ディレクトリ構造については [3_Directory_Structure.md](3_Directory_Structure.md) を参照してください。

## 前提条件

「お金をかけずに初心者が実装しやすい」方針を優先し、**無料で使えるモダンな技術スタック**を採用します。具体的には、以下の条件を満たす技術を選定します：

- 容易に経験の浅いエンジニアが実装できること
- 将来的な機能追加・スケーラビリティにも柔軟に対応できる構成
- フロントエンド + バックエンドを同一言語(TypeScript)で統一
- 最小限の手順でローカル開発を開始できる
- 本番環境にも無料枠でデプロイ可能

## 1. 言語選定

- **TypeScript 5.x**
  - **選定理由**:
    1. **静的型付け**によりコンパイル時のエラー検出が可能で、保守性を大きく向上する
    2. **JavaScriptとの高い互換性**があり、Reactなどのフロントエンドライブラリと自然に統合できる
    3. **広範なコミュニティ**と学習資源があり、初心者でも移行・導入がスムーズ
    4. **サーバレス/クラウド環境**（Cloudflare Functions など）と親和性が高く、Edge Functions の実装事例も充実
  - **バージョン**: TypeScript 5.1 以降
    - 新しいコンパイラ機能とパフォーマンス最適化が充実しており、型推論の質も向上

## 2. フレームワーク

- **Next.js 14 (React)**
  - **採用理由**:
    1. **SSR, SSG, ISR** など柔軟なレンダリング方式を公式サポートし、ベストプラクティスに沿った開発がしやすい
    2. [Cloudflare Pages](https://pages.cloudflare.com/) との組み合わせが可能で、無料枠でのデプロイおよびプレビュー機能が充実
    3. TypeScript との相性が良く、公式テンプレート (`create-next-app`) で初期セットアップが簡単
    4. 大規模コミュニティがあり、学習リソースやプラグインが豊富
    5. App Router を採用（実装済み: Next.js 15.2.2）

## 3. コア技術

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Next.js | 14.x | フロントエンド＆バックエンドフレームワーク |
| TypeScript | 5.x | 型安全な開発言語 |
| Prisma | 5.x | ORM、データベースマイグレーション |
| Supabase | 最新 | データベース（PostgreSQL）、認証（メール・Googleアカウント） |
| PostgreSQL | 15.x | リレーショナルデータベース |
| Cloudflare Pages | 最新 | ホスティング、Edge関数 |
| ngrok | 最新 | ローカル開発環境の外部公開 |

## 4. 開発環境

### コードエディタ

1. **Visual Studio Code**
   - 無料で高機能
   - 豊富な拡張機能
   - Git 連携が簡単
   - プロジェクト開発で使用中

2. **拡張機能**
   - ESLint: コード品質チェック（設定済み）
   - Prettier: コードフォーマット（設定済み）
   - Tailwind CSS IntelliSense: クラス補完
   - TypeScript 関連: 型チェックと補完

### 開発ツール

1. **ESLint**（実装済み: eslint.config.mjs）
   - コード品質の維持
   - エラーの早期発見
   - Next.js推奨設定を採用

2. **Prettier**
   - コードフォーマット
   - チーム内での一貫性確保
   - ESLintと連携

3. **TypeScript**（実装済み: tsconfig.json）
   - 型安全性
   - 自己文書化
   - エディタのサポートが充実
   - パスエイリアス設定済み（@/components など）

4. **Git / GitHub**
   - バージョン管理
   - コラボレーション
   - CI/CD 連携
   - プロジェクトで使用中

5. **ngrok**
   - ローカル開発環境を外部公開
   - 外部サービスからのコールバックテストに有効
   - 認証フローのテストに便利

## 5. デプロイ

### ホスティングサービス

1. **Cloudflare Pages**
   - Next.js との連携が可能
   - GitHub 連携で自動デプロイ
   - 無料枠が十分
   - グローバルCDNを活用した高速配信
   - Edge Functionsの活用が可能

2. **Vercel**（代替）
   - Next.js との相性が最高
   - GitHub 連携で自動デプロイ
   - 無料枠が十分
   - プレビュー環境の自動生成

3. **Netlify**（代替）
   - 同様に使いやすい
   - フォーム機能などの追加機能

## 6. データベース管理

### データベース技術

1. **PostgreSQL**
   - リレーショナルデータベース
   - Supabaseを通じて提供
   - 多様なデータ型とインデックス機能

2. **Prisma ORM**
   - 型安全なデータベースアクセス
   - スキーマ管理とマイグレーション
   - 自動生成されるクライアントAPI

### マイグレーション管理

1. **環境設定**
   - 環境変数管理：
     - `.env.development`: 開発環境設定（開発用Supabaseプロジェクト接続情報）
     - `.env.production`: 本番環境設定（本番用Supabaseプロジェクト接続情報）
     - `.env.test`: テスト環境設定（テスト用モック設定）
   - 環境切替コマンド：
     - `npm run use:dev`: 開発環境に切り替え
     - `npm run use:prod`: 本番環境に切り替え

2. **マイグレーションコマンド**
   - `npx prisma migrate dev`: 開発環境でのスキーマ変更とマイグレーション
   - `npx prisma migrate deploy`: 本番環境でのマイグレーション適用
   - `npx prisma db push`: スキーマを直接データベースに反映（開発初期段階）

3. **環境検出ロジック**
   - `constants.ts` 内の関数で環境を自動検出：
     - `isDevEnvironment()`: 開発環境かどうかを判定
     - `isProdEnvironment()`: 本番環境かどうかを判定
     - `isTestEnvironment()`: テスト環境かどうかを判定
   - これらの関数を使用して、環境に応じた接続先を自動選択

### シードデータ

1. **開発環境用シードデータ**
   - `prisma/seeds/dev_seed.sql`: 開発用テストデータ
   - 開発環境のみで使用し、本番環境では使用しない
   - アプリケーションの全モデルに対応するテストデータを含む

2. **適用方法**
   - Supabaseダッシュボード（SQL Editor）から実行
   - PostgreSQLコマンドラインから実行：`psql -h localhost -p 5432 -d postgres -U postgres -f ./prisma/seeds/dev_seed.sql`
   - `package.json`の`seed`スクリプトから実行：`npm run seed`

## 1_common_requirements/2_requirements.md

# 共通要件

## 概要

このドキュメントでは、DigeClipの共通要件を定義します。フロントエンドとバックエンドの両方に適用される要件を一元管理することで、要件の重複を避け、整合性を確保します。

## 1. エラーハンドリング

### エラー応答フォーマット

すべてのAPIエラーは以下の統一フォーマットで返却します：

```json
{
  "error": {
    "code": "E400",
    "message": "ユーザーフレンドリーなエラーメッセージ",
    "details": {
      "field1": "フィールド固有のエラーメッセージ",
      "field2": "フィールド固有のエラーメッセージ"
    }
  }
}
```

### エラーコード体系

- **E4xx**: クライアントエラー
  - E400: バリデーションエラー
  - E401: 認証エラー
  - E403: 権限エラー
  - E404: リソース未発見
  - E409: リソース競合
  - E429: リクエスト数制限超過

- **E5xx**: サーバーエラー
  - E500: 内部サーバーエラー
  - E503: サービス利用不可

### ログ記録

- すべてのエラーは適切なログレベルで記録する
- 本番環境ではスタックトレースをクライアントに返さない
- 重大なエラーは管理者に通知する仕組みを実装する

### ユーザー向けエラー表示

- ユーザーに対して、具体的で理解しやすいエラーメッセージを表示する
  - エラーメッセージはユーザーの行動をガイドする内容とし、解決策を提示
- ネットワークエラーやバリデーションエラーを適切にキャッチし、ユーザーに通知する
  - エラー発生時には、ポップアップやトースト通知を用いて即座にユーザーに知らせる
- ユーザーがエラー発生時に再試行できるオプションを提供し、操作の継続を支援する
  - 再試行ボタンを設置し、ユーザーが簡単に操作をやり直せるようにする

## 2. セキュリティ

### 認証・認可

- JWTベースの認証を実装
- ロールベースのアクセス制御（RBAC）を実装
- セッションタイムアウトは24時間
- 機密性の高い操作には再認証を要求

### データ保護

- 個人情報は暗号化して保存
- パスワードはbcryptでハッシュ化
- APIキーなどの機密情報は環境変数で管理
- データベース接続情報は適切に保護

### 入力検証

- すべてのユーザー入力は適切にバリデーション
- SQLインジェクション対策としてプリペアドステートメントを使用
- XSS対策としてユーザー入力をエスケープ
- CSRF（クロスサイトリクエストフォージェリ）対策として、トークンを用いたリクエスト検証を行う
  - 各リクエストにCSRFトークンを付与し、正当性を確認

### 通信セキュリティ

- セキュアな通信（HTTPS）を必須とし、データの盗聴や改ざんを防ぐ
  - すべての通信をHTTPSで暗号化し、セキュリティを強化
- セッション管理を強化し、一定時間の非操作で自動的にログアウトするタイムアウト設定を行う
  - セッションの有効期限を設定し、セキュリティリスクを低減

## 3. パフォーマンス

### レスポンス時間

- APIレスポンスは95%のリクエストで500ms以内
- 長時間実行される処理は非同期で実行
- 重いクエリはキャッシュを活用

### スケーラビリティ

- ステートレスなAPI設計
- 水平スケーリングを考慮した設計
- データベースインデックスを適切に設定

### リソース最適化

- 画像の最適化と遅延読み込みを実装し、初期ロード時間を短縮する
  - 画像はWebP形式を優先し、適切なサイズに最適化
  - viewport外の画像はLazy Loadingを適用
- コードの分割（Code Splitting）を行い、必要な機能のみを初期ロード時に読み込む
  - ルートベースのコード分割を実装し、ページごとに必要なコードのみ読み込み
  - 共通コンポーネントは共有チャンクとして抽出
- キャッシュ戦略を導入し、再訪問時のロード時間を短縮する
  - 静的アセットには適切なCache-Controlヘッダーを設定
  - Service Workerを使用したオフラインサポートを検討

## 4. テスト要件

### テスト種別

- 単体テスト: 個々の関数やクラスの動作を検証
- 統合テスト: コンポーネント間の連携を検証
- E2Eテスト: エンドツーエンドの動作を検証

### テストカバレッジ

- コアビジネスロジックは80%以上のカバレッジ
- 重要なAPIエンドポイントは100%カバレッジ

### 自動テスト

- CIパイプラインでの自動テスト実行
- テスト環境の自動セットアップ

## 5. アクセシビリティ

- キーボード操作をサポートし、すべてのインタラクティブ要素にフォーカス可能にする
  - タブキーでのナビゲーションをスムーズにし、フォーカスインジケーターを明確に表示
- スクリーンリーダーでの読み上げに対応し、視覚障害者が情報を取得できるようにする
  - 重要な情報には適切なラベルを付与し、スクリーンリーダーでの理解を助ける
- WCAG 2.1に準拠した適切なコントラスト比を確保し、視認性を向上させる
  - テキストと背景のコントラストを高め、すべてのユーザーにとって読みやすいデザインを提供
- ARIA属性を適切に適用し、補助技術が要素の意味を正しく理解できるようにする
  - ARIAロールやプロパティを用いて、インターフェースの意味を明確に伝える

## 6. 国際化対応

- すべてのテキストリソースを外部化し、多言語対応を容易にする
  - next-intlやreact-i18nextなどのライブラリを使用
  - 言語切り替え機能をUIに実装
- 日時表示はユーザーのロケールに合わせて最適化する
  - Intl.DateTimeFormatを活用し、地域に適した日時フォーマットを表示
- RTL（右から左）言語のサポートを考慮したレイアウト設計を行う
  - CSSの論理プロパティ（margin-inline-startなど）を使用
- 数値や通貨のフォーマットをロケールに応じて調整する
  - Intl.NumberFormatを使用して適切な桁区切りや小数点を表示

## 2_coding_conventions/1_conventions.md

# コーディング規約

このドキュメントでは、プロジェクト全体で適用されるコーディング規約を定義します。これらの規約に従うことで、コードの一貫性と可読性を確保し、チーム開発をスムーズに進めることができます。

## 基本方針

「お金をかけずに初心者が実装しやすい」方針を優先し、厳密すぎるルールは設定しません。最低限の Lint/Formatter を導入し、シンプルな規約を設けます。

## 命名規則

- **ファイル名**:
  - コンポーネント: パスカルケース (例: `Button.tsx`, `UserProfile.jsx`)
  - ユーティリティ/サービス: キャメルケース (例: `apiClient.ts`, `userService.js`)
  - 定数/設定ファイル: キャメルケース (例: `config.ts`, `constants.js`)

- **変数/関数**:
  - キャメルケースで統一 (例: `getUserData`, `fetchItems`)
  - プライベート変数/関数の先頭にはアンダースコアを付ける (例: `_privateMethod`)

- **クラス/インターフェース/型**:
  - パスカルケースで統一 (例: `UserService`, `ApiResponse`)

- **定数**:
  - 大文字のスネークケースで統一 (例: `MAX_RETRY_COUNT`, `API_BASE_URL`)

- **コンポーネントprops**:
  - キャメルケースで統一 (例: `onClick`, `userData`)

- **CSSクラス名**:
  - Tailwind ユーティリティを使用するため、命名は最小限
  - カスタムクラスが必要な場合は、ケバブケースを使用 (例: `user-card`, `nav-item`)

## コメント

- 複雑なロジックには必ずコメントを付ける
- JSDoc形式でAPI関数にはドキュメントコメントを記述
- コメントは「何をしているか」ではなく「なぜそうしているか」を説明する

```typescript
// 良い例
// ユーザーが非アクティブの場合はキャッシュから除外する
if (user.isActive) {
  cache.set(user.id, user);
}

// 悪い例
// ユーザーをキャッシュに設定
if (user.isActive) {
  cache.set(user.id, user);
}
```

## コード構造

- 関数は単一責任の原則に従い、一つのことだけを行うようにする
- 関数の長さは画面の高さ（約30行）を超えないようにする
- ネストは3レベル以上深くならないようにする
- 早期リターンを活用して、ネストを減らす

```typescript
// 良い例
function processUser(user) {
  if (!user) return null;
  if (!user.isActive) return { error: 'User is not active' };

  // メイン処理
  return transformUser(user);
}

// 悪い例
function processUser(user) {
  if (user) {
    if (user.isActive) {
      // メイン処理
      return transformUser(user);
    } else {
      return { error: 'User is not active' };
    }
  } else {
    return null;
  }
}
```

## エラーハンドリング

- try/catchブロックを適切に使用する
- エラーメッセージは具体的かつユーザーフレンドリーにする
- エラーはログに記録し、必要に応じてモニタリングシステムに通知する

## インポート順序

1. 外部ライブラリ
2. 内部モジュール（相対パスではないもの）
3. 相対パスでのインポート

```typescript
// 外部ライブラリ
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

// 内部モジュール
import { Button } from '@/components/ui';
import { useAuth } from '@/hooks';

// 相対パスでのインポート
import { UserCard } from '../UserCard';
import styles from './styles.module.css';
```

## Lint / Formatter

1. **ESLint**
   - Next.js プロジェクト作成時に自動設定されることが多い
   - "extends: next/core-web-vitals" などを採用

2. **Prettier**
   - コードフォーマット統一
   - コミット時に自動整形 (husky + lint-staged など追加可)

## 型定義（TypeScript）

- `any`型の使用は最小限に抑える
- 共通の型は`/types`ディレクトリに定義
- 関数の引数と戻り値には必ず型を指定する
- ジェネリック型を適切に活用する

```typescript
// 良い例
function getUser<T extends User>(id: string): Promise<T | null> {
  // ...
}

// 悪い例
function getUser(id) {
  // ...
}
```

## テストコードのディレクトリ構造

テストコードは以下のディレクトリ構造に従って配置します：

```
/digeclip/src
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /openai.ts                # OpenAI関連機能
  │   ├─ /discord.ts               # Discord関連機能
  │   ├─ /supabase.ts              # Supabase関連機能
  │   └─ /__tests__                # libディレクトリのテスト
  │       ├─ /openai.test.ts       # OpenAIのテスト
  │       ├─ /discord.test.ts      # Discordのテスト
  │       └─ /supabase.test.ts     # Supabaseのテスト
  │
  ├─ /components                   # コンポーネント
  │   ├─ /ui                       # UIコンポーネント
  │   └─ /__tests__                # コンポーネントのテスト
  │       └─ /ui                   # UIコンポーネントのテスト
  │
  ├─ /app                          # Next.jsのApp Router
  │   └─ /__tests__                # アプリケーションのテスト
  │
  └─ /__tests__                    # 全体的なテスト
      ├─ /utils                    # テスト用ユーティリティ
      ├─ /e2e                      # E2Eテスト
      └─ /integration              # 統合テスト
```

### テストファイルの命名規則

- 単体テスト: `*.test.ts` または `*.test.tsx`
- 統合テスト: `*.test.ts` または `*.integration.test.ts`
- E2Eテスト: `*.spec.ts` または `*.e2e.spec.ts`

### テストコードの構造

テストコードは以下の構造に従って記述します：

```typescript
// 1. インポート
import { functionToTest } from '../path/to/function';
import { mockData } from '../../__tests__/utils/test-utils';

// 2. モックの設定（必要な場合）
jest.mock('../path/to/dependency', () => ({
  dependencyFunction: jest.fn(),
}));

// 3. テストスイート
describe('functionToTest', () => {
  // 4. 前処理
  beforeEach(() => {
    // テスト前の準備
  });

  // 5. 後処理
  afterEach(() => {
    // テスト後のクリーンアップ
    jest.clearAllMocks();
  });

  // 6. テストケース
  it('正常系: 期待通りの結果を返すこと', () => {
    // テストコード
    const result = functionToTest(mockData);
    expect(result).toEqual(expectedResult);
  });

  it('異常系: エラーがスローされること', () => {
    // テストコード
    expect(() => functionToTest(invalidData)).toThrow();
  });
});
```

## まとめ

これらの規約は、コードの品質を維持しながらも、初心者が参加しやすい環境を作るために設計されています。プロジェクトの進行に合わせて、必要に応じて規約を更新していきます。

## 3_directory_structure/1_structure.md

# 共通ディレクトリ構造

このドキュメントでは、プロジェクト全体で使用する標準的なディレクトリ構造を定義します。この構造に従うことで、コードの一貫性と可読性を確保し、新しいメンバーがプロジェクトに参加する際の学習コストを低減します。

## Next.jsプロジェクトの標準ディレクトリ構造

```
/digeclip/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  ├─ /config                       # 設定ファイル
  │   ├─ constants.ts              # 定数定義
  │   ├─ routes.ts                 # ルート定義
  │   └─ ...
  │
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

## ディレクトリ構造の原則

1. **関心の分離**
   - 機能ごとに明確に分離されたディレクトリ構造
   - コンポーネント、ロジック、データアクセスの分離

2. **階層的な整理**
   - 関連するファイルは同じディレクトリにグループ化
   - 深すぎる階層は避け、必要に応じて平坦化

3. **命名規則**
   - ディレクトリ名は機能や目的を明確に表す
   - コンポーネントファイルはパスカルケース（例：`Button.tsx`）
   - ユーティリティやフックはキャメルケース（例：`useAuth.ts`）
   - テストファイルは対象ファイル名に `.test.ts(x)` を付与（例：`Button.test.tsx`）

4. **モジュール化**
   - 各ディレクトリには `index.ts` ファイルを配置して、外部からのインポートを簡素化
   - 関連するファイルをまとめてエクスポート

## テストディレクトリ構造の原則

1. **ソースコード構造との対応**
   - テストディレクトリ構造はソースコードの構造を反映
   - 各テストファイルは対応するソースファイルと同じ名前パターンを使用

2. **テスト種類による分離**
   - 単体テスト、統合テスト、E2Eテストは明確に分離
   - 各テスト種類に適した構造とツールを使用

3. **共通リソースの共有**
   - テスト用ユーティリティとモックは再利用可能なよう共通ディレクトリに配置
   - テスト間の重複を最小限に抑える

## 特記事項

- この構造は初心者でも理解しやすいように設計されています
- Next.js の最新推奨構成に従いつつ、初心者でも迷いにくいフォルダ数に留めています
- プロジェクトの成長に合わせて、必要に応じて構造を拡張できます
- テストはJest、React Testing Library、MSW、Cypressなどのツールを使用して実装します

## 4_test_strategy/1_strategy.md

# テスト戦略

このドキュメントでは、プロジェクト全体のテスト戦略を定義します。適切なテスト戦略を持つことで、コードの品質を確保し、バグの早期発見と修正が可能になります。

## テストの種類

以下の3種類のテストを実施します：

1. **単体テスト (Unit Tests)**
   - 個々のコンポーネント、関数、クラスが仕様通りに動作することを確認する
   - 外部依存を持たない、または依存をモック化して行うテスト
   - 例：UI コンポーネントの単体テスト、ユーティリティ関数のテスト

2. **統合テスト (Integration Tests)**
   - 複数のモジュールが連携して正しく動作することを確認する
   - API エンドポイントとデータベースの連携、フロントエンドとバックエンドの連携など
   - 例：API リクエストとレスポンスのテスト、データベース操作のテスト

3. **E2E テスト (End-to-End Tests)**
   - 実際のユーザーシナリオに沿ってアプリケーション全体が正しく動作することを確認する
   - フロントエンドとバックエンドの統合、データベースとの連携など、システム全体の動作を検証
   - 例：ユーザーログインフロー、コンテンツ作成フローなど

## テストの責任範囲

| テストの種類 | 責任範囲 | テストツール |
|------------|---------|------------|
| 単体テスト | コンポーネント、関数、クラスの個別機能 | Jest, React Testing Library |
| 統合テスト | モジュール間の連携、API との連携 | Jest, Supertest, MSW |
| E2E テスト | ユーザーフロー、システム全体の動作 | Playwright または Cypress |

## テストの優先度

テストの優先度は以下の順で行います：

1. **重要なビジネスロジック**
   - ユーザー認証、データ処理、重要な計算など
   - 高いテストカバレッジを目指す（80%以上）

2. **UIコンポーネント**
   - 共通UI コンポーネント（ボタン、フォーム、カードなど）
   - 複雑な UI コンポーネント

3. **API エンドポイント**
   - データ操作（CRUD）
   - 認証・認可

4. **ユーザーフロー**
   - ログインフロー
   - コンテンツ作成・編集フロー
   - 検索・フィルタリングフロー

## テストディレクトリ構造

テストコードは、以下のディレクトリ構造に従って配置します：

```
/digeclip/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          ├─ /handlers             # MSWリクエストハンドラー
          └─ /server.ts            # MSWサーバー設定
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](./2_test_structure.md)を参照してください。

## テスト命名規則

- **テストファイル**: `[対象ファイル名].test.ts` または `[対象ファイル名].test.tsx`
- **テストスイート**: `describe('[コンポーネント/関数名]', () => { ... })`
- **テストケース**: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テストツール

### 単体テスト・統合テスト

- **Jest**: JavaScript のテストランナー
- **React Testing Library**: React コンポーネントのテスト
- **MSW (Mock Service Worker)**: API リクエストのモック

### E2E テスト

- **Playwright**: Microsoft が開発した E2E テストフレームワーク
- **Cypress**: JavaScript ベースの E2E テストフレームワーク

詳細なテストツールについては、以下のドキュメントを参照してください：

- [Jest](./2_test_tools/1_jest.md)
- [Cypress と Playwright](./2_test_tools/2_cypress_playwright.md)

## テストカバレッジ

テストカバレッジの目標は以下の通りです：

- **単体テスト**: 80% 以上
- **統合テスト**: 主要な機能・フローをカバー
- **E2E テスト**: 重要なユーザーフローをカバー

テストカバレッジレポートは CI/CD パイプラインで自動的に生成し、一定以下になった場合はビルドを失敗させます。

## テスト環境

### 開発環境

- **環境変数**: `.env.test` ファイルを使用
- **データベース**: テスト用データベースを使用
- **API**: モック化または専用のテスト環境を使用

### CI環境

- GitHub Actions を使用して自動テストを実行
- Pull Request 時に全テストを実行
- マージ前にテストが全て成功していることを確認

## テスト実行コマンド

```bash
# すべてのテストを実行
npm test

# 単体テストのみ実行
npm run test:unit

# 統合テストのみ実行
npm run test:integration

# E2E テストのみ実行
npm run test:e2e

# テストカバレッジを計測
npm run test:coverage
```

## テスト作成のガイドライン

### 全般的なガイドライン

1. 各テストは独立して実行できるようにする
2. テストは明確で理解しやすいものにする
3. テストケースは具体的な動作を検証する
4. モックは必要最小限にする

### 単体テストのガイドライン

詳細は [単体テスト](./1_test_types/1_unit_tests.md) を参照してください。

### 統合テストのガイドライン

詳細は [統合テスト](./1_test_types/2_integration_tests.md) を参照してください。

### E2E テストのガイドライン

詳細は [E2E テスト](./1_test_types/3_e2e_tests.md) を参照してください。

## 継続的インテグレーション

テストは継続的インテグレーション (CI) パイプラインの一部として自動的に実行されます。

1. **プルリクエスト時**:
   - 単体テスト
   - 統合テスト
   - テストカバレッジの測定

2. **マージ前**:
   - E2E テスト

3. **定期的なスケジュール**:
   - 全テスト
   - パフォーマンステスト

## テスト戦略の見直し

テスト戦略は定期的に見直し、必要に応じて更新します。以下のタイミングで見直しを行います：

1. 四半期ごと
2. 大きな機能追加や変更がある場合
3. テストに関する問題が発生した場合

## 1_test_types/1_unit_tests.md

# 単体テスト (Unit Tests)

単体テストは、アプリケーションの最小単位（関数、クラス、コンポーネントなど）を個別にテストします。これにより、各機能が意図したとおりに動作することを確認します。

## 単体テストの目的

- 個々のコンポーネント、関数、クラスが仕様通りに動作することを確認する
- バグの早期発見と修正を容易にする
- リファクタリングの安全性を確保する
- コードの品質を向上させる

## 対象となるコード

以下のようなコードが単体テストの対象となります：

1. **UIコンポーネント**
   - ボタン、フォーム、カードなどの基本的なUIコンポーネント
   - ヘッダー、フッター、サイドバーなどのレイアウトコンポーネント
   - データテーブル、グラフなどの複雑なコンポーネント

2. **ユーティリティ関数**
   - 日付フォーマット、数値変換などのヘルパー関数
   - バリデーション関数
   - データ変換関数

3. **カスタムフック**
   - 状態管理フック
   - API通信フック
   - イベントハンドリングフック

## ディレクトリ構造

単体テストは、`digeclip/src/__tests__/unit` ディレクトリに配置します。テストの構造はソースコードの構造を反映します。

```
/digeclip/src
  └─ /__tests__                    # テストコード
      └─ /unit                     # 単体テスト
          ├─ /components           # コンポーネントの単体テスト
          │   ├─ /ui               # UIコンポーネント
          │   │   ├─ Button.test.tsx
          │   │   └─ ...
          │   ├─ /layout           # レイアウトコンポーネント
          │   └─ /features         # 機能別コンポーネント
          ├─ /hooks                # カスタムフックのテスト
          │   ├─ useAuth.test.ts
          │   └─ ...
          ├─ /lib                  # ユーティリティのテスト
          │   ├─ /services         # サービスのテスト
          │   ├─ /utils            # ユーティリティのテスト
          │   └─ ...
          └─ /context              # コンテキストのテスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象ファイル名].test.ts` または `[対象ファイル名].test.tsx`
- テストスイート: `describe('[関数名/コンポーネント名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 各テストは独立して実行できるようにする
2. テストは明確で理解しやすいものにする
3. テストケースは具体的な動作を検証する
4. モックは必要最小限にする

### 関数のテスト

```typescript
// src/lib/__tests__/openai.test.ts
import { generateText } from '../openai';
import { mockEnv } from '../../__tests__/utils/test-utils';

// 環境変数のモック
mockEnv({
  OPENAI_API_KEY: 'test-api-key',
});

describe('generateText', () => {
  it('正常系: テキストを生成できること', async () => {
    // テストコード
    const result = await generateText('テストプロンプト');
    expect(result).toBeDefined();
    expect(typeof result).toBe('string');
  });

  it('異常系: APIキーがない場合はエラーをスローすること', async () => {
    // 環境変数を一時的に上書き
    const originalEnv = process.env.OPENAI_API_KEY;
    process.env.OPENAI_API_KEY = '';

    // テストコード
    await expect(generateText('テストプロンプト')).rejects.toThrow();

    // 環境変数を元に戻す
    process.env.OPENAI_API_KEY = originalEnv;
  });
});
```

### コンポーネントのテスト

```typescript
// src/components/__tests__/ui/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../../ui/Button';

describe('Button', () => {
  it('ボタンがレンダリングされること', () => {
    render(<Button>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeInTheDocument();
  });

  it('クリックイベントが発火すること', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>テスト</Button>);
    const button = screen.getByText('テスト');
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('disabled属性が適用されること', () => {
    render(<Button disabled>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeDisabled();
  });
});
```

## テストカバレッジ

単体テストは、以下の基準を目標とします：

- 関数/メソッド: 80%以上
- 分岐カバレッジ: 70%以上
- 行カバレッジ: 75%以上

ただし、これらの数値は目安であり、コードの重要度や複雑さに応じて調整します。

## 1_test_types/2_integration_tests.md

# 統合テスト (Integration Tests)

統合テストは、複数のコンポーネントやモジュールが連携して動作することを確認するテストです。単体テストでは検出できない、コンポーネント間の連携の問題を発見することができます。

## 統合テストの目的

- 複数のコンポーネントやモジュールが連携して正しく動作することを確認する
- APIとのデータのやり取りが正しく行われることを確認する
- ユーザーインターフェースとバックエンドロジックの統合を検証する
- 単体テストでは発見できない問題を検出する

## 対象となるコード

以下のようなコードが統合テストの対象となります：

1. **機能別コンポーネント**
   - フォームとバリデーションロジックの統合
   - データ取得コンポーネントとAPIフックの統合
   - 複数のUIコンポーネントの組み合わせ

2. **APIとのデータのやり取り**
   - APIリクエストの送信と応答の処理
   - エラーハンドリング
   - キャッシュの管理

3. **状態管理**
   - Contextの更新と子コンポーネントの再レンダリング
   - 複数のReducerの連携

## ディレクトリ構造

統合テストは、`digeclip/src/__tests__/integration` ディレクトリに配置します。

```
/digeclip/src
  └─ /__tests__                    # テストコード
      └─ /integration              # 統合テスト
          ├─ /api                  # API統合テスト
          │   ├─ auth.test.ts
          │   └─ ...
          ├─ /features             # 機能結合テスト
          │   ├─ SourceForm.test.tsx
          │   └─ ...
          └─ /pages                # ページ統合テスト
              ├─ dashboard.test.tsx
              └─ ...
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象機能].test.ts` または `[対象機能].integration.test.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 実際の依存関係を使用する（モックは最小限に）
2. テスト環境を適切に設定する
3. テストデータは自己完結的に用意する
4. テスト後は環境をクリーンアップする

### APIとデータベースの統合テスト

```typescript
// src/__tests__/integration/api/content.test.ts
import { createClient } from '@supabase/supabase-js';
import { createContent, getContent } from '../../../lib/content';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('Content API 統合テスト', () => {
  let supabase;
  let testContentId;

  beforeAll(async () => {
    // テスト用のSupabaseクライアントを作成
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );

    // テストデータをクリーンアップ
    await supabase.from('contents').delete().eq('title', 'テスト用コンテンツ');
  });

  afterAll(async () => {
    // テストデータをクリーンアップ
    if (testContentId) {
      await supabase.from('contents').delete().eq('id', testContentId);
    }
  });

  it('コンテンツを作成して取得できること', async () => {
    // コンテンツを作成
    const newContent = {
      title: 'テスト用コンテンツ',
      body: 'これはテスト用のコンテンツです。',
    };

    const { data: createdContent, error: createError } = await createContent(newContent);
    expect(createError).toBeNull();
    expect(createdContent).toBeDefined();
    expect(createdContent.title).toBe(newContent.title);

    testContentId = createdContent.id;

    // 作成したコンテンツを取得
    const { data: retrievedContent, error: getError } = await getContent(testContentId);
    expect(getError).toBeNull();
    expect(retrievedContent).toBeDefined();
    expect(retrievedContent.id).toBe(testContentId);
    expect(retrievedContent.title).toBe(newContent.title);
  });
});
```

### フロントエンドとバックエンドの統合テスト

```typescript
// src/__tests__/integration/services/content.test.ts
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ContentForm } from '../../../components/ContentForm';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('ContentForm 統合テスト', () => {
  it('フォーム送信時にコンテンツが作成されること', async () => {
    // モックサーバーのセットアップ（MSWなどを使用）
    // ...

    // コンポーネントをレンダリング
    render(<ContentForm />);

    // フォームに入力
    await userEvent.type(screen.getByLabelText('タイトル'), 'テスト用コンテンツ');
    await userEvent.type(screen.getByLabelText('本文'), 'これはテスト用のコンテンツです。');

    // フォームを送信
    await userEvent.click(screen.getByText('保存'));

    // 結果を確認
    await waitFor(() => {
      expect(screen.getByText('コンテンツが保存されました')).toBeInTheDocument();
    });
  });
});
```

## テスト環境

統合テストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **モックサーバー**
   - 外部APIとの通信をモック化（必要に応じて）
   - [MSW (Mock Service Worker)](https://mswjs.io/) などのツールを使用

3. **テスト用環境変数**
   - `.env.test` ファイルを用意
   - テスト用の認証情報を設定

## 1_test_types/3_e2e_tests.md

# E2Eテスト (End-to-End Tests)

E2Eテストは、アプリケーション全体を実際のユーザーの視点からテストします。ユーザーの行動を模倣し、アプリケーションが期待通りに動作することを確認します。

## E2Eテストの目的

- 実際のユーザー体験をシミュレートする
- アプリケーション全体の機能が連携して動作することを確認する
- 本番環境に近い状態でのテストを行い、統合上の問題を発見する
- 重要なユーザーフローが正常に機能することを確認する

## 対象となるユーザーフロー

以下のようなユーザーフローがE2Eテストの対象となります：

1. **認証フロー**
   - ユーザーのログイン
   - ユーザーの登録
   - パスワードリセット

2. **ナビゲーションフロー**
   - メニュー間の移動
   - ページ間の遷移
   - ディープリンクの動作

3. **データ操作フロー**
   - フォーム入力と送信
   - データの作成・読み取り・更新・削除（CRUD）
   - ファイルのアップロードとダウンロード

## ディレクトリ構造

E2Eテストは、`digeclip/src/__tests__/e2e` ディレクトリに配置します。

```
/digeclip/src
  └─ /__tests__                    # テストコード
      └─ /e2e                      # E2Eテスト
          ├─ /auth                 # 認証関連E2Eテスト
          │   ├─ login.test.ts
          │   ├─ register.test.ts
          │   └─ ...
          ├─ /navigation           # ナビゲーション関連E2Eテスト
          │   ├─ menu.test.ts
          │   └─ ...
          └─ /content              # コンテンツ関連E2Eテスト
              ├─ contentList.test.ts
              ├─ contentDetail.test.ts
              └─ ...
```

## Cypressを使用したE2Eテスト例

```typescript
// E2Eテスト例：ログインフロー
describe('ログイン機能', () => {
  beforeEach(() => {
    // 各テスト前にホームページにアクセス
    cy.visit('/');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインページに移動
    cy.get('[data-testid="login-button"]').click();

    // 認証情報を入力
    cy.get('[data-testid="email-input"]').type('test@example.com');
    cy.get('[data-testid="password-input"]').type('password123');

    // ログインボタンをクリック
    cy.get('[data-testid="submit-button"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ユーザー名が表示されることを確認
    cy.get('[data-testid="user-greeting"]').should('contain', 'テストユーザー');
  });

  it('無効な認証情報でログインするとエラーが表示されること', () => {
    // ログインページに移動
    cy.get('[data-testid="login-button"]').click();

    // 無効な認証情報を入力
    cy.get('[data-testid="email-input"]').type('invalid@example.com');
    cy.get('[data-testid="password-input"]').type('wrongpassword');

    // ログインボタンをクリック
    cy.get('[data-testid="submit-button"]').click();

    // エラーメッセージが表示されることを確認
    cy.get('[data-testid="error-message"]').should('be.visible');
    cy.get('[data-testid="error-message"]').should('contain', 'メールアドレスまたはパスワードが正しくありません');

    // URLがログインページのままであることを確認
    cy.url().should('include', '/login');
  });
});
```

## テスト命名規則

- テストファイル: `[対象機能].spec.ts` または `[対象機能].e2e.spec.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 重要なユーザーフローに焦点を当てる
2. テストは独立して実行できるようにする
3. テストデータは自己完結的に用意する
4. テスト環境をテスト前に適切に設定し、テスト後にクリーンアップする

### Cypressを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/login.spec.ts
describe('ログインフロー', () => {
  beforeEach(() => {
    // テスト前の準備
    cy.visit('/login');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインフォームに入力
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ログイン成功メッセージが表示されることを確認
    cy.contains('ログインに成功しました').should('be.visible');
  });

  it('無効な認証情報でログインできないこと', () => {
    // ログインフォームに無効な認証情報を入力
    cy.get('input[name="email"]').type('invalid@example.com');
    cy.get('input[name="password"]').type('wrongpassword');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ログインページに留まることを確認
    cy.url().should('include', '/login');

    // エラーメッセージが表示されることを確認
    cy.contains('メールアドレスまたはパスワードが正しくありません').should('be.visible');
  });
});
```

### Playwrightを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/content.spec.ts
import { test, expect } from '@playwright/test';

test.describe('コンテンツ作成フロー', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // ダッシュボードに移動したことを確認
    await expect(page).toHaveURL(/.*dashboard/);
  });

  test('新しいコンテンツを作成できること', async ({ page }) => {
    // 新規作成ページに移動
    await page.click('text=新規作成');
    await expect(page).toHaveURL(/.*create/);

    // フォームに入力
    await page.fill('input[name="title"]', 'テスト用コンテンツ');
    await page.fill('textarea[name="body"]', 'これはテスト用のコンテンツです。');

    // 保存ボタンをクリック
    await page.click('button:has-text("保存")');

    // 保存成功メッセージが表示されることを確認
    await expect(page.locator('text=コンテンツが保存されました')).toBeVisible();

    // コンテンツ一覧に作成したコンテンツが表示されることを確認
    await page.goto('/dashboard');
    await expect(page.locator('text=テスト用コンテンツ')).toBeVisible();
  });
});
```

## テスト環境

E2Eテストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **テスト用サーバー**
   - ローカル開発サーバーまたはステージング環境を使用

3. **テスト用ブラウザ**
   - 複数のブラウザでテストを実行（Chrome, Firefox, Safari など）
   - モバイルデバイスのエミュレーションも考慮

## テスト実行方法

```bash
# Cypressを使用する場合
npm run test:e2e

# Playwrightを使用する場合
npm run test:e2e:playwright
```

## 4_test_strategy/2_test_structure.md

# テストディレクトリ構造

このドキュメントでは、テストコードの構造と整理方法について詳細を説明します。

## テストディレクトリの基本構造

```
/digeclip/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

ルートディレクトリには以下の設定ファイルも配置します：

```
/
├─ jest.config.js                # Jest設定
├─ jest.setup.js                 # Jestセットアップ
└─ playwright.config.ts          # Playwright設定（E2Eテスト用）
```

## テストの種類別の構造

### 単体テスト（Unit Tests）

単体テストは、個々のコンポーネント、関数、フックなどの小さな単位をテストします。

- **テストツール**: Jest + React Testing Library
- **ディレクトリ**: `/__tests__/unit/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: ソースコードの構造を反映する

### 統合テスト（Integration Tests）

統合テストは、複数のコンポーネントや機能が連携して正しく動作することを確認します。

- **テストツール**: Jest + React Testing Library + MSW
- **ディレクトリ**: `/__tests__/integration/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: 機能ごとにグループ化する

### E2Eテスト（End-to-End Tests）

E2Eテストは、実際のユーザーシナリオに沿ってアプリケーション全体が正しく動作することを確認します。

- **テストツール**: Playwright または Cypress
- **ディレクトリ**: `/__tests__/e2e/`
- **ファイル命名規則**: `*.test.ts`
- **構造原則**: ユーザーフローごとにグループ化する

## サポートディレクトリ

### ユーティリティ（Utils）

テスト間で共有される便利な関数やヘルパーを提供します。

- **ディレクトリ**: `/__tests__/utils/`
- **内容**:
  - `test-utils.ts`: 共通ヘルパー関数
  - `renderWithProviders.tsx`: プロバイダー付きのコンポーネントレンダリング
  - カスタムマッチャーなど

### モック（Mocks）

テストで使用するモックデータとリクエストハンドラーを定義します。

- **ディレクトリ**: `/__tests__/mocks/`
- **内容**:
  - `/data/`: モックデータオブジェクト
  - `/handlers/`: MSWリクエストハンドラー
  - `server.ts`: MSWサーバー設定

## テストファイルの配置原則

1. **単体テスト**:
   - テスト対象のソースコードと同じ構造を反映
   - 例：`/components/ui/Button.tsx` → `/__tests__/unit/components/ui/Button.test.tsx`

2. **統合テスト**:
   - 機能やモジュールの連携に焦点を当てた構造
   - 例：認証フロー全体をテスト → `/__tests__/integration/auth/authFlow.test.tsx`

3. **E2Eテスト**:
   - ユーザーストーリーやユースケースに基づく構造
   - 例：ログインフロー → `/__tests__/e2e/auth/login.test.ts`

## テストディレクトリ構造の利点

1. **明確な分離**: テストの種類ごとに明確に分離することで、テストの目的と範囲が明確になる
2. **容易な実行**: 特定の種類のテストのみを実行することが容易
3. **構造の一貫性**: ソースコードの構造を反映することで、テストファイルの場所が予測しやすくなる
4. **再利用性**: ユーティリティとモックを共有することで、コードの重複を減らす

## テスト関連設定ファイル

### Jest設定（jest.config.js）

```js
// jest.config.js
import nextJest from 'next/jest.js';

const createJestConfig = nextJest({
  // テスト環境のNext.jsアプリのパスを指定
  dir: './',
});

/** @type {import('jest').Config} */
const config = {
  // テストマッチングパターン
  testMatch: [
    '<rootDir>/digeclip/src/__tests__/unit/**/*.test.{ts,tsx}',
    '<rootDir>/digeclip/src/__tests__/integration/**/*.test.{ts,tsx}',
  ],

  // モジュール変換の設定
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },

  // テスト環境
  testEnvironment: 'jest-environment-jsdom',

  // パスエイリアス
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/digeclip/src/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },

  // カバレッジの設定
  collectCoverageFrom: [
    'digeclip/src/**/*.{ts,tsx}',
    '!digeclip/src/**/*.d.ts',
    '!digeclip/src/**/*.stories.{ts,tsx}',
    '!digeclip/src/types/**/*',
    '!digeclip/src/__tests__/**/*',
  ],

  // テスト前後の処理
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
};

export default createJestConfig(config);
```

### Jest設定（jest.setup.js）

```js
// jest.setup.js
import '@testing-library/jest-dom';
import { TextEncoder, TextDecoder } from 'util';
import { server } from './digeclip/src/__tests__/mocks/server';

// MSWサーバーのセットアップ
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// グローバルなモックの設定
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
```

### Playwright設定（playwright.config.ts）

```ts
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './digeclip/src/__tests__/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile-safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

## テスト実行コマンド

以下のコマンドをpackage.jsonに追加します：

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=digeclip/src/__tests__/unit",
    "test:integration": "jest --testPathPattern=digeclip/src/__tests__/integration",
    "test:e2e": "playwright test",
    "test:coverage": "jest --coverage"
  }
}
```

## まとめ

この構造に従うことで、テストの管理と実行が容易になり、コードの品質を確保できます。テストディレクトリ構造は、プロジェクトの成長に合わせて柔軟に拡張できます。

## 2_test_tools/1_jest.md

# Jest

## 概要

Jestは、JavaScriptとTypeScriptのテストフレームワークであり、特にReactアプリケーションのテストに適しています。シンプルな設定と強力な機能を持ち、単体テストと統合テストに使用します。

## 設定

### パッケージのインストール

```bash
npm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom
```

### 基本設定（jest.config.js）

```javascript
/** @type {import('jest').Config} */
const config = {
  testEnvironment: 'jest-environment-jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/digeclip/src/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  collectCoverageFrom: [
    'digeclip/src/**/*.{ts,tsx}',
    '!digeclip/src/**/*.d.ts',
    '!digeclip/src/**/*.stories.{ts,tsx}',
    '!digeclip/src/types/**/*',
    '!digeclip/src/__tests__/**/*',
  ],
};

export default config;
```

### セットアップファイル（jest.setup.js）

```javascript
import '@testing-library/jest-dom';
import { server } from './digeclip/src/__tests__/mocks/server';

// MSWサーバーのセットアップ
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

## 使用例

### コンポーネントのテスト

```typescript
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import Button from '@/components/ui/Button/Button';

describe('Button Component', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });

  it('calls onClick handler when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('applies the correct variant class', () => {
    render(<Button variant="primary">Primary Button</Button>);
    expect(screen.getByRole('button')).toHaveClass('btn-primary');
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled Button</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

### ユーティリティ関数のテスト

```typescript
// formatDate.test.ts
import { formatDate } from '@/lib/utils/formatDate';

describe('formatDate', () => {
  it('formats dates correctly', () => {
    const date = new Date('2023-01-15T12:30:45');
    expect(formatDate(date)).toBe('2023/01/15');
  });

  it('formats dates with custom format', () => {
    const date = new Date('2023-01-15T12:30:45');
    expect(formatDate(date, 'YYYY-MM-DD')).toBe('2023-01-15');
  });

  it('returns empty string for invalid date', () => {
    const date = new Date('invalid date');
    expect(formatDate(date)).toBe('');
  });
});
```

### カスタムフックのテスト

```typescript
// useCounter.test.ts
import { renderHook, act } from '@testing-library/react';
import useCounter from '@/hooks/useCounter';

describe('useCounter', () => {
  it('should initialize counter with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it('should initialize counter with provided value', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });

  it('should increment counter', () => {
    const { result } = renderHook(() => useCounter());
    act(() => {
      result.current.increment();
    });
    expect(result.current.count).toBe(1);
  });

  it('should decrement counter', () => {
    const { result } = renderHook(() => useCounter(5));
    act(() => {
      result.current.decrement();
    });
    expect(result.current.count).toBe(4);
  });

  it('should reset counter to provided value', () => {
    const { result } = renderHook(() => useCounter(5));
    act(() => {
      result.current.reset();
    });
    expect(result.current.count).toBe(0);
  });
});
```

## ベストプラクティス

1. **テストファイルの命名規則**
   - テスト対象のファイルと同じ名前に `.test.ts(x)` を付ける
   - 例：`Button.tsx` → `Button.test.tsx`

2. **テスト構造**
   - `describe` ブロックでテストスイートをグループ化
   - `it` または `test` ブロックで個々のテストケースを記述
   - テスト名は「何をテストするか」が明確になるように記述

3. **テストカバレッジ**
   - 重要なロジックやコンポーネントは高いカバレッジを目指す
   - `npm test -- --coverage` でカバレッジレポートを生成

4. **モックの活用**
   - 外部依存（API、データベースなど）はモック化
   - `jest.mock()` や MSW を使用してAPIリクエストをモック

5. **スナップショットテスト**
   - UIコンポーネントの変更を検出するためにスナップショットテストを活用
   - `expect(component).toMatchSnapshot()`

## 注意点

- テストは独立していて、他のテストに依存しないようにする
- グローバルな状態を変更するテストはリセットを忘れずに
- 非同期コードをテストする場合は、適切に待機処理を行う
- テストパフォーマンスを考慮し、必要以上に複雑なテストを避ける


## 2_test_tools/2_cypress_playwright.md

# Cypress/Playwright

## 概要

Cypress と Playwright は、ブラウザ上でのインタラクションをシミュレートしてWebアプリケーションをテストするためのE2E（エンドツーエンド）テストツールです。ユーザーの操作を自動化し、実際のブラウザ環境での動作を検証します。

## Playwright

PlaywrightはMicrosoftが開発したモダンなE2Eテストツールで、複数のブラウザエンジン（Chromium、Firefox、WebKit）をサポートしています。

### インストール

```bash
npm install --save-dev @playwright/test
npx playwright install
```

### 設定（playwright.config.ts）

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './digeclip/src/__tests__/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

### Playwrightを使用したテスト例

```typescript
// login.test.ts
import { test, expect } from '@playwright/test';

test.describe('ログイン機能', () => {
  test.beforeEach(async ({ page }) => {
    // 各テスト前にホームページにアクセス
    await page.goto('/');
  });

  test('有効な認証情報でログインできること', async ({ page }) => {
    // ログインページに移動
    await page.click('[data-testid="login-button"]');

    // 認証情報を入力
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');

    // ログインボタンをクリック
    await page.click('[data-testid="submit-button"]');

    // ダッシュボードにリダイレクトされることを確認
    await expect(page).toHaveURL(/.*dashboard/);

    // ユーザー名が表示されることを確認
    await expect(page.locator('[data-testid="user-greeting"]')).toContainText('テストユーザー');
  });

  test('無効な認証情報でログインするとエラーが表示されること', async ({ page }) => {
    // ログインページに移動
    await page.click('[data-testid="login-button"]');

    // 無効な認証情報を入力
    await page.fill('[data-testid="email-input"]', 'invalid@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');

    // ログインボタンをクリック
    await page.click('[data-testid="submit-button"]');

    // エラーメッセージが表示されることを確認
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
    await expect(page.locator('[data-testid="error-message"]')).toContainText('メールアドレスまたはパスワードが正しくありません');

    // URLがログインページのままであることを確認
    await expect(page).toHaveURL(/.*login/);
  });
});
```

## Cypress

Cypressは、モダンなWebアプリケーションのためのE2Eテストツールで、開発者向けの優れたデバッグ体験を提供します。

### インストール

```bash
npm install --save-dev cypress
```

### 設定（cypress.config.ts）

```typescript
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'digeclip/src/__tests__/e2e/**/*.cy.{js,jsx,ts,tsx}',
    supportFile: 'digeclip/src/__tests__/e2e/support/e2e.ts',
    videosFolder: 'cypress/videos',
    screenshotsFolder: 'cypress/screenshots',
    viewportWidth: 1280,
    viewportHeight: 720,
  },
});
```

### Cypressを使用したテスト例

```typescript
// login.cy.ts
describe('ログイン機能', () => {
  beforeEach(() => {
    // 各テスト前にホームページにアクセス
    cy.visit('/');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインページに移動
    cy.get('[data-testid="login-button"]').click();

    // 認証情報を入力
    cy.get('[data-testid="email-input"]').type('test@example.com');
    cy.get('[data-testid="password-input"]').type('password123');

    // ログインボタンをクリック
    cy.get('[data-testid="submit-button"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ユーザー名が表示されることを確認
    cy.get('[data-testid="user-greeting"]').should('contain', 'テストユーザー');
  });

  it('無効な認証情報でログインするとエラーが表示されること', () => {
    // ログインページに移動
    cy.get('[data-testid="login-button"]').click();

    // 無効な認証情報を入力
    cy.get('[data-testid="email-input"]').type('invalid@example.com');
    cy.get('[data-testid="password-input"]').type('wrongpassword');

    // ログインボタンをクリック
    cy.get('[data-testid="submit-button"]').click();

    // エラーメッセージが表示されることを確認
    cy.get('[data-testid="error-message"]').should('be.visible');
    cy.get('[data-testid="error-message"]').should('contain', 'メールアドレスまたはパスワードが正しくありません');

    // URLがログインページのままであることを確認
    cy.url().should('include', '/login');
  });
});
```

## ベストプラクティス

1. **データ属性の使用**
   - テスト用のデータ属性（例：`data-testid="login-button"`）を使用して要素を選択
   - CSSやクラス名の変更に影響されないロバストなテストを作成

2. **テストの独立性確保**
   - 各テストは完全に独立して実行できるようにする
   - テスト間で状態が共有されないようにする

3. **テスト環境の分離**
   - テスト用のデータベースやAPIモックを使用
   - テスト用の環境変数を設定

4. **テストの安定性向上**
   - 非同期処理の待機を適切に行う
   - 再試行メカニズムを活用（特にCI環境で）

5. **視覚的リグレッションテスト**
   - スクリーンショットを使った視覚的な変更検出
   - コンポーネントのレイアウト崩れなどを検出

## 注意点

- E2Eテストは単体テストや統合テストよりも実行時間が長い
- すべての機能をE2Eテストでカバーするのではなく、重要なユーザーフローに焦点を当てる
- CIパイプラインに組み込む場合は、実行時間とリソース消費を考慮
- ヘッドレスモードでの実行をサポートして、CI環境での実行を効率化

## 4_test_strategy/README.md

# テスト戦略

このディレクトリには、プロジェクトのテスト戦略に関するドキュメントが含まれています。

## ドキュメント構造

```
/rules/0_common/4_test_strategy/
├── README.md                     # このファイル
├── 1_strategy.md                 # テスト戦略の概要
├── 1_test_types/                 # テストの種類
│   ├── 1_unit_tests.md           # 単体テスト
│   ├── 2_integration_tests.md    # 統合テスト
│   └── 3_e2e_tests.md            # E2Eテスト
├── 2_test_tools/                 # テストツール
│   ├── 1_jest.md                 # Jest
│   └── 2_cypress_playwright.md   # Cypress/Playwright
└── 2_test_structure.md           # テストディレクトリ構造
```

## テスト戦略の概要

テスト戦略では、以下の要素を定義しています：

1. [テスト戦略の概要](./1_strategy.md) - テスト戦略の全体像
2. テストの種類
   - [単体テスト](./1_test_types/1_unit_tests.md) - 個々のコンポーネントや関数のテスト
   - [統合テスト](./1_test_types/2_integration_tests.md) - 複数のモジュールの連携テスト
   - [E2Eテスト](./1_test_types/3_e2e_tests.md) - アプリケーション全体の動作テスト
3. テストツール
   - [Jest](./2_test_tools/1_jest.md) - 単体・統合テスト用フレームワーク
   - [Cypress/Playwright](./2_test_tools/2_cypress_playwright.md) - E2Eテスト用フレームワーク
4. [テストディレクトリ構造](./2_test_structure.md) - テストコードの配置方法

## テストディレクトリ構造

プロジェクトのテストディレクトリ構造の詳細については、[テストディレクトリ構造](./2_test_structure.md)を参照してください。この文書では、テストコードの配置方法、命名規則、ディレクトリ構成などを定義しています。

