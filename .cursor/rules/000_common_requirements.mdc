---
description: 共通要件
globs: "src/**/*.{tsx,jsx,ts,js,md}"
alwaysApply: true
---
# 共通要件

# 共通技術スタック

> **注意:** コーディング規約については [4_Coding_Conventions.md](4_Coding_Conventions.md) を参照してください。ディレクトリ構造については [3_Directory_Structure.md](3_Directory_Structure.md) を参照してください。

## 前提条件

「お金をかけずに初心者が実装しやすい」方針を優先し、**無料で使えるモダンな技術スタック**を採用します。具体的には、以下の条件を満たす技術を選定します：

- 容易に経験の浅いエンジニアが実装できること
- 将来的な機能追加・スケーラビリティにも柔軟に対応できる構成
- フロントエンド + バックエンドを同一言語(TypeScript)で統一
- 最小限の手順でローカル開発を開始できる
- 本番環境にも無料枠でデプロイ可能

## 1. 言語選定

- **TypeScript 5.x**
  - **選定理由**:
    1. **静的型付け**によりコンパイル時のエラー検出が可能で、保守性を大きく向上する
    2. **JavaScriptとの高い互換性**があり、Reactなどのフロントエンドライブラリと自然に統合できる
    3. **広範なコミュニティ**と学習資源があり、初心者でも移行・導入がスムーズ
    4. **サーバレス/クラウド環境**（Vercel Functions など）と親和性が高く、Edge Functions の実装事例も充実
  - **バージョン**: TypeScript 5.1 以降
    - 新しいコンパイラ機能とパフォーマンス最適化が充実しており、型推論の質も向上

## 2. フレームワーク

- **Next.js 14 (React)**
  - **採用理由**:
    1. **SSR, SSG, ISR** など柔軟なレンダリング方式を公式サポートし、ベストプラクティスに沿った開発がしやすい
    2. [Vercel](https://vercel.com/) との組み合わせが非常にスムーズで、無料枠でのデプロイおよびプレビュー機能が充実
    3. TypeScript との相性が良く、公式テンプレート (`create-next-app`) で初期セットアップが簡単
    4. 大規模コミュニティがあり、学習リソースやプラグインが豊富
    5. App Router を採用（実装済み: Next.js 15.2.2）

## 3. コア技術

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Next.js | 14.x | フロントエンド＆バックエンドフレームワーク |
| TypeScript | 5.x | 型安全な開発言語 |
| Supabase | 最新 | データベース（PostgreSQL）、認証 |
| Vercel | 最新 | ホスティング、サーバレス関数 |

## 4. 開発環境

### コードエディタ

1. **Visual Studio Code**
   - 無料で高機能
   - 豊富な拡張機能
   - Git 連携が簡単
   - プロジェクト開発で使用中

2. **拡張機能**
   - ESLint: コード品質チェック（設定済み）
   - Prettier: コードフォーマット（設定済み）
   - Tailwind CSS IntelliSense: クラス補完
   - TypeScript 関連: 型チェックと補完

### 開発ツール

1. **ESLint**（実装済み: eslint.config.mjs）
   - コード品質の維持
   - エラーの早期発見
   - Next.js推奨設定を採用

2. **Prettier**
   - コードフォーマット
   - チーム内での一貫性確保
   - ESLintと連携

3. **TypeScript**（実装済み: tsconfig.json）
   - 型安全性
   - 自己文書化
   - エディタのサポートが充実
   - パスエイリアス設定済み（@/components など）

4. **Git / GitHub**
   - バージョン管理
   - コラボレーション
   - CI/CD 連携
   - プロジェクトで使用中

## 5. デプロイ

### ホスティングサービス

1. **Vercel**
   - Next.js との相性が最高
   - GitHub 連携で自動デプロイ
   - 無料枠が十分
   - プレビュー環境の自動生成

2. **Netlify**（代替）
   - 同様に使いやすい
   - フォーム機能などの追加機能

3. **GitHub Pages**（最小構成の場合）
   - 完全無料
   - 静的サイト向け

# 共通要件

## 概要

このドキュメントでは、DigeClipの共通要件を定義します。フロントエンドとバックエンドの両方に適用される要件を一元管理することで、要件の重複を避け、整合性を確保します。

## 1. エラーハンドリング

### エラー応答フォーマット

すべてのAPIエラーは以下の統一フォーマットで返却します：

```json
{
  "error": {
    "code": "E400",
    "message": "ユーザーフレンドリーなエラーメッセージ",
    "details": {
      "field1": "フィールド固有のエラーメッセージ",
      "field2": "フィールド固有のエラーメッセージ"
    }
  }
}
```

### エラーコード体系

- **E4xx**: クライアントエラー
  - E400: バリデーションエラー
  - E401: 認証エラー
  - E403: 権限エラー
  - E404: リソース未発見
  - E409: リソース競合
  - E429: リクエスト数制限超過

- **E5xx**: サーバーエラー
  - E500: 内部サーバーエラー
  - E503: サービス利用不可

### ログ記録

- すべてのエラーは適切なログレベルで記録する
- 本番環境ではスタックトレースをクライアントに返さない
- 重大なエラーは管理者に通知する仕組みを実装する

### ユーザー向けエラー表示

- ユーザーに対して、具体的で理解しやすいエラーメッセージを表示する
  - エラーメッセージはユーザーの行動をガイドする内容とし、解決策を提示
- ネットワークエラーやバリデーションエラーを適切にキャッチし、ユーザーに通知する
  - エラー発生時には、ポップアップやトースト通知を用いて即座にユーザーに知らせる
- ユーザーがエラー発生時に再試行できるオプションを提供し、操作の継続を支援する
  - 再試行ボタンを設置し、ユーザーが簡単に操作をやり直せるようにする

## 2. セキュリティ

### 認証・認可

- JWTベースの認証を実装
- ロールベースのアクセス制御（RBAC）を実装
- セッションタイムアウトは24時間
- 機密性の高い操作には再認証を要求

### データ保護

- 個人情報は暗号化して保存
- パスワードはbcryptでハッシュ化
- APIキーなどの機密情報は環境変数で管理
- データベース接続情報は適切に保護

### 入力検証

- すべてのユーザー入力は適切にバリデーション
- SQLインジェクション対策としてプリペアドステートメントを使用
- XSS対策としてユーザー入力をエスケープ
- CSRF（クロスサイトリクエストフォージェリ）対策として、トークンを用いたリクエスト検証を行う
  - 各リクエストにCSRFトークンを付与し、正当性を確認

### 通信セキュリティ

- セキュアな通信（HTTPS）を必須とし、データの盗聴や改ざんを防ぐ
  - すべての通信をHTTPSで暗号化し、セキュリティを強化
- セッション管理を強化し、一定時間の非操作で自動的にログアウトするタイムアウト設定を行う
  - セッションの有効期限を設定し、セキュリティリスクを低減

## 3. パフォーマンス

### レスポンス時間

- APIレスポンスは95%のリクエストで500ms以内
- 長時間実行される処理は非同期で実行
- 重いクエリはキャッシュを活用

### スケーラビリティ

- ステートレスなAPI設計
- 水平スケーリングを考慮した設計
- データベースインデックスを適切に設定

### リソース最適化

- 画像の最適化と遅延読み込みを実装し、初期ロード時間を短縮する
  - 画像はWebP形式を優先し、適切なサイズに最適化
  - viewport外の画像はLazy Loadingを適用
- コードの分割（Code Splitting）を行い、必要な機能のみを初期ロード時に読み込む
  - ルートベースのコード分割を実装し、ページごとに必要なコードのみ読み込み
  - 共通コンポーネントは共有チャンクとして抽出
- キャッシュ戦略を導入し、再訪問時のロード時間を短縮する
  - 静的アセットには適切なCache-Controlヘッダーを設定
  - Service Workerを使用したオフラインサポートを検討

## 4. テスト要件

### テスト種別

- 単体テスト: 個々の関数やクラスの動作を検証
- 統合テスト: コンポーネント間の連携を検証
- E2Eテスト: エンドツーエンドの動作を検証

### テストカバレッジ

- コアビジネスロジックは80%以上のカバレッジ
- 重要なAPIエンドポイントは100%カバレッジ

### 自動テスト

- CIパイプラインでの自動テスト実行
- テスト環境の自動セットアップ

## 5. アクセシビリティ

- キーボード操作をサポートし、すべてのインタラクティブ要素にフォーカス可能にする
  - タブキーでのナビゲーションをスムーズにし、フォーカスインジケーターを明確に表示
- スクリーンリーダーでの読み上げに対応し、視覚障害者が情報を取得できるようにする
  - 重要な情報には適切なラベルを付与し、スクリーンリーダーでの理解を助ける
- WCAG 2.1に準拠した適切なコントラスト比を確保し、視認性を向上させる
  - テキストと背景のコントラストを高め、すべてのユーザーにとって読みやすいデザインを提供
- ARIA属性を適切に適用し、補助技術が要素の意味を正しく理解できるようにする
  - ARIAロールやプロパティを用いて、インターフェースの意味を明確に伝える

## 6. 国際化対応

- すべてのテキストリソースを外部化し、多言語対応を容易にする
  - next-intlやreact-i18nextなどのライブラリを使用
  - 言語切り替え機能をUIに実装
- 日時表示はユーザーのロケールに合わせて最適化する
  - Intl.DateTimeFormatを活用し、地域に適した日時フォーマットを表示
- RTL（右から左）言語のサポートを考慮したレイアウト設計を行う
  - CSSの論理プロパティ（margin-inline-startなど）を使用
- 数値や通貨のフォーマットをロケールに応じて調整する
  - Intl.NumberFormatを使用して適切な桁区切りや小数点を表示

# 共通ディレクトリ構造

このドキュメントでは、プロジェクト全体で使用する標準的なディレクトリ構造を定義します。この構造に従うことで、コードの一貫性と可読性を確保し、新しいメンバーがプロジェクトに参加する際の学習コストを低減します。

## Next.jsプロジェクトの標準ディレクトリ構造

```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  └─ /config                       # 設定ファイル
      ├─ constants.ts              # 定数定義
      ├─ routes.ts                 # ルート定義
      └─ ...
```

## ディレクトリ構造の原則

1. **関心の分離**
   - 機能ごとに明確に分離されたディレクトリ構造
   - コンポーネント、ロジック、データアクセスの分離

2. **階層的な整理**
   - 関連するファイルは同じディレクトリにグループ化
   - 深すぎる階層は避け、必要に応じて平坦化

3. **命名規則**
   - ディレクトリ名は機能や目的を明確に表す
   - コンポーネントファイルはパスカルケース（例：`Button.tsx`）
   - ユーティリティやフックはキャメルケース（例：`useAuth.ts`）

4. **モジュール化**
   - 各ディレクトリには `index.ts` ファイルを配置して、外部からのインポートを簡素化
   - 関連するファイルをまとめてエクスポート

## 特記事項

- この構造は初心者でも理解しやすいように設計されています
- Next.js の最新推奨構成に従いつつ、初心者でも迷いにくいフォルダ数に留めています
- プロジェクトの成長に合わせて、必要に応じて構造を拡張できます

# コーディング規約

このドキュメントでは、プロジェクト全体で適用されるコーディング規約を定義します。これらの規約に従うことで、コードの一貫性と可読性を確保し、チーム開発をスムーズに進めることができます。

## 基本方針

「お金をかけずに初心者が実装しやすい」方針を優先し、厳密すぎるルールは設定しません。最低限の Lint/Formatter を導入し、シンプルな規約を設けます。

## 命名規則

- **ファイル名**:
  - コンポーネント: パスカルケース (例: `Button.tsx`, `UserProfile.jsx`)
  - ユーティリティ/サービス: キャメルケース (例: `apiClient.ts`, `userService.js`)
  - 定数/設定ファイル: キャメルケース (例: `config.ts`, `constants.js`)

- **変数/関数**:
  - キャメルケースで統一 (例: `getUserData`, `fetchItems`)
  - プライベート変数/関数の先頭にはアンダースコアを付ける (例: `_privateMethod`)

- **クラス/インターフェース/型**:
  - パスカルケースで統一 (例: `UserService`, `ApiResponse`)

- **定数**:
  - 大文字のスネークケースで統一 (例: `MAX_RETRY_COUNT`, `API_BASE_URL`)

- **コンポーネントprops**:
  - キャメルケースで統一 (例: `onClick`, `userData`)

- **CSSクラス名**:
  - Tailwind ユーティリティを使用するため、命名は最小限
  - カスタムクラスが必要な場合は、ケバブケースを使用 (例: `user-card`, `nav-item`)

## コメント

- 複雑なロジックには必ずコメントを付ける
- JSDoc形式でAPI関数にはドキュメントコメントを記述
- コメントは「何をしているか」ではなく「なぜそうしているか」を説明する

```typescript
// 良い例
// ユーザーが非アクティブの場合はキャッシュから除外する
if (user.isActive) {
  cache.set(user.id, user);
}

// 悪い例
// ユーザーをキャッシュに設定
if (user.isActive) {
  cache.set(user.id, user);
}
```

## コード構造

- 関数は単一責任の原則に従い、一つのことだけを行うようにする
- 関数の長さは画面の高さ（約30行）を超えないようにする
- ネストは3レベル以上深くならないようにする
- 早期リターンを活用して、ネストを減らす

```typescript
// 良い例
function processUser(user) {
  if (!user) return null;
  if (!user.isActive) return { error: 'User is not active' };

  // メイン処理
  return transformUser(user);
}

// 悪い例
function processUser(user) {
  if (user) {
    if (user.isActive) {
      // メイン処理
      return transformUser(user);
    } else {
      return { error: 'User is not active' };
    }
  } else {
    return null;
  }
}
```

## エラーハンドリング

- try/catchブロックを適切に使用する
- エラーメッセージは具体的かつユーザーフレンドリーにする
- エラーはログに記録し、必要に応じてモニタリングシステムに通知する

## インポート順序

1. 外部ライブラリ
2. 内部モジュール（相対パスではないもの）
3. 相対パスでのインポート

```typescript
// 外部ライブラリ
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

// 内部モジュール
import { Button } from '@/components/ui';
import { useAuth } from '@/hooks';

// 相対パスでのインポート
import { UserCard } from '../UserCard';
import styles from './styles.module.css';
```

## Lint / Formatter

1. **ESLint**
   - Next.js プロジェクト作成時に自動設定されることが多い
   - "extends: next/core-web-vitals" などを採用

2. **Prettier**
   - コードフォーマット統一
   - コミット時に自動整形 (husky + lint-staged など追加可)

## 型定義（TypeScript）

- `any`型の使用は最小限に抑える
- 共通の型は`/types`ディレクトリに定義
- 関数の引数と戻り値には必ず型を指定する
- ジェネリック型を適切に活用する

```typescript
// 良い例
function getUser<T extends User>(id: string): Promise<T | null> {
  // ...
}

// 悪い例
function getUser(id) {
  // ...
}
```

## まとめ

これらの規約は、コードの品質を維持しながらも、初心者が参加しやすい環境を作るために設計されています。プロジェクトの進行に合わせて、必要に応じて規約を更新していきます。

# テスト戦略

## 概要

このドキュメントでは、DigeClipプロジェクトにおける共通のテスト戦略と方針を定義します。テストは品質保証の重要な要素であり、バグの早期発見、コードの信頼性向上、および安全なリファクタリングを可能にします。

## 1. テストの目的

- **品質保証**: 機能が期待通りに動作することを確認
- **回帰テスト**: 新機能追加や変更による既存機能への影響を検出
- **ドキュメント**: テストはコードの使用方法を示す生きたドキュメントとしても機能
- **設計改善**: テスト駆動開発（TDD）を通じて、より良い設計を促進

## 2. テストレベル

### 2.1 単体テスト (Unit Tests)

- **対象**: 個々の関数、メソッド、コンポーネント
- **目的**: 最小単位の機能が正しく動作することを確認
- **特徴**: 外部依存を持たない、または依存をモック化して実行
- **カバレッジ目標**: 重要なビジネスロジックに対して80%以上

### 2.2 統合テスト (Integration Tests)

- **対象**: 複数のモジュール間の連携
- **目的**: コンポーネント間の相互作用が正しく機能することを確認
- **特徴**: 実際の依存関係を使用するが、外部サービスはモック化する場合もある
- **カバレッジ目標**: 主要な統合ポイントをカバー

### 2.3 エンドツーエンドテスト (E2E Tests)

- **対象**: アプリケーション全体のフロー
- **目的**: 実際のユーザー操作シナリオが正しく機能することを確認
- **特徴**: 実際のブラウザとバックエンドを使用
- **カバレッジ目標**: 重要なユーザーフローをカバー

## 3. テスト環境

### 3.1 ローカル開発環境

- 開発者のローカルマシンで実行
- 単体テストと一部の統合テストを実行
- 迅速なフィードバックループを提供

### 3.2 CI/CD環境

- GitHub Actionsを使用
- すべてのPRに対して自動テストを実行
- テストカバレッジレポートを生成

### 3.3 ステージング環境

- 本番に近い環境でE2Eテストを実行
- パフォーマンステストも実施

## 4. テストデータ管理

### 4.1 テストデータの原則

- テストは独立して実行できるべき
- テストデータは自己完結的であるべき
- 機密データをテストに使用しない

### 4.2 テストデータ生成

- ファクトリーパターンを使用
- ランダムデータ生成ライブラリの活用
- シード値を使用して再現性を確保

### 4.3 テストデータベース

- インメモリデータベースまたはテスト用のコンテナを使用
- テスト前に状態をリセット
- マイグレーションスクリプトを活用

## 5. モック戦略

### 5.1 モックの使用原則

- 外部依存（API、データベース、サードパーティサービス）をモック化
- 遅い処理や非決定的な処理をモック化
- モックは実際の動作を忠実に再現すべき

### 5.2 モックツール

- Jest モック機能
- MSW (Mock Service Worker) for API モック
- Sinon.js（必要に応じて）

## 6. 共通テスト規約

### 6.1 命名規則

- テストファイル: `[対象ファイル名].test.[拡張子]` または `[対象ファイル名].spec.[拡張子]`
- テスト関数: `it('should [期待される動作]', () => { ... })`
- テストスイート: `describe('[テスト対象]', () => { ... })`

### 6.2 テスト構造

- Arrange-Act-Assert (AAA) パターンを使用
  - Arrange: テストの前提条件を設定
  - Act: テスト対象の機能を実行
  - Assert: 結果を検証

### 6.3 テストカバレッジ

- Jest カバレッジレポートを使用
- ステートメント、ブランチ、関数のカバレッジを測定
- 重要なビジネスロジックは高いカバレッジを目指す

## 7. 継続的インテグレーション

### 7.1 CI/CDパイプライン

- プルリクエスト時に自動テスト実行
- マージ前にすべてのテストが成功することを要求
- テストカバレッジレポートを生成・保存

### 7.2 テスト実行の最適化

- テストの並列実行
- テストキャッシュの活用
- 変更されたファイルに関連するテストのみを実行

## 8. テスト自動化ツール

### 8.1 共通ツール

- **Jest**: JavaScript/TypeScriptのテストフレームワーク
- **React Testing Library**: Reactコンポーネントのテスト
- **Supertest**: HTTPリクエストのテスト
- **Cypress**: E2Eテスト

### 8.2 コード品質ツール

- **ESLint**: コードスタイルとバグの検出
- **Prettier**: コードフォーマット
- **TypeScript**: 型チェック

## 9. テストドキュメント

### 9.1 テストドキュメントの目的

- テスト戦略の共有
- テスト実行方法の説明
- テスト結果の解釈方法

### 9.2 ドキュメント内容

- テスト実行コマンド
- テスト環境のセットアップ手順
- テスト結果の解釈方法
- よくある問題のトラブルシューティング

## 10. 責任分担

- **開発者**: 単体テストと統合テストの作成・実行
- **QAエンジニア**: E2Eテストの作成・実行、手動テスト
- **テックリード**: テスト戦略の策定、コードレビュー
- **全員**: 品質に対する責任を共有

