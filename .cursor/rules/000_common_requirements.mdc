---
description: 共通要件
globs: ["**/*.{tsx,jsx,ts,js,md}"]
alwaysApply: false
---
# 共通要件

## 1_common_requirements/1_technology_stack.md

# 共通技術スタック

> **注意:** コーディング規約については [4_Coding_Conventions.md](4_Coding_Conventions.md) を参照してください。ディレクトリ構造については [3_Directory_Structure.md](3_Directory_Structure.md) を参照してください。

## 前提条件

「お金をかけずに初心者が実装しやすい」方針を優先し、**無料で使えるモダンな技術スタック**を採用します。具体的には、以下の条件を満たす技術を選定します：

- 容易に経験の浅いエンジニアが実装できること
- 将来的な機能追加・スケーラビリティにも柔軟に対応できる構成
- フロントエンド + バックエンドを同一言語(TypeScript)で統一
- 最小限の手順でローカル開発を開始できる
- 本番環境にも無料枠でデプロイ可能

## 1. 言語選定

- **TypeScript 5.x**
  - **選定理由**:
    1. **静的型付け**によりコンパイル時のエラー検出が可能で、保守性を大きく向上する
    2. **JavaScriptとの高い互換性**があり、Reactなどのフロントエンドライブラリと自然に統合できる
    3. **広範なコミュニティ**と学習資源があり、初心者でも移行・導入がスムーズ
    4. **サーバレス/クラウド環境**（Vercel Functions など）と親和性が高く、Edge Functions の実装事例も充実
  - **バージョン**: TypeScript 5.1 以降
    - 新しいコンパイラ機能とパフォーマンス最適化が充実しており、型推論の質も向上

## 2. フレームワーク

- **Next.js 14 (React)**
  - **採用理由**:
    1. **SSR, SSG, ISR** など柔軟なレンダリング方式を公式サポートし、ベストプラクティスに沿った開発がしやすい
    2. [Vercel](https://vercel.com/) との組み合わせが非常にスムーズで、無料枠でのデプロイおよびプレビュー機能が充実
    3. TypeScript との相性が良く、公式テンプレート (`create-next-app`) で初期セットアップが簡単
    4. 大規模コミュニティがあり、学習リソースやプラグインが豊富
    5. App Router を採用（実装済み: Next.js 15.2.2）

## 3. コア技術

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Next.js | 14.x | フロントエンド＆バックエンドフレームワーク |
| TypeScript | 5.x | 型安全な開発言語 |
| Supabase | 最新 | データベース（PostgreSQL）、認証 |
| Vercel | 最新 | ホスティング、サーバレス関数 |

## 4. 開発環境

### コードエディタ

1. **Visual Studio Code**
   - 無料で高機能
   - 豊富な拡張機能
   - Git 連携が簡単
   - プロジェクト開発で使用中

2. **拡張機能**
   - ESLint: コード品質チェック（設定済み）
   - Prettier: コードフォーマット（設定済み）
   - Tailwind CSS IntelliSense: クラス補完
   - TypeScript 関連: 型チェックと補完

### 開発ツール

1. **ESLint**（実装済み: eslint.config.mjs）
   - コード品質の維持
   - エラーの早期発見
   - Next.js推奨設定を採用

2. **Prettier**
   - コードフォーマット
   - チーム内での一貫性確保
   - ESLintと連携

3. **TypeScript**（実装済み: tsconfig.json）
   - 型安全性
   - 自己文書化
   - エディタのサポートが充実
   - パスエイリアス設定済み（@/components など）

4. **Git / GitHub**
   - バージョン管理
   - コラボレーション
   - CI/CD 連携
   - プロジェクトで使用中

## 5. デプロイ

### ホスティングサービス

1. **Vercel**
   - Next.js との相性が最高
   - GitHub 連携で自動デプロイ
   - 無料枠が十分
   - プレビュー環境の自動生成

2. **Netlify**（代替）
   - 同様に使いやすい
   - フォーム機能などの追加機能

3. **GitHub Pages**（最小構成の場合）
   - 完全無料
   - 静的サイト向け

## 1_common_requirements/2_requirements.md

# 共通要件

## 概要

このドキュメントでは、DigeClipの共通要件を定義します。フロントエンドとバックエンドの両方に適用される要件を一元管理することで、要件の重複を避け、整合性を確保します。

## 1. エラーハンドリング

### エラー応答フォーマット

すべてのAPIエラーは以下の統一フォーマットで返却します：

```json
{
  "error": {
    "code": "E400",
    "message": "ユーザーフレンドリーなエラーメッセージ",
    "details": {
      "field1": "フィールド固有のエラーメッセージ",
      "field2": "フィールド固有のエラーメッセージ"
    }
  }
}
```

### エラーコード体系

- **E4xx**: クライアントエラー
  - E400: バリデーションエラー
  - E401: 認証エラー
  - E403: 権限エラー
  - E404: リソース未発見
  - E409: リソース競合
  - E429: リクエスト数制限超過

- **E5xx**: サーバーエラー
  - E500: 内部サーバーエラー
  - E503: サービス利用不可

### ログ記録

- すべてのエラーは適切なログレベルで記録する
- 本番環境ではスタックトレースをクライアントに返さない
- 重大なエラーは管理者に通知する仕組みを実装する

### ユーザー向けエラー表示

- ユーザーに対して、具体的で理解しやすいエラーメッセージを表示する
  - エラーメッセージはユーザーの行動をガイドする内容とし、解決策を提示
- ネットワークエラーやバリデーションエラーを適切にキャッチし、ユーザーに通知する
  - エラー発生時には、ポップアップやトースト通知を用いて即座にユーザーに知らせる
- ユーザーがエラー発生時に再試行できるオプションを提供し、操作の継続を支援する
  - 再試行ボタンを設置し、ユーザーが簡単に操作をやり直せるようにする

## 2. セキュリティ

### 認証・認可

- JWTベースの認証を実装
- ロールベースのアクセス制御（RBAC）を実装
- セッションタイムアウトは24時間
- 機密性の高い操作には再認証を要求

### データ保護

- 個人情報は暗号化して保存
- パスワードはbcryptでハッシュ化
- APIキーなどの機密情報は環境変数で管理
- データベース接続情報は適切に保護

### 入力検証

- すべてのユーザー入力は適切にバリデーション
- SQLインジェクション対策としてプリペアドステートメントを使用
- XSS対策としてユーザー入力をエスケープ
- CSRF（クロスサイトリクエストフォージェリ）対策として、トークンを用いたリクエスト検証を行う
  - 各リクエストにCSRFトークンを付与し、正当性を確認

### 通信セキュリティ

- セキュアな通信（HTTPS）を必須とし、データの盗聴や改ざんを防ぐ
  - すべての通信をHTTPSで暗号化し、セキュリティを強化
- セッション管理を強化し、一定時間の非操作で自動的にログアウトするタイムアウト設定を行う
  - セッションの有効期限を設定し、セキュリティリスクを低減

## 3. パフォーマンス

### レスポンス時間

- APIレスポンスは95%のリクエストで500ms以内
- 長時間実行される処理は非同期で実行
- 重いクエリはキャッシュを活用

### スケーラビリティ

- ステートレスなAPI設計
- 水平スケーリングを考慮した設計
- データベースインデックスを適切に設定

### リソース最適化

- 画像の最適化と遅延読み込みを実装し、初期ロード時間を短縮する
  - 画像はWebP形式を優先し、適切なサイズに最適化
  - viewport外の画像はLazy Loadingを適用
- コードの分割（Code Splitting）を行い、必要な機能のみを初期ロード時に読み込む
  - ルートベースのコード分割を実装し、ページごとに必要なコードのみ読み込み
  - 共通コンポーネントは共有チャンクとして抽出
- キャッシュ戦略を導入し、再訪問時のロード時間を短縮する
  - 静的アセットには適切なCache-Controlヘッダーを設定
  - Service Workerを使用したオフラインサポートを検討

## 4. テスト要件

### テスト種別

- 単体テスト: 個々の関数やクラスの動作を検証
- 統合テスト: コンポーネント間の連携を検証
- E2Eテスト: エンドツーエンドの動作を検証

### テストカバレッジ

- コアビジネスロジックは80%以上のカバレッジ
- 重要なAPIエンドポイントは100%カバレッジ

### 自動テスト

- CIパイプラインでの自動テスト実行
- テスト環境の自動セットアップ

## 5. アクセシビリティ

- キーボード操作をサポートし、すべてのインタラクティブ要素にフォーカス可能にする
  - タブキーでのナビゲーションをスムーズにし、フォーカスインジケーターを明確に表示
- スクリーンリーダーでの読み上げに対応し、視覚障害者が情報を取得できるようにする
  - 重要な情報には適切なラベルを付与し、スクリーンリーダーでの理解を助ける
- WCAG 2.1に準拠した適切なコントラスト比を確保し、視認性を向上させる
  - テキストと背景のコントラストを高め、すべてのユーザーにとって読みやすいデザインを提供
- ARIA属性を適切に適用し、補助技術が要素の意味を正しく理解できるようにする
  - ARIAロールやプロパティを用いて、インターフェースの意味を明確に伝える

## 6. 国際化対応

- すべてのテキストリソースを外部化し、多言語対応を容易にする
  - next-intlやreact-i18nextなどのライブラリを使用
  - 言語切り替え機能をUIに実装
- 日時表示はユーザーのロケールに合わせて最適化する
  - Intl.DateTimeFormatを活用し、地域に適した日時フォーマットを表示
- RTL（右から左）言語のサポートを考慮したレイアウト設計を行う
  - CSSの論理プロパティ（margin-inline-startなど）を使用
- 数値や通貨のフォーマットをロケールに応じて調整する
  - Intl.NumberFormatを使用して適切な桁区切りや小数点を表示

## 2_coding_conventions/1_conventions.md

# コーディング規約

このドキュメントでは、プロジェクト全体で適用されるコーディング規約を定義します。これらの規約に従うことで、コードの一貫性と可読性を確保し、チーム開発をスムーズに進めることができます。

## 基本方針

「お金をかけずに初心者が実装しやすい」方針を優先し、厳密すぎるルールは設定しません。最低限の Lint/Formatter を導入し、シンプルな規約を設けます。

## 命名規則

- **ファイル名**:
  - コンポーネント: パスカルケース (例: `Button.tsx`, `UserProfile.jsx`)
  - ユーティリティ/サービス: キャメルケース (例: `apiClient.ts`, `userService.js`)
  - 定数/設定ファイル: キャメルケース (例: `config.ts`, `constants.js`)

- **変数/関数**:
  - キャメルケースで統一 (例: `getUserData`, `fetchItems`)
  - プライベート変数/関数の先頭にはアンダースコアを付ける (例: `_privateMethod`)

- **クラス/インターフェース/型**:
  - パスカルケースで統一 (例: `UserService`, `ApiResponse`)

- **定数**:
  - 大文字のスネークケースで統一 (例: `MAX_RETRY_COUNT`, `API_BASE_URL`)

- **コンポーネントprops**:
  - キャメルケースで統一 (例: `onClick`, `userData`)

- **CSSクラス名**:
  - Tailwind ユーティリティを使用するため、命名は最小限
  - カスタムクラスが必要な場合は、ケバブケースを使用 (例: `user-card`, `nav-item`)

## コメント

- 複雑なロジックには必ずコメントを付ける
- JSDoc形式でAPI関数にはドキュメントコメントを記述
- コメントは「何をしているか」ではなく「なぜそうしているか」を説明する

```typescript
// 良い例
// ユーザーが非アクティブの場合はキャッシュから除外する
if (user.isActive) {
  cache.set(user.id, user);
}

// 悪い例
// ユーザーをキャッシュに設定
if (user.isActive) {
  cache.set(user.id, user);
}
```

## コード構造

- 関数は単一責任の原則に従い、一つのことだけを行うようにする
- 関数の長さは画面の高さ（約30行）を超えないようにする
- ネストは3レベル以上深くならないようにする
- 早期リターンを活用して、ネストを減らす

```typescript
// 良い例
function processUser(user) {
  if (!user) return null;
  if (!user.isActive) return { error: 'User is not active' };

  // メイン処理
  return transformUser(user);
}

// 悪い例
function processUser(user) {
  if (user) {
    if (user.isActive) {
      // メイン処理
      return transformUser(user);
    } else {
      return { error: 'User is not active' };
    }
  } else {
    return null;
  }
}
```

## エラーハンドリング

- try/catchブロックを適切に使用する
- エラーメッセージは具体的かつユーザーフレンドリーにする
- エラーはログに記録し、必要に応じてモニタリングシステムに通知する

## インポート順序

1. 外部ライブラリ
2. 内部モジュール（相対パスではないもの）
3. 相対パスでのインポート

```typescript
// 外部ライブラリ
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

// 内部モジュール
import { Button } from '@/components/ui';
import { useAuth } from '@/hooks';

// 相対パスでのインポート
import { UserCard } from '../UserCard';
import styles from './styles.module.css';
```

## Lint / Formatter

1. **ESLint**
   - Next.js プロジェクト作成時に自動設定されることが多い
   - "extends: next/core-web-vitals" などを採用

2. **Prettier**
   - コードフォーマット統一
   - コミット時に自動整形 (husky + lint-staged など追加可)

## 型定義（TypeScript）

- `any`型の使用は最小限に抑える
- 共通の型は`/types`ディレクトリに定義
- 関数の引数と戻り値には必ず型を指定する
- ジェネリック型を適切に活用する

```typescript
// 良い例
function getUser<T extends User>(id: string): Promise<T | null> {
  // ...
}

// 悪い例
function getUser(id) {
  // ...
}
```

## テストコードのディレクトリ構造

テストコードは以下のディレクトリ構造に従って配置します：

```
/src
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /openai.ts                # OpenAI関連機能
  │   ├─ /discord.ts               # Discord関連機能
  │   ├─ /supabase.ts              # Supabase関連機能
  │   └─ /__tests__                # libディレクトリのテスト
  │       ├─ /openai.test.ts       # OpenAIのテスト
  │       ├─ /discord.test.ts      # Discordのテスト
  │       └─ /supabase.test.ts     # Supabaseのテスト
  │
  ├─ /components                   # コンポーネント
  │   ├─ /ui                       # UIコンポーネント
  │   └─ /__tests__                # コンポーネントのテスト
  │       └─ /ui                   # UIコンポーネントのテスト
  │
  ├─ /app                          # Next.jsのApp Router
  │   └─ /__tests__                # アプリケーションのテスト
  │
  └─ /__tests__                    # 全体的なテスト
      ├─ /utils                    # テスト用ユーティリティ
      ├─ /e2e                      # E2Eテスト
      └─ /integration              # 統合テスト
```

### テストファイルの命名規則

- 単体テスト: `*.test.ts` または `*.test.tsx`
- 統合テスト: `*.test.ts` または `*.integration.test.ts`
- E2Eテスト: `*.spec.ts` または `*.e2e.spec.ts`

### テストコードの構造

テストコードは以下の構造に従って記述します：

```typescript
// 1. インポート
import { functionToTest } from '../path/to/function';
import { mockData } from '../../__tests__/utils/test-utils';

// 2. モックの設定（必要な場合）
jest.mock('../path/to/dependency', () => ({
  dependencyFunction: jest.fn(),
}));

// 3. テストスイート
describe('functionToTest', () => {
  // 4. 前処理
  beforeEach(() => {
    // テスト前の準備
  });

  // 5. 後処理
  afterEach(() => {
    // テスト後のクリーンアップ
    jest.clearAllMocks();
  });

  // 6. テストケース
  it('正常系: 期待通りの結果を返すこと', () => {
    // テストコード
    const result = functionToTest(mockData);
    expect(result).toEqual(expectedResult);
  });

  it('異常系: エラーがスローされること', () => {
    // テストコード
    expect(() => functionToTest(invalidData)).toThrow();
  });
});
```

## まとめ

これらの規約は、コードの品質を維持しながらも、初心者が参加しやすい環境を作るために設計されています。プロジェクトの進行に合わせて、必要に応じて規約を更新していきます。

## 3_directory_structure/1_structure.md

# 共通ディレクトリ構造

このドキュメントでは、プロジェクト全体で使用する標準的なディレクトリ構造を定義します。この構造に従うことで、コードの一貫性と可読性を確保し、新しいメンバーがプロジェクトに参加する際の学習コストを低減します。

## Next.jsプロジェクトの標準ディレクトリ構造

```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  ├─ /config                       # 設定ファイル
  │   ├─ constants.ts              # 定数定義
  │   ├─ routes.ts                 # ルート定義
  │   └─ ...
  │
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

## ディレクトリ構造の原則

1. **関心の分離**
   - 機能ごとに明確に分離されたディレクトリ構造
   - コンポーネント、ロジック、データアクセスの分離

2. **階層的な整理**
   - 関連するファイルは同じディレクトリにグループ化
   - 深すぎる階層は避け、必要に応じて平坦化

3. **命名規則**
   - ディレクトリ名は機能や目的を明確に表す
   - コンポーネントファイルはパスカルケース（例：`Button.tsx`）
   - ユーティリティやフックはキャメルケース（例：`useAuth.ts`）
   - テストファイルは対象ファイル名に `.test.ts(x)` を付与（例：`Button.test.tsx`）

4. **モジュール化**
   - 各ディレクトリには `index.ts` ファイルを配置して、外部からのインポートを簡素化
   - 関連するファイルをまとめてエクスポート

## テストディレクトリ構造の原則

1. **ソースコード構造との対応**
   - テストディレクトリ構造はソースコードの構造を反映
   - 各テストファイルは対応するソースファイルと同じ名前パターンを使用

2. **テスト種類による分離**
   - 単体テスト、統合テスト、E2Eテストは明確に分離
   - 各テスト種類に適した構造とツールを使用

3. **共通リソースの共有**
   - テスト用ユーティリティとモックは再利用可能なよう共通ディレクトリに配置
   - テスト間の重複を最小限に抑える

## 特記事項

- この構造は初心者でも理解しやすいように設計されています
- Next.js の最新推奨構成に従いつつ、初心者でも迷いにくいフォルダ数に留めています
- プロジェクトの成長に合わせて、必要に応じて構造を拡張できます
- テストはJest、React Testing Library、MSW、Cypressなどのツールを使用して実装します

## 4_test_strategy/1_strategy.md

# テスト戦略

このドキュメントでは、プロジェクト全体のテスト戦略を定義します。テスト戦略は、アプリケーションの品質を確保し、バグを早期に発見するために重要です。

## テストの種類

プロジェクトでは、以下の3種類のテストを実施します：

1. **単体テスト (Unit Tests)**
   - 個々の関数やコンポーネントが期待通りに動作することを確認する
   - 詳細: [単体テスト](./1_test_types/1_unit_tests.md)

2. **統合テスト (Integration Tests)**
   - 複数のモジュールやコンポーネントが連携して正しく動作することを確認する
   - 詳細: [統合テスト](./1_test_types/2_integration_tests.md)

3. **E2Eテスト (End-to-End Tests)**
   - アプリケーション全体が実際のユーザーシナリオに沿って正しく動作することを確認する
   - 詳細: [E2Eテスト](./1_test_types/3_e2e_tests.md)

## テストピラミッド

テストの量と実行頻度は、テストピラミッドに従って設計します：

```
    /\
   /  \
  /E2E \
 /------\
/統合テスト\
/----------\
/  単体テスト \
/--------------\
```

- **単体テスト**: 最も多く、最も頻繁に実行する
- **統合テスト**: 中程度の量と頻度
- **E2Eテスト**: 最も少なく、最も頻度が低い

## テストツール

プロジェクトでは、以下のテストツールを使用します：

1. **Jest**
   - 単体テストと統合テストに使用
   - 詳細: [Jest](./2_test_tools/1_jest.md)

2. **React Testing Library**
   - Reactコンポーネントのテストに使用
   - Jestと組み合わせて使用

3. **Cypress / Playwright**
   - E2Eテストに使用
   - 詳細: [Cypress と Playwright](./2_test_tools/2_cypress_playwright.md)

## テストディレクトリ構造

テストコードは、以下のディレクトリ構造に従って配置します：

```
/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](./2_test_structure.md)を参照してください。

## テスト実行

テストは、以下のコマンドで実行します：

```bash
# すべてのテストを実行
npm test

# 単体テストのみ実行
npm run test:unit

# 統合テストのみ実行
npm run test:integration

# E2Eテストのみ実行
npm run test:e2e

# テストカバレッジを計測
npm run test:coverage
```

## CI/CDとの統合

テストは、CI/CDパイプラインに統合します：

1. **プルリクエスト時**
   - 単体テストと統合テストを実行
   - テストカバレッジを計測

2. **メインブランチへのマージ時**
   - 単体テスト、統合テスト、E2Eテストを実行
   - テストカバレッジを計測

3. **デプロイ前**
   - すべてのテストが成功していることを確認

## テストカバレッジ

テストカバレッジは、以下の基準を目標とします：

- **単体テスト**
  - 関数/メソッド: 80%以上
  - 分岐カバレッジ: 70%以上
  - 行カバレッジ: 75%以上

- **統合テスト**
  - 主要な機能フロー: 90%以上

- **E2Eテスト**
  - 重要なユーザーフロー: 100%

## テスト環境

テストは、以下の環境で実行します：

1. **ローカル開発環境**
   - 開発者のマシン上で実行
   - 単体テストと統合テストを実行

2. **CI環境**
   - GitHub Actionsなどで実行
   - すべてのテストを実行

3. **ステージング環境**
   - 本番環境に近い環境で実行
   - E2Eテストを実行

## テストデータ

テストデータは、以下の方針で管理します：

1. **モックデータ**
   - 単体テストと統合テストで使用
   - `src/__tests__/utils/test-utils.ts` に定義

2. **テスト用データベース**
   - 統合テストとE2Eテストで使用
   - 本番環境とは別のデータベースを使用

3. **フィクスチャ**
   - E2Eテストで使用
   - `src/__tests__/e2e/fixtures/` に配置

## テスト作成のガイドライン

1. **テストファーストの原則**
   - 可能な限り、コードを書く前にテストを書く
   - TDD (Test-Driven Development) の考え方を取り入れる

2. **テストの独立性**
   - 各テストは独立して実行できるようにする
   - テスト間の依存関係を作らない

3. **テストの可読性**
   - テストは明確で理解しやすいものにする
   - テストケースは具体的な動作を検証する

4. **テストの保守性**
   - テストコードも本番コードと同様に保守する
   - リファクタリングの際はテストも更新する

## 1_test_types/1_unit_tests.md

# 単体テスト

単体テストは、個々の関数やコンポーネントが期待通りに動作することを確認するためのテストです。

## 目的

- 個々の関数やコンポーネントが仕様通りに動作することを確認する
- バグの早期発見と修正を容易にする
- リファクタリングの安全性を確保する
- コードの品質を維持する

## テスト対象

- ユーティリティ関数 (`src/lib/`)
- カスタムフック (`src/hooks/`)
- UIコンポーネント (`src/components/`)
- APIルート (`src/app/api/`)

## ディレクトリ構造

単体テストは、`src/__tests__/unit` ディレクトリに配置します。テストの構造はソースコードの構造を反映します。

```
/src
  └─ /__tests__                    # テストコード
      └─ /unit                     # 単体テスト
          ├─ /components           # コンポーネントの単体テスト
          │   ├─ /ui               # UIコンポーネント
          │   │   ├─ Button.test.tsx
          │   │   └─ ...
          │   ├─ /layout           # レイアウトコンポーネント
          │   └─ /features         # 機能別コンポーネント
          ├─ /hooks                # カスタムフックのテスト
          │   ├─ useAuth.test.ts
          │   └─ ...
          ├─ /lib                  # ユーティリティのテスト
          │   ├─ /services         # サービスのテスト
          │   ├─ /utils            # ユーティリティのテスト
          │   └─ ...
          └─ /context              # コンテキストのテスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象ファイル名].test.ts` または `[対象ファイル名].test.tsx`
- テストスイート: `describe('[関数名/コンポーネント名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 各テストは独立して実行できるようにする
2. テストは明確で理解しやすいものにする
3. テストケースは具体的な動作を検証する
4. モックは必要最小限にする

### 関数のテスト

```typescript
// src/lib/__tests__/openai.test.ts
import { generateText } from '../openai';
import { mockEnv } from '../../__tests__/utils/test-utils';

// 環境変数のモック
mockEnv({
  OPENAI_API_KEY: 'test-api-key',
});

describe('generateText', () => {
  it('正常系: テキストを生成できること', async () => {
    // テストコード
    const result = await generateText('テストプロンプト');
    expect(result).toBeDefined();
    expect(typeof result).toBe('string');
  });

  it('異常系: APIキーがない場合はエラーをスローすること', async () => {
    // 環境変数を一時的に上書き
    const originalEnv = process.env.OPENAI_API_KEY;
    process.env.OPENAI_API_KEY = '';

    // テストコード
    await expect(generateText('テストプロンプト')).rejects.toThrow();

    // 環境変数を元に戻す
    process.env.OPENAI_API_KEY = originalEnv;
  });
});
```

### コンポーネントのテスト

```typescript
// src/components/__tests__/ui/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../../ui/Button';

describe('Button', () => {
  it('ボタンがレンダリングされること', () => {
    render(<Button>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeInTheDocument();
  });

  it('クリックイベントが発火すること', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>テスト</Button>);
    const button = screen.getByText('テスト');
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('disabled属性が適用されること', () => {
    render(<Button disabled>テスト</Button>);
    const button = screen.getByText('テスト');
    expect(button).toBeDisabled();
  });
});
```

## テストカバレッジ

単体テストは、以下の基準を目標とします：

- 関数/メソッド: 80%以上
- 分岐カバレッジ: 70%以上
- 行カバレッジ: 75%以上

ただし、これらの数値は目安であり、コードの重要度や複雑さに応じて調整します。

## 1_test_types/2_integration_tests.md

# 統合テスト

統合テストは、複数のモジュールやコンポーネントが連携して正しく動作することを確認するためのテストです。

## 目的

- 複数のモジュール間の連携が正しく機能することを確認する
- 単体テストでは検出できない、モジュール間のインターフェースの問題を発見する
- 実際の環境に近い状態でのテストを行う

## テスト対象

- APIエンドポイントとデータベースの連携
- フロントエンドコンポーネントとバックエンドAPIの連携
- 複数のサービス間の連携

## ディレクトリ構造

統合テストは、`src/__tests__/integration` ディレクトリに配置します。

```
/src
  └─ /__tests__
      └─ /integration              # 統合テスト
          ├─ /api                  # API統合テスト
          │   ├─ auth.test.ts
          │   └─ ...
          ├─ /services             # サービス統合テスト
          └─ /features             # 機能結合テスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象機能].test.ts` または `[対象機能].integration.test.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 実際の依存関係を使用する（モックは最小限に）
2. テスト環境を適切に設定する
3. テストデータは自己完結的に用意する
4. テスト後は環境をクリーンアップする

### APIとデータベースの統合テスト

```typescript
// src/__tests__/integration/api/content.test.ts
import { createClient } from '@supabase/supabase-js';
import { createContent, getContent } from '../../../lib/content';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('Content API 統合テスト', () => {
  let supabase;
  let testContentId;

  beforeAll(async () => {
    // テスト用のSupabaseクライアントを作成
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );

    // テストデータをクリーンアップ
    await supabase.from('contents').delete().eq('title', 'テスト用コンテンツ');
  });

  afterAll(async () => {
    // テストデータをクリーンアップ
    if (testContentId) {
      await supabase.from('contents').delete().eq('id', testContentId);
    }
  });

  it('コンテンツを作成して取得できること', async () => {
    // コンテンツを作成
    const newContent = {
      title: 'テスト用コンテンツ',
      body: 'これはテスト用のコンテンツです。',
    };

    const { data: createdContent, error: createError } = await createContent(newContent);
    expect(createError).toBeNull();
    expect(createdContent).toBeDefined();
    expect(createdContent.title).toBe(newContent.title);

    testContentId = createdContent.id;

    // 作成したコンテンツを取得
    const { data: retrievedContent, error: getError } = await getContent(testContentId);
    expect(getError).toBeNull();
    expect(retrievedContent).toBeDefined();
    expect(retrievedContent.id).toBe(testContentId);
    expect(retrievedContent.title).toBe(newContent.title);
  });
});
```

### フロントエンドとバックエンドの統合テスト

```typescript
// src/__tests__/integration/services/content.test.ts
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ContentForm } from '../../../components/ContentForm';
import { mockEnv } from '../../utils/test-utils';

// 環境変数のモック
mockEnv({
  NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
});

describe('ContentForm 統合テスト', () => {
  it('フォーム送信時にコンテンツが作成されること', async () => {
    // モックサーバーのセットアップ（MSWなどを使用）
    // ...

    // コンポーネントをレンダリング
    render(<ContentForm />);

    // フォームに入力
    await userEvent.type(screen.getByLabelText('タイトル'), 'テスト用コンテンツ');
    await userEvent.type(screen.getByLabelText('本文'), 'これはテスト用のコンテンツです。');

    // フォームを送信
    await userEvent.click(screen.getByText('保存'));

    // 結果を確認
    await waitFor(() => {
      expect(screen.getByText('コンテンツが保存されました')).toBeInTheDocument();
    });
  });
});
```

## テスト環境

統合テストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **モックサーバー**
   - 外部APIとの通信をモック化（必要に応じて）
   - [MSW (Mock Service Worker)](https://mswjs.io/) などのツールを使用

3. **テスト用環境変数**
   - `.env.test` ファイルを用意
   - テスト用の認証情報を設定

## 1_test_types/3_e2e_tests.md

# E2Eテスト

E2Eテスト（エンドツーエンドテスト）は、アプリケーション全体が実際のユーザーシナリオに沿って正しく動作することを確認するためのテストです。

## 目的

- 実際のユーザーの操作シナリオを模倣し、アプリケーション全体が正しく機能することを確認する
- フロントエンドとバックエンドの統合、データベースとの連携など、システム全体の動作を検証する
- 本番環境に近い状態でのテストを行う

## テスト対象

- ユーザーフロー（ログイン、コンテンツ作成、検索など）
- 画面遷移
- データの永続化
- エラーハンドリング

## ディレクトリ構造

E2Eテストは、`src/__tests__/e2e` ディレクトリに配置します。

```
/src
  └─ /__tests__
      └─ /e2e                      # E2Eテスト
          ├─ /auth                 # 認証関連E2Eテスト
          │   ├─ login.test.ts
          │   └─ ...
          ├─ /contents             # コンテンツ関連E2Eテスト
          │   ├─ contentList.test.ts
          │   └─ ...
          └─ /settings             # 設定関連E2Eテスト
```

詳細なテストディレクトリ構造については、[テストディレクトリ構造](../2_test_structure.md)を参照してください。

## テスト命名規則

- テストファイル: `[対象機能].spec.ts` または `[対象機能].e2e.spec.ts`
- テストスイート: `describe('[機能名]', () => { ... })`
- テストケース: `it('[期待する動作]', () => { ... })` または `test('[期待する動作]', () => { ... })`

## テスト作成のガイドライン

### 一般的なガイドライン

1. 重要なユーザーフローに焦点を当てる
2. テストは独立して実行できるようにする
3. テストデータは自己完結的に用意する
4. テスト環境をテスト前に適切に設定し、テスト後にクリーンアップする

### Cypressを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/login.spec.ts
describe('ログインフロー', () => {
  beforeEach(() => {
    // テスト前の準備
    cy.visit('/login');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインフォームに入力
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ログイン成功メッセージが表示されることを確認
    cy.contains('ログインに成功しました').should('be.visible');
  });

  it('無効な認証情報でログインできないこと', () => {
    // ログインフォームに無効な認証情報を入力
    cy.get('input[name="email"]').type('invalid@example.com');
    cy.get('input[name="password"]').type('wrongpassword');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ログインページに留まることを確認
    cy.url().should('include', '/login');

    // エラーメッセージが表示されることを確認
    cy.contains('メールアドレスまたはパスワードが正しくありません').should('be.visible');
  });
});
```

### Playwrightを使用したE2Eテスト

```typescript
// src/__tests__/e2e/flows/content.spec.ts
import { test, expect } from '@playwright/test';

test.describe('コンテンツ作成フロー', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // ダッシュボードに移動したことを確認
    await expect(page).toHaveURL(/.*dashboard/);
  });

  test('新しいコンテンツを作成できること', async ({ page }) => {
    // 新規作成ページに移動
    await page.click('text=新規作成');
    await expect(page).toHaveURL(/.*create/);

    // フォームに入力
    await page.fill('input[name="title"]', 'テスト用コンテンツ');
    await page.fill('textarea[name="body"]', 'これはテスト用のコンテンツです。');

    // 保存ボタンをクリック
    await page.click('button:has-text("保存")');

    // 保存成功メッセージが表示されることを確認
    await expect(page.locator('text=コンテンツが保存されました')).toBeVisible();

    // コンテンツ一覧に作成したコンテンツが表示されることを確認
    await page.goto('/dashboard');
    await expect(page.locator('text=テスト用コンテンツ')).toBeVisible();
  });
});
```

## テスト環境

E2Eテストでは、以下の環境を使用します：

1. **テスト用データベース**
   - 本番環境とは別のテスト用データベースを使用
   - テスト前後にデータをクリーンアップ

2. **テスト用サーバー**
   - ローカル開発サーバーまたはステージング環境を使用

3. **テスト用ブラウザ**
   - 複数のブラウザでテストを実行（Chrome, Firefox, Safari など）
   - モバイルデバイスのエミュレーションも考慮

## テスト実行方法

```bash
# Cypressを使用する場合
npm run test:e2e

# Playwrightを使用する場合
npm run test:e2e:playwright
```

## 4_test_strategy/2_test_structure.md

# テストディレクトリ構造

このドキュメントでは、プロジェクトのテストに関するディレクトリ構造を定義します。適切なテストディレクトリ構造を持つことで、テストの管理と実行が容易になり、コードの品質を確保できます。

## テストディレクトリの基本構造

テストコードは、以下のディレクトリ構造に従って配置します：

```
/src
  └─ /__tests__                    # テストコード
      ├─ /unit                     # 単体テスト
      │   ├─ /components           # コンポーネントの単体テスト
      │   │   ├─ /ui               # UIコンポーネント
      │   │   │   ├─ Button.test.tsx
      │   │   │   └─ ...
      │   │   ├─ /layout           # レイアウトコンポーネント
      │   │   └─ /features         # 機能別コンポーネント
      │   ├─ /hooks                # カスタムフックのテスト
      │   │   ├─ useAuth.test.ts
      │   │   └─ ...
      │   ├─ /lib                  # ユーティリティのテスト
      │   │   ├─ /services         # サービスのテスト
      │   │   ├─ /utils            # ユーティリティのテスト
      │   │   └─ ...
      │   └─ /context              # コンテキストのテスト
      │
      ├─ /integration              # 統合テスト
      │   ├─ /api                  # API統合テスト
      │   │   ├─ auth.test.ts
      │   │   └─ ...
      │   ├─ /services             # サービス統合テスト
      │   └─ /features             # 機能結合テスト
      │
      ├─ /e2e                      # E2Eテスト
      │   ├─ /auth                 # 認証関連E2Eテスト
      │   │   ├─ login.test.ts
      │   │   └─ ...
      │   ├─ /contents             # コンテンツ関連E2Eテスト
      │   │   ├─ contentList.test.ts
      │   │   └─ ...
      │   └─ /settings             # 設定関連E2Eテスト
      │
      ├─ /utils                    # テスト用ユーティリティ
      │   ├─ test-utils.ts         # テスト共通ユーティリティ
      │   ├─ renderWithProviders.tsx # プロバイダ付きのレンダリングヘルパー
      │   └─ ...
      │
      └─ /mocks                    # モックデータとハンドラー
          ├─ /data                 # モックデータ
          │   ├─ sources.ts
          │   ├─ contents.ts
          │   └─ ...
          ├─ /handlers             # MSWリクエストハンドラー
          │   ├─ auth.ts
          │   └─ ...
          └─ /server.ts            # MSWサーバー設定
```

ルートディレクトリには以下の設定ファイルも配置します：

```
/
├─ jest.config.js                # Jest設定
├─ jest.setup.js                 # Jestセットアップ
└─ playwright.config.ts          # Playwright設定（E2Eテスト用）
```

## テストの種類別の構造

### 単体テスト（Unit Tests）

単体テストは、個々のコンポーネント、関数、フックなどの小さな単位をテストします。

- **テストツール**: Jest + React Testing Library
- **ディレクトリ**: `/__tests__/unit/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: ソースコードの構造を反映する

### 統合テスト（Integration Tests）

統合テストは、複数のコンポーネントや機能が連携して正しく動作することを確認します。

- **テストツール**: Jest + React Testing Library + MSW
- **ディレクトリ**: `/__tests__/integration/`
- **ファイル命名規則**: `*.test.ts` または `*.test.tsx`
- **構造原則**: 機能ごとにグループ化する

### E2Eテスト（End-to-End Tests）

E2Eテストは、実際のユーザーシナリオに沿ってアプリケーション全体が正しく動作することを確認します。

- **テストツール**: Playwright または Cypress
- **ディレクトリ**: `/__tests__/e2e/`
- **ファイル命名規則**: `*.test.ts`
- **構造原則**: ユーザーフローごとにグループ化する

## サポートディレクトリ

### ユーティリティ（Utils）

テスト間で共有される便利な関数やヘルパーを提供します。

- **ディレクトリ**: `/__tests__/utils/`
- **内容**:
  - `test-utils.ts`: 共通ヘルパー関数
  - `renderWithProviders.tsx`: プロバイダー付きのコンポーネントレンダリング
  - カスタムマッチャーなど

### モック（Mocks）

テストで使用するモックデータとリクエストハンドラーを定義します。

- **ディレクトリ**: `/__tests__/mocks/`
- **内容**:
  - `/data/`: モックデータオブジェクト
  - `/handlers/`: MSWリクエストハンドラー
  - `server.ts`: MSWサーバー設定

## テストファイルの配置原則

1. **単体テスト**:
   - テスト対象のソースコードと同じ構造を反映
   - 例：`/components/ui/Button.tsx` → `/__tests__/unit/components/ui/Button.test.tsx`

2. **統合テスト**:
   - 機能やモジュールの連携に焦点を当てた構造
   - 例：認証フロー全体をテスト → `/__tests__/integration/auth/authFlow.test.tsx`

3. **E2Eテスト**:
   - ユーザーストーリーやユースケースに基づく構造
   - 例：ログインフロー → `/__tests__/e2e/auth/login.test.ts`

## テストディレクトリ構造の利点

1. **明確な分離**: テストの種類ごとに明確に分離することで、テストの目的と範囲が明確になる
2. **容易な実行**: 特定の種類のテストのみを実行することが容易
3. **構造の一貫性**: ソースコードの構造を反映することで、テストファイルの場所が予測しやすくなる
4. **再利用性**: ユーティリティとモックを共有することで、コードの重複を減らす

## テスト関連設定ファイル

### Jest設定（jest.config.js）

```javascript
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/_*.{js,jsx,ts,tsx}',
    '!src/**/index.{js,jsx,ts,tsx}',
  ],
};
```

### Jest設定（jest.setup.js）

```javascript
import '@testing-library/jest-dom';
import { server } from './src/__tests__/mocks/server';

// MSWのセットアップ
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### Playwright設定（playwright.config.ts）

```typescript
import { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './src/__tests__/e2e',
  use: {
    baseURL: 'http://localhost:3000',
    headless: true,
    viewport: { width: 1280, height: 720 },
    screenshot: 'only-on-failure',
  },
  reporter: [['html', { outputFolder: 'playwright-report' }]],
};

export default config;
```

## テスト実行コマンド

以下のコマンドをpackage.jsonに追加します：

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=src/__tests__/unit",
    "test:integration": "jest --testPathPattern=src/__tests__/integration",
    "test:e2e": "playwright test",
    "test:coverage": "jest --coverage"
  }
}
```

## まとめ

この構造に従うことで、テストの管理と実行が容易になり、コードの品質を確保できます。テストディレクトリ構造は、プロジェクトの成長に合わせて柔軟に拡張できます。

## 2_test_tools/1_jest.md

# Jest

Jestは、JavaScriptのテストフレームワークで、単体テストと統合テストに使用します。

## 設定

プロジェクトでは、以下の設定でJestを使用します：

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/_*.{js,jsx,ts,tsx}',
    '!src/**/index.{js,jsx,ts,tsx}',
  ],
  testMatch: ['**/__tests__/**/*.test.ts?(x)', '**/?(*.)+(test).ts?(x)'],
};
```

## セットアップファイル

```javascript
// jest.setup.js
// テスト実行前の環境設定
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://example.supabase.co';
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
process.env.OPENAI_API_KEY = 'test-api-key';
```

```javascript
// jest.setup.afterEnv.js
// テスト実行後の環境設定
import '@testing-library/jest-dom';

// グローバルなモックのセットアップ
jest.mock('next/router', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    query: {},
  }),
}));
```

## テスト実行

```bash
# すべてのテストを実行
npm test

# 特定のテストファイルを実行
npm test -- path/to/test.test.ts

# 単体テストのみ実行
npm run test:unit

# 統合テストのみ実行
npm run test:integration

# E2Eテストのみ実行
npm run test:e2e

# テストカバレッジを計測
npm run test:coverage
```

## マッチャー

Jestでは、以下のマッチャーを使用してアサーションを行います：

```typescript
// 値の検証
expect(value).toBe(expected);        // 厳密等価性（===）
expect(value).toEqual(expected);     // 深い等価性
expect(value).toBeDefined();         // undefined でないこと
expect(value).toBeNull();            // null であること
expect(value).toBeTruthy();          // truthy であること
expect(value).toBeFalsy();           // falsy であること

// 数値の検証
expect(value).toBeGreaterThan(expected);
expect(value).toBeLessThan(expected);
expect(value).toBeCloseTo(expected, numDigits);

// 文字列の検証
expect(string).toMatch(/pattern/);
expect(string).toContain(substring);

// 配列の検証
expect(array).toContain(item);
expect(array).toHaveLength(length);

// オブジェクトの検証
expect(object).toHaveProperty(keyPath, value);

// 例外の検証
expect(() => { throw new Error() }).toThrow();
expect(() => { throw new Error('message') }).toThrow('message');

// 非同期コードの検証
await expect(promise).resolves.toBe(value);
await expect(promise).rejects.toThrow();
```

## モック

Jestでは、以下の方法でモックを作成します：

```typescript
// 関数のモック
const mockFn = jest.fn();
mockFn.mockReturnValue(value);
mockFn.mockResolvedValue(value);
mockFn.mockRejectedValue(error);

// モジュールのモック
jest.mock('./path/to/module', () => ({
  functionName: jest.fn(),
}));

// スパイ
const spy = jest.spyOn(object, 'method');
```

## テストの構造

```typescript
// グループ化
describe('グループ名', () => {
  // 前処理
  beforeAll(() => {
    // テスト前の準備（1回のみ）
  });

  beforeEach(() => {
    // 各テスト前の準備
  });

  // テストケース
  it('テスト名', () => {
    // テストコード
  });

  test('テスト名', () => {
    // テストコード
  });

  // 後処理
  afterEach(() => {
    // 各テスト後のクリーンアップ
  });

  afterAll(() => {
    // テスト後のクリーンアップ（1回のみ）
  });
});
```

## React Testing Library

Reactコンポーネントのテストには、React Testing Libraryを使用します：

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '../Button';

describe('Button', () => {
  it('ボタンがレンダリングされること', () => {
    render(<Button>テスト</Button>);

    // テキストでの要素取得
    const button = screen.getByText('テスト');
    expect(button).toBeInTheDocument();

    // ロールでの要素取得
    const buttonByRole = screen.getByRole('button', { name: 'テスト' });
    expect(buttonByRole).toBeInTheDocument();
  });

  it('クリックイベントが発火すること', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>テスト</Button>);

    // fireEventを使用したイベント発火
    const button = screen.getByText('テスト');
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);

    // userEventを使用したイベント発火（より実際のユーザー操作に近い）
    userEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(2);
  });

  it('非同期処理の結果が表示されること', async () => {
    render(<AsyncComponent />);

    // ボタンをクリック
    userEvent.click(screen.getByText('データを取得'));

    // 非同期処理の完了を待機
    await waitFor(() => {
      expect(screen.getByText('データ取得完了')).toBeInTheDocument();
    });
  });
});
```

## 2_test_tools/2_cypress_playwright.md

# Cypress と Playwright

E2Eテストには、CypressとPlaywrightを使用します。どちらも強力なE2Eテストツールですが、用途に応じて使い分けます。

## Cypress

Cypressは、モダンなWebアプリケーションのE2Eテストに特化したツールです。

### 設定

```javascript
// cypress.config.js
const { defineConfig } = require('cypress');

module.exports = defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'src/__tests__/e2e/**/*.test.{js,jsx,ts,tsx}',
    supportFile: 'src/__tests__/e2e/support/e2e.ts',
    setupNodeEvents(on, config) {
      // イベントリスナーの設定
    },
  },
  env: {
    // 環境変数
    apiUrl: 'http://localhost:3000/api',
  },
  viewportWidth: 1280,
  viewportHeight: 720,
});
```

### ディレクトリ構造

```
/src
  └─ /__tests__
      └─ /e2e
          ├─ /flows           # ユーザーフロー別のテスト
          │   ├─ login.spec.ts
          │   └─ content.spec.ts
          ├─ /fixtures        # テストデータ
          │   └─ users.json
          ├─ /support         # ヘルパー関数
          │   ├─ commands.ts
          │   └─ e2e.ts
          └─ /utils           # ユーティリティ
              └─ selectors.ts
```

### テスト例

```typescript
// src/__tests__/e2e/flows/login.spec.ts
describe('ログインフロー', () => {
  beforeEach(() => {
    // テスト前の準備
    cy.visit('/login');
  });

  it('有効な認証情報でログインできること', () => {
    // ログインフォームに入力
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');

    // ログインボタンをクリック
    cy.get('button[type="submit"]').click();

    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard');

    // ログイン成功メッセージが表示されることを確認
    cy.contains('ログインに成功しました').should('be.visible');
  });
});
```

### カスタムコマンド

```typescript
// src/__tests__/e2e/support/commands.ts
Cypress.Commands.add('login', (email, password) => {
  cy.visit('/login');
  cy.get('input[name="email"]').type(email);
  cy.get('input[name="password"]').type(password);
  cy.get('button[type="submit"]').click();
  cy.url().should('include', '/dashboard');
});

// 使用例
it('ログイン後にコンテンツを作成できること', () => {
  cy.login('test@example.com', 'password123');
  // 以降のテストコード
});
```

### テスト実行

```bash
# Cypressを開く
npx cypress open

# ヘッドレスモードでテストを実行
npx cypress run

# 特定のテストファイルを実行
npx cypress run --spec "src/__tests__/e2e/flows/login.spec.ts"
```

## Playwright

Playwrightは、複数のブラウザをサポートするE2Eテストツールです。

### 設定

```typescript
// playwright.config.ts
import { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './src/__tests__/e2e',
  testMatch: '**/*.spec.ts',
  use: {
    baseURL: 'http://localhost:3000',
    headless: true,
    viewport: { width: 1280, height: 720 },
    screenshot: 'only-on-failure',
    video: 'on-first-retry',
  },
  projects: [
    {
      name: 'Chrome',
      use: { browserName: 'chromium' },
    },
    {
      name: 'Firefox',
      use: { browserName: 'firefox' },
    },
    {
      name: 'Safari',
      use: { browserName: 'webkit' },
    },
  ],
};

export default config;
```

### ディレクトリ構造

```
/src
  └─ /__tests__
      └─ /e2e
          ├─ /flows           # ユーザーフロー別のテスト
          │   ├─ login.spec.ts
          │   └─ content.spec.ts
          ├─ /fixtures        # テストデータ
          │   └─ users.json
          ├─ /utils           # ユーティリティ
          │   └─ selectors.ts
          └─ /pages           # ページオブジェクト
              ├─ login.page.ts
              └─ dashboard.page.ts
```

### テスト例

```typescript
// src/__tests__/e2e/flows/content.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage } from '../pages/login.page';
import { DashboardPage } from '../pages/dashboard.page';

test.describe('コンテンツ作成フロー', () => {
  let loginPage;
  let dashboardPage;

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
    dashboardPage = new DashboardPage(page);

    // ログイン
    await loginPage.goto();
    await loginPage.login('test@example.com', 'password123');
    await expect(page).toHaveURL(/.*dashboard/);
  });

  test('新しいコンテンツを作成できること', async ({ page }) => {
    // 新規作成ページに移動
    await dashboardPage.clickNewContent();
    await expect(page).toHaveURL(/.*create/);

    // フォームに入力
    await page.fill('input[name="title"]', 'テスト用コンテンツ');
    await page.fill('textarea[name="body"]', 'これはテスト用のコンテンツです。');

    // 保存ボタンをクリック
    await page.click('button:has-text("保存")');

    // 保存成功メッセージが表示されることを確認
    await expect(page.locator('text=コンテンツが保存されました')).toBeVisible();
  });
});
```

### ページオブジェクトパターン

```typescript
// src/__tests__/e2e/pages/login.page.ts
import { Page } from '@playwright/test';

export class LoginPage {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async goto() {
    await this.page.goto('/login');
  }

  async login(email: string, password: string) {
    await this.page.fill('input[name="email"]', email);
    await this.page.fill('input[name="password"]', password);
    await this.page.click('button[type="submit"]');
  }
}
```

### テスト実行

```bash
# すべてのテストを実行
npx playwright test

# 特定のテストファイルを実行
npx playwright test src/__tests__/e2e/flows/login.spec.ts

# UIモードでテストを実行
npx playwright test --ui

# 特定のブラウザでテストを実行
npx playwright test --project=Chrome
```

## Cypress と Playwright の使い分け

### Cypressの利点

- 直感的なUIとデバッグ機能
- 自動リトライ機能
- 豊富なプラグインエコシステム
- 優れたドキュメント

### Playwrightの利点

- 複数のブラウザをサポート（Chrome, Firefox, Safari）
- モバイルエミュレーション
- 高速な実行
- 並列実行のサポート

### 使い分けの指針

- **Cypress**: 単一ブラウザでのテストや、チーム内にCypressの経験者がいる場合
- **Playwright**: 複数ブラウザでのテストや、パフォーマンスが重要な場合

## 共通のベストプラクティス

1. **ページオブジェクトパターンを使用する**
   - テストコードとページの詳細を分離する
   - 再利用性と保守性を向上させる

2. **データ駆動テストを活用する**
   - 同じテストを異なるデータセットで実行する
   - テストケースの網羅性を向上させる

3. **安定したセレクタを使用する**
   - データ属性（`data-testid`など）を使用する
   - CSSクラスやIDに依存しない

4. **テスト環境を適切に設定する**
   - テスト用データベースを使用する
   - テスト前後にデータをクリーンアップする

## 4_test_strategy/README.md

# テスト戦略

このディレクトリには、プロジェクトのテスト戦略に関するドキュメントが含まれています。

## ドキュメント構造

```
/rules/0_common/4_test_strategy/
├── README.md                     # このファイル
├── 1_strategy.md                 # テスト戦略の概要
├── 1_test_types/                 # テストの種類
│   ├── 1_unit_tests.md           # 単体テスト
│   ├── 2_integration_tests.md    # 統合テスト
│   └── 3_e2e_tests.md            # E2Eテスト
├── 2_test_tools/                 # テストツール
│   ├── 1_jest.md                 # Jest
│   └── 2_cypress_playwright.md   # Cypress/Playwright
└── 2_test_structure.md           # テストディレクトリ構造
```

## テスト戦略の概要

テスト戦略では、以下の要素を定義しています：

1. [テスト戦略の概要](./1_strategy.md) - テスト戦略の全体像
2. テストの種類
   - [単体テスト](./1_test_types/1_unit_tests.md) - 個々のコンポーネントや関数のテスト
   - [統合テスト](./1_test_types/2_integration_tests.md) - 複数のモジュールの連携テスト
   - [E2Eテスト](./1_test_types/3_e2e_tests.md) - アプリケーション全体の動作テスト
3. テストツール
   - [Jest](./2_test_tools/1_jest.md) - 単体・統合テスト用フレームワーク
   - [Cypress/Playwright](./2_test_tools/2_cypress_playwright.md) - E2Eテスト用フレームワーク
4. [テストディレクトリ構造](./2_test_structure.md) - テストコードの配置方法

## テストディレクトリ構造

プロジェクトのテストディレクトリ構造の詳細については、[テストディレクトリ構造](./2_test_structure.md)を参照してください。この文書では、テストコードの配置方法、命名規則、ディレクトリ構成などを定義しています。

