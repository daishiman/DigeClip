---
description: 開発プロセス
globs: ["**/__tests__/**/*.{tsx,ts}", "**/lib/utils/**/*.ts", "**/scripts/**/*.ts"]
alwaysApply: false
---
# 開発プロセス

## 5_development_process/1_Agile_Approach.md

```markdown
# アジャイル開発の進め方 (最新版)

> **方針**
> - **経験の浅いエンジニア**でも、**短期間**で開発プロセスを回せるようにする
> - **無料ツール/サービス**を活用し、最小限のコストで **スクラム/カンバンのエッセンス** を導入
> - **継続的な改善**により、システム拡張や新機能追加に柔軟対応

---

## 1. 開発手法

1. **スクラム + カンバン** のハイブリッド
   - スプリント単位の計画・レビューは **Scrum** を参考に実施
   - 日々のタスク管理は **カンバンボード**（GitHub Projects や Trello など）で可視化
   - 継続的フィードバックと短いリリースサイクルを重視

2. **作業単位**
   - 1つの**ユーザーストーリー** or **タスク** をなるべく **1〜2日** で完了可能な規模へ分割
   - 経験の浅いエンジニアでも進捗が見えやすく、リードタイムが短縮

3. **ツール**
   - バックログ管理: **GitHub Issues/Projects** or **Trello**
   - コミュニケーション: **Slack / Discord** (無料プラン)
   - ドキュメント: **GitHub Wiki** or **Notion**

---

## 2. スプリント計画

1. **スプリント期間**
   - **1〜2週間** スプリントを推奨
   - 小さなリリースを重ねて、**フィードバックを素早く反映**

2. **バックログ管理手法**
   - **プロダクトバックログ**: 新規機能や改善案を登録（優先度を付ける）
   - **スプリントバックログ**: スプリント期間内に対応予定のタスクを選出
   - 進行中 / 完了したタスクはカンバンボードでステータスを更新

3. **ポイント見積もり (任意)**
   - 経験が浅い場合、ざっくり「S(1日程度) / M(1〜3日) / L(1週間)」などの見積もり
   - 進捗状況を把握し、**見積もり誤差**が大きい場合に調整

---

## 3. デイリースクラム

1. **開催時間**
   - 毎日 or 隔日 朝10分程度
   - オンライン(Discord/Slack 通話)でOK、無料ツールを活用

2. **進捗共有内容**
   - **昨日やったこと**
   - **今日やること**
   - **困っていること（ブロッカー）**

3. **所要時間**
   - **1回あたり5〜10分** 以内
   - タスクの詳細議論は別途ミーティング（デイリー終了後にブレイクアウト）で行う

---

## 4. スプリントレビュー & レトロスペクティブ

1. **スプリントレビュー**
   - **成果物デモ**: 開発機能を実際に動かしてメンバーやステークホルダーへ披露
   - **フィードバック**: 改善点や追加要望をヒアリング
   - レビュー結果は**プロダクトバックログ**へ反映し、優先度を再検討

2. **レトロスペクティブ**
   - **よかったこと / 問題点 / 改善案** をメンバー全員で話し合う
   - 改善案は**次のスプリント**へ取り入れる（例：タスク分割の方法改善、コミュニケーション頻度調整など）
   - 所要時間目安: **30分〜1時間**

---

## 5. 継続的インテグレーション (CI)

1. **ビルド/テスト/通知の流れ**
   - **GitHub + Vercel** を活用し、**プルリクエスト** 発行時に自動ビルド＋簡易テスト
   - テスト失敗やLintエラー時は GitHub上でステータス確認＆Slack/Discord通知
   - メインブランチへマージ後、**Vercelが自動デプロイ** → ステージング/本番環境が更新

2. **テスト内容**
   - **ユニットテスト** (Jest/React Testing Libraryなど) でコンポーネントとロジックを確認
   - **E2Eテスト** (Cypress/Playwright など) は最低限の操作フローをカバー
   - **Lint/Formatter** (ESLint, Prettier) でコード規約統一

3. **運用規模が拡大したら**
   - **より詳細な自動テスト** (UIテスト, Visual Regression等) を検討
   - **パフォーマンステスト** (負荷試験) も組み込み、CI内で定期的に実行

---

### まとめ

- スプリントを **1〜2週間** で回し、小刻みにリリース
- デイリー（5〜10分）で進捗とブロッカーを素早く共有
- **スクラムレビュー / レトロ** で常に改善サイクルを回す
- **CI (GitHub + Vercel)** を構築し、Pull Request 単位で自動ビルド＆テスト
- 初期は簡単な単体テストやLint中心、拡張時にE2Eや負荷テストを追加
- 小規模チーム＆無償ツールで運用し、必要に応じてエンタープライズ向け機能に移行しやすい構成とする

以上のアジャイル開発の進め方により、**経験の浅いエンジニア**でも **短いスプリント**で徐々に成長しながら**システムを拡張**していくことが可能となります。必要に応じて**スプリント期間やツール**を調整し、**段階的に開発プロセスを強化**してください。
```

## 5_development_process/2_Priority_Management.md

```markdown
# 要件の優先度管理（MoSCoW方式）

> **前提**
> - お金をかけずに、容易に経験の浅いエンジニアが実装できることを最優先
> - 必須（Must）要件をまず実装し、Should/ Could は余力で徐々に拡張
> - 将来的に追加しやすい構成・拡張性を常に意識

---

## 1. Must（必須要件）

1. **YouTubeチャンネル監視機能**
   - 毎時RSS取得し、新着動画を検知
   - 字幕・サムネイルを DB に保存し、通知や要約に活用
2. **外部コンテンツ監視機能**
   - arXiv / ブログ RSS から新着記事を検知
   - OGP 画像/抄録/本文などを保存
3. **マルチAIモデル要約（単一ステップ）**
   - 1つのステップ(例: 概要要約のみ) で十分
   - GPT-3.5等の無料クレジットや安価なAPIを想定
4. **Discord通知機能**
   - Embed形式でサムネ＋タイトル＋リンク＋要約を送信
   - Webhook設定（Token管理）
5. **認証・認可(最小限)**
   - Google OAuth + JWT（Email+パスワード）
   - ロール: admin / user
6. **コンテンツ一覧＆詳細画面**
   - タグ付与、絞り込み検索、要約比較（単一ステップの場合は1種のみ）
   - ページネーション
7. **管理画面（基本）**
   - ソース追加/編集/削除（YouTube, RSS）
   - AIモデル設定（API Key暗号化, デフォルトモデル指定）
   - 通知設定（Discord Webhook）
8. **定期実行（Vercel Cron）**
   - 毎時実行ジョブで新着検出→要約→通知
   - 動作ログを簡易保存（DB, Supabase Logs など）
9. **段階的な運用ドキュメント**
   - 初期導入ガイド（1週間以内導入を目標）
   - 主要API一覧、環境変数設定手順

---

## 2. Should（時間が許せば実装したい要件）

1. **複数ステップ要約（概要→見出し→詳細）**
   - 要約を段階的に生成し、比較・閲覧
   - トークン使用量が増えるため、コスト検討
2. **複数AIモデル同時比較**
   - GPT-4, Claude, Gemini等からそれぞれの要約をDBに保存して比較表示
3. **ユーザー管理拡張**
   - ユーザー招待機能、ロールの細分化（guest / user / editor / admin）
   - メール認証（送信先メールに確認リンクを送る）
4. **OGP取得の最適化**
   - メタタグ スクレイピング or Puppeteer等でサムネイル・本文抽出を自動化
   - 失敗時のリトライやキャッシュ
5. **UI/UX向上**
   - ダッシュボードにチャートや統計情報
   - テーマ切り替え（ダークモード等）
   - キーボードショートカット

---

## 3. Could（余裕があれば実装する要件）

1. **翻訳機能**
   - 英語等の要約を日本語に変換、逆も可能
   - DeepL API や Google Translate API などを検討
2. **Slack / Teams / Email 通知**
   - Discord以外の通知先を追加
   - 同様のEmbed(またはリッチメッセージ)形式に対応
3. **高度な検索フィルタ**
   - 日付範囲、キーワード検索、タグのAND/OR指定
   - 要約のワードクラウド表示 etc.
4. **モバイル/PWA対応**
   - スマホアプリっぽいUI、オフラインキャッシュ
   - プッシュ通知連携
5. **高負荷対策（大規模拡張）**
   - Supabase 有料プラン移行
   - Edge NetworkやCDN活用、DBレプリケーション

---

## 4. Won’t（今回のスコープ外）

1. **大企業向け SSO / SAML 認証**
   - 現状の範囲では必要性が低いため見送り
   - 有料プランや専門知識が必要
2. **自動翻訳の多言語要約**
   - 先に単一言語の要約機能を安定させる
   - 翻訳は将来的にCould要件として検討
3. **モバイルネイティブアプリ**
   - Webアプリだけで十分運用可能
   - 将来の要望があればPWAやReactNativeを検討
4. **大規模スケーリング (CDN, 負荷分散)**
   - 需要が増大するまではVercel無料枠+Supabase無料枠で十分
   - 必要に応じて有料プランへ移行

---

### まとめ

- **Must**: 基本的な監視・要約・通知・閲覧機能を短期間（1週間以内）で構築 → MVP完成
- **Should**: 多段階要約や複数AI比較など、ユーザー利便性を高める機能
- **Could**: 翻訳やSlack通知、モバイル対応など後日拡張機能
- **Won’t**: 現段階では必要性が低い高度機能（大企業向けSSO、多言語要約、ネイティブアプリ化など）

経験の浅いエンジニアでも、**Mustの範囲**を最優先に取り組むことで**短期間**でリリースが可能。後から **Should/ Could** の要件を徐々に追加するアジャイル的手法が望ましいです。
```

## 5_development_process/3_Documentation_and_Communication.md

```markdown
# ドキュメント管理・コミュニケーション

> **前提**
> - お金をかけずに、経験の浅いエンジニアでもスムーズに**短期間**で開発を進められるようにする
> - 将来的な拡張や新メンバーの参加を考慮し、**ドキュメント管理・情報共有**をシンプルかつ拡張しやすく整備

---

## 1. ドキュメントの分類

本プロジェクトで扱う主なドキュメントを以下のように分類します。

1. **要件定義書 (Requirements)**
   - 例: 「YouTubeおよび外部コンテンツ情報収集・要約システム 要件定義書」
   - システムの目的や範囲、機能一覧、優先度、成功基準などを記載
   - **誰向け**: プロダクトオーナー・開発チーム全員

2. **設計書 (Design)**
   - 画面設計書, API設計書, データベース設計書など
   - **詳細設計要素**: テーブルスキーマ、APIの入出力仕様、画面UIワイヤーフレーム 等
   - **誰向け**: エンジニア・デザイナ

3. **運用マニュアル (Operations)**
   - 運用手順・トラブルシューティング・Cron/バックアップなどの定期処理手順
   - 監視観点/ログ確認方法、バージョンアップ時の手順
   - **誰向け**: 運用担当者, オンコール担当

4. **開発ガイドライン (Guidelines)**
   - コーディング規約, ブランチ命名ルール, コミットメッセージ形式, Lint/Formatter設定 等
   - **誰向け**: 全エンジニア

5. **リリースノート (Release Notes)**
   - 各バージョンで追加/変更された機能、バグ修正点など
   - ユーザー向けのリリース告知も兼ねる
   - **誰向け**: 全メンバー（特に関係者）

6. **その他**
   - Q&A, FAQ 集, チュートリアル, アーキテクチャ図, インフラ構成図 など
   - 必要に応じて Wiki/Notion/GitHub Pages 等で追加

---

## 2. 更新手順

1. **更新トリガー**
   - 要件変更、スプリントの結果、レビューでの指摘、トラブル発生 → ドキュメント修正
   - 新機能実装・リリース時 → リリースノート更新
   - 運用フロー追加 → 運用マニュアル追記

2. **編集・レビュー・承認プロセス (例)**
   1. **編集**: ドキュメントをエディタ（MarkDown, Google Docs 等）で編集
   2. **Pull Request**: GitHub リポジトリ管理の場合、PRを作成して差分を確認
   3. **レビュー**: チームメンバーが内容を確認、修正コメントを付与
   4. **承認/マージ**: 内容問題なければマージし、最新版を反映
   5. **告知**: Slack などで「ドキュメント更新のお知らせ」

3. **ドキュメント配置**
   - **GitHubリポジトリ** の `docs/` フォルダなどに配置 → バージョン管理
   - あるいは **Notion / Confluence / Wiki** に同等の内容を反映
   - **運用担当** が更新しやすい仕組み（GUI編集ツール等）が望ましい

---

## 3. チャット / プロジェクト管理ツール

> **低コスト & 習熟しやすい** ツール選択を重視

1. **チャットツール**
   - **Slack** (無料プラン) が定番
   - チャンネル例: `#general` (全体連絡), `#dev` (技術相談), `#alerts` (エラー通知), `#random`
   - Googleアカウントでもログイン可能

2. **タスク管理 / チケット管理**
   - **GitHub Projects** or **Trello**
   - シンプルなカンバンボード形式 → 経験の浅いエンジニアでも直感的に使える
   - Issue と紐づけることで状況把握が容易

3. **Wiki / Documentation**
   - **GitHub Wiki** や **Notion**
   - 要件定義書や運用マニュアル等、**Markdown** で管理 → Pull Request レビュー
   - メンバーが増えた場合、Notion 等で WYSIWYG 編集も検討

4. **アラート / 通知**
   - **Slack** へ自動通知 (GitHub Actions, Sentry, Supabaseイベント etc.)
   - 運用負荷を下げるため、警告レベル・本番障害レベルなど優先度のフィルタ設定

---

## 4. 会議体・議事録

1. **定例会議 (Weekly or Bi-Weekly)**
   - **参加者**: PM, リードエンジニア, 必要に応じて全チーム
   - **目的**: 進捗共有, 課題/リスク確認, 次スプリント計画の調整
   - **時間**: 30分～1時間

2. **デイリースクラム (任意)**
   - 毎朝15分程度、担当タスクの進捗やブロッカーを共有
   - 小規模チームなら Slack で簡易報告でもOK

3. **議事録テンプレ**
   - **日時 / 参加者 / 目的**
   - **議題1…** + 決定事項 / ToDo
   - **次回アクション**  (担当者・期限)
   - 保管先: GitHub Wiki or Google Drive / Notion など

4. **スプリントレビュー & レトロスペクティブ** (アジャイルの場合)
   - **スプリントレビュー**: 完了した機能のデモ, フィードバック, 次スプリントへの要件整理
   - **レトロスペクティブ**: 改善点洗い出し (プロセス, コミュニケーション, ツールなど)

---

### まとめ

- ドキュメントは **GitHubリポジトリ** や **Wiki/Notion** で集中管理 → Pull Request ベースでレビュー
- コミュニケーションは **Slack** + **GitHub Issues/Projects** をメインとし、追加で **Notion** / **Confluence** 等を必要に応じて利用
- 定例会議やデイリースクラムを簡易に回しつつ、会議や議事録で**決定事項の可視化**を徹底
- 経験の浅いエンジニアにも分かりやすいツール・テンプレートを採用し、ドキュメント更新も**簡単なプロセス**にする

こうすることで、**低コストかつ短期間**でプロジェクトを進めながらも、必要な情報共有とドキュメント整備が無理なく実現でき、後々の**拡張**や**メンバー増**にも対応しやすくなります。
```

## 5_development_process/4_Automation.md

# 自動化 (CI/CD, IaC)

> **前提**
> - お金をかけずに、経験の浅いエンジニアでも構築しやすい仕組みを重視
> - 将来的に機能追加やメンバー増への対応が容易な構成を目指す
> - GitHub リポジトリ + Cloudflare Pages を中心に**簡易CI/CD**を実装し、さらに必要に応じてテスト/インフラ自動化を拡張

---

## 1. CIパイプライン

1. **使用ツール候補**
   - **GitHub Actions** (無料枠あり)
     - Pull Request 作成時に自動ビルド、Lint/Formatter、単体テストなど実行
     - Next.js + TypeScript 用のテンプレワークフローが多数存在
   - 他選択肢: CircleCI, Jenkins など (無料枠 or Self-hosted で利用)

2. **ビルド/テスト手順 (例)**
   1. **checkout**: リポジトリを取得
   2. **install**: `npm ci` で依存関係インストール
   3. **lint**: `npm run lint` (ESLint + Prettier)
   4. **test**: `npm run test` (Jest / Vitest等 単体テスト)
   5. **build**: `npm run build` (Next.js ビルド確認)
   6. **report**: テスト結果 / カバレッジを GitHub Actions のコンソールや Slack に通知

3. **成果物**
   - 成功: Pull Request に「CI パス」と表示
   - 失敗: エラー詳細を表示 → PR 修正

> **経験の浅いエンジニア** でも、GitHub Actions の [ワークフローファイルサンプル](https://github.com/actions/starter-workflows) を参照すれば導入可能

---

## 2. CDパイプライン

1. **環境分離とデプロイ方法**
   - **開発環境**: `development` ブランチをデフォルトブランチとし、開発環境にデプロイ
   - **本番環境**: `production` ブランチへのマージで本番環境にデプロイ
   - **Cloudflare Pages** を活用することで、**GitHub リポジトリ**にプッシュするたびに自動ビルド＆デプロイ
   - **Preview Deploy**: PRごとにプレビューURLが発行され、UIの確認が容易
   - **開発/本番分離**: 各ブランチに対応する環境が自動的に構築され、開発と本番の分離が容易

2. **承認フロー (簡易)**
   1. 機能ブランチを作成 → 開発 → `development`ブランチへPR → CIパス → コードレビュー → マージ
   2. 開発環境で十分にテスト → `production`ブランチへPR → コードレビュー → マージ
   3. マージ後、自動で Cloudflare Pages の本番環境にデプロイ
   4. Slack 等へ「デプロイ完了通知」
   - 大規模/厳密な運用が必要な場合は、**手動承認ステップ** など追加可

3. **環境変数管理**
   - **Cloudflare Pages Dashboard** 上で開発/本番環境ごとに環境変数を設定 (.env.* はGit ignore)
   - Supabase 接続URL, JWT_SECRET などはここで安全に管理

---

## 3. インフラのコード化 (IaC)

1. **対象範囲** (将来拡張)
   - Supabase はマネージドで自動管理 → Terraform でDBスキーマ管理までは不要かもしれない
   - Cloudflare Pages は自動デプロイが主 → Terraform, Pulumi などで管理するメリットは限定的
   - 小規模なら**手動設定**で十分 → 将来的に AWS移行や大規模化を考えるなら IaC検討

2. **ツール例**
   - **Terraform**: 各種クラウドリソースを宣言的にコード管理
   - **Pulumi**: TypeScript など好きな言語でIaC可能
   - 運用コスト(学習+メンテ)があるため、当面は**手動** or **Supabase migration scripts** でも可

3. **推奨方針**
   - MVPフェーズ：Cloudflare Pages + Supabase の**GUI管理が中心**
   - 将来的に本格インフラ(EC2, RDS, S3 など)を使う場合→Terraform/Pulumi でIaC化

---

## 4. テスト自動化

1. **単体テスト (Unit Test)**
   - **Jest** or **Vitest** など → Reactコンポーネントやロジック層のテスト
   - API Routes は jest + supertest で簡易的なHTTPテスト可能

2. **結合テスト / E2Eテスト**
   - **Cypress** / **Playwright** など
   - フロントエンドから実際の画面操作を自動化
   - ログイン機能や要約機能が一通り動くか検証

3. **段階的導入**
   - まずは**重要ロジック (要約生成, 認証フロー)** を優先 → 単体テスト
   - 時間があれば UI周りのE2Eテストを追加
   - カバレッジ100%は目指さず、**クリティカルな箇所**をカバー

---

## 5. 運用タスクの自動化

1. **定期バッチ**
   - 現状: **Cloudflare Workers** を利用したスケジュール実行でRSS/YouTube監視 → DB保存
   - スクリプトは Next.js API Routes or バックエンドCron専用パスで管理
   - Supabase Functions は要検討(無料枠/制限)

2. **ログ集計・分析**
   - 小規模なら**Supabase** のログ機能 / テーブルで十分
   - 必要なら**Sentry** などのエラーログ連携 → Slack通知

3. **自動レポート (将来)**
   - 毎朝9時に Discord/Webhook で「新着要約数レポート」を送信
   - 期間別リソース使用量など → Supabase + Simple CLI or Webhook

4. **データバックアップ**
   - Supabase には定期バックアップ機能(無料枠でも有)
   - 重要テーブルはCSV出力 or PG_dump でローカル/クラウドへ保存

---

### まとめ

- **CI (GitHub Actions)**: Pull Request 時にビルド+Lint+テスト → 失敗を早期検知
- **CD (Cloudflare Pages)**:
  - `development` ブランチをデフォルトとし、開発環境へ自動デプロイ
  - `production` ブランチマージで本番環境へ自動デプロイ
  - Preview URL で安全にレビュー
- **環境分離**: 開発環境と本番環境を明確に分離
- **テスト自動化**: まず単体テストを整備 → 余力があれば E2E
- **IaC**: 小規模MVP段階は手動/GUI管理が妥当、拡張時にTerraform等導入検討
- **運用自動化**: Cloudflare Workers でスケジュール実行、Slack通知など最低限を実装 → 大規模化時に細分化

このようにして、**低コスト & シンプル** に **CI/CD + 運用自動化** を導入し、後から段階的に拡張できる体制を整えます。
```

## 5_development_process/5_Test_Strategy.md

```markdown
# テスト戦略

> **前提**:
> - **コストをかけずに、初心者でもテストできる**体制を優先
> - システム規模が大きくなった際にも**段階的に拡張**しやすい設計
> - まずは**最重要機能**をテスト、余裕があれば非機能・E2Eまで拡張

---

## 1. テストレベル

1. **単体テスト (Unit Test)**
   - **対象**: 関数や小規模コンポーネント（Next.js のAPI Route単体、認証ロジック、要約生成ロジックなど）
   - **目的**: 各モジュールが**単体で**正しく動作するかを確認
   - **実施タイミング**: 開発者が機能追加/修正する度にローカル実施 + CI上で自動実行

2. **結合テスト (Integration Test)**
   - **対象**: APIとDB連携/外部サービス連携（Supabase, Discord Webhook, AIモデルAPI）など
   - **目的**: **モジュール間**の連携が正常に動作するかを確認
   - **実施タイミング**: 大きな機能ブランチ完了、Pull Request時など

3. **システムテスト (E2E)**
   - **対象**: ユーザー操作の流れ（ログイン → 新着検出 → AI要約 → Discord通知 → アプリ画面で閲覧 など）
   - **目的**: システム全体を通して**一連の操作**が意図通りに動作するか確認
   - **実施タイミング**: リリース前のステージング環境で定期 or 主要機能追加時

4. **UAT (ユーザー受け入れテスト)**
   - **対象**: 管理者/一般ユーザーが実際に触り、本番運用イメージで最終確認
   - **目的**: 要件・UI/UXがユーザー要望とズレていないか評価
   - **実施タイミング**: 大きめのリリース前、あるいはフェーズ完了前

---

## 2. テスト項目

1. **機能テスト (正常系/異常系)**
   - **正常系**:
     - 新規ユーザー登録、ログイン/ログアウト
     - 要約機能（AIモデル呼び出し、結果保存）
     - RSS/YouTube監視ジョブ → DB保存
     - Discord通知（サムネ付きEmbed）
     - タグ登録/削除、検索フィルタ など
   - **異常系**:
     - ログイン失敗（不正パスワード、アカウントロックなど）
     - AIモデル呼び出し失敗（API Key不備、タイムアウト）
     - DB保存時のエラー（容量超過、接続切断など）
     - Discord Webhookエラー（URL不正、403 Forbiddenなど）

2. **非機能テスト**
   - **性能テスト**:
     - ページネーションで大量コンテンツがある際、応答速度が許容範囲内か
     - Cronジョブで同時多数のRSSを処理して問題ないか
   - **セキュリティテスト**:
     - 認証/認可の欠陥、CSRFトークン有効性
     - .env / 機密情報の漏えいがないか
   - **操作性テスト**: (簡易)
     - ダッシュボードや管理画面がUI的に使いやすいか

---

## 3. テスト環境

1. **ステージング**:
   - Vercel の Preview Deploy 機能 → PRごとに自動生成される環境
   - Supabase: テスト用テーブル or テスト用プロジェクトを別途用意
   - テスト用のDiscord Webhook (開発専用チャンネル)

2. **本番相当の構成**:
   - 主要機能確認や負荷テストを実施するなら、本番同等にDB/設定を用意
   - Supabase の無料枠内でもENVを分ける (プロジェクト2つにしてデータ分離)

3. **テストデータの扱い**:
   - テスト用アカウント: `test-user@example.com` / `test-pass123` など
   - 大量の記事/動画IDを用意 → テスト的にRSSに混ぜ込む
   - テスト終了後はリセット/クリーンアップ

---

## 4. 自動テストカバレッジ目標

1. **単体テスト**:
   - 主要ロジック（AI要約、Discord送信、RSS解析等）は**最低限** 70% 以上
   - 全機能100% は目指さず、**重要処理**を優先カバー

2. **結合テスト**:
   - 認証 + DB連携 + AI呼び出しなど主要経路を1,2ケースずつ
   - 毎回フルテストでなく**主要機能が壊れていないか**を確認

3. **E2Eテスト**:
   - ログイン→YouTube監視→DB保存→要約→Discord通知→アプリ画面表示
   - クリティカルパスを1,2のシナリオで自動化
   - UI変更多い時は保守コストに注意

---

## 5. テスト管理ツール

1. **軽量管理**:
   - **GitHub Projects** / Issue でテストケース追跡
   - スプレッドシート: 「テスト項目表」作成 (ID, 手順, 期待結果, 実施可否など)

2. **本格導入** (将来):
   - TestRail, Xray for Jira 等 → 大規模開発向け
   - 初期導入コストあるため**小規模MVPでは不要**

---

## 6. リリース判定基準

1. **バグ残数**:
   - 重大バグ (サービス停止/データ破壊レベル) は 0
   - 中程度バグは**次リリース対応**でもOKか判断 → Issue化

2. **パフォーマンス指標**:
   - 1ユーザー操作あたり**応答1秒以内**程度を目標 (ページネーション時)
   - Cronジョブが**許容時間**(例: 1分以内)でRSS全取得 → 超過ならスケールか対策

3. **テスト完了率**:
   - 重要シナリオ (AI要約/認証/通知) は 100% 実施
   - 余力があれば他機能も網羅 → 未実施項目はリリースメモに記載

4. **承認フロー**:
   - 開発メンバー/PMがテスト結果確認 → OK で本番デプロイ
   - 重大バグがあれば修正後に再テスト

---

### まとめ

- **テストレベル**: 単体 → 結合 → E2E → UAT の段階的実施
- **テスト項目**: まずは**主要機能 (認証, 要約, 通知)** を中心に正常・異常系
- **環境**: Vercel Preview + Supabaseテスト用プロジェクト
- **カバレッジ目標**: 重要ロジック優先で70%程度
- **ツール**: 小規模はGitHub Issue/Projects + スプレッドシートで十分
- **リリース判定**: 重大バグ0 & パフォーマンス目標達成 → OK

これにより、初心者でも少ないコストでテストを回しつつ、将来的な機能拡張時にも対応しやすい構成を実現する。
```

