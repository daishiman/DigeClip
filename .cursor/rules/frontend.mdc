---
description: フロントエンド実装上の注意事項
globs: "src/app/**/*.{tsx,jsx,ts,js}",     "!src/app/api/**/*",     "src/components/**/*.{tsx,jsx,ts,js}",     "src/hooks/**/*.{tsx,jsx,ts,js}",     "src/context/**/*.{tsx,jsx,ts,js}",     "src/config/**/*.{tsx,jsx,ts,js}",     "src/types/models/**/*.{ts,js}"
alwaysApply: false
---
# フロントエンド実装上の注意事項


## フロントエンド実装上の注意事項

### コンポーネント設計
- **コンポーネントを機能単位で分割する**: 大きすぎるコンポーネントは避け、機能単位で適切に分割すること
- **プレゼンテーションとロジックを分離する**: 表示に関するコードとビジネスロジックを明確に分離すること
- **共通コンポーネントを作成する**: 繰り返し使用するUI要素は共通コンポーネントとして実装すること

### 状態管理
- **状態の範囲を最小限に保つ**: グローバル状態は必要最小限にし、コンポーネントローカルな状態を優先すること
- **状態更新ロジックを集約する**: 状態更新のロジックは一箇所に集約し、予測可能性を高めること
- **不変性を保持する**: 状態の更新は常に不変性を保持し、直接的な変更を避けること

### パフォーマンス最適化
- **不要な再レンダリングを防止する**: メモ化やコンポーネント分割を活用して再レンダリングを最適化すること
- **遅延ロードを活用する**: 初期表示に必要ないコンポーネントは遅延ロードを使用すること
- **リソースの事前読み込みを検討する**: ユーザーの次のアクションを予測し、必要なリソースを事前に読み込むこと

### コード品質
- **一貫したコーディングスタイルを維持する**: ESLintやPrettierを使用して、コードスタイルを統一すること
- **命名規則を統一する**: 変数、関数、コンポーネントの命名規則を統一し、意図を明確に表現すること
- **デッドコードを残さない**: 使用されていないコードは削除し、コードベースをクリーンに保つこと

### ユーザー体験
- **エラー状態を適切に処理する**: ユーザーにわかりやすいエラーメッセージを表示し、回復手段を提供すること
- **ローディング状態を表示する**: 非同期操作中はローディング状態を明示し、ユーザーを待たせないこと
- **アクセシビリティを考慮する**: キーボード操作やスクリーンリーダーに対応したUIを実装すること

## 共通の注意事項

### シンプルさの維持
- **YAGNI原則を適用する**: 「必要になるまで作らない」原則を守り、過剰な機能を実装しないこと
- **過度な抽象化を避ける**: 将来の拡張性のために過度に複雑な抽象化を導入しないこと
- **明確さを優先する**: 短いコードよりも明確なコードを優先し、理解しやすさを重視すること

### コード管理
- **小さなコミットを心がける**: 大きな変更は小さな単位に分割し、レビューしやすくすること
- **意味のあるコミットメッセージを書く**: コミットメッセージは変更内容と理由を明確に説明すること
- **ブランチ戦略を統一する**: 機能開発、バグ修正、リリースなどの目的に応じたブランチ戦略を採用すること

### ドキュメント
- **コードの意図を文書化する**: 複雑なロジックや重要な決定事項は文書化し、将来の開発者が理解できるようにすること
- **APIの使用方法を説明する**: 公開APIは使用方法と例を含むドキュメントを提供すること
- **変更履歴を記録する**: 重要な変更はCHANGELOGに記録し、バージョン間の違いを明確にすること

### チーム協業
- **コードレビューを重視する**: すべての変更は少なくとも1人のレビューを受けること
- **知識共有を促進する**: 複雑な実装や重要な決定事項はチーム内で共有すること
- **技術的負債を管理する**: 技術的負債を定期的に特定し、計画的に解消すること

### バランスの取れた設計
- **過度な最適化を避ける**: 早期の最適化は避け、実際のパフォーマンス問題が確認された場合にのみ最適化すること
- **適切な技術選択をする**: プロジェクトの規模と要件に適した技術を選択し、過剰な技術スタックを避けること
- **拡張性と保守性のバランスを取る**: 将来の拡張性を考慮しつつも、現在の保守性を犠牲にしないこと

## 4. コーディング規約

### 概要

「お金をかけずに初心者が実装しやすい」方針を優先し、厳密すぎるルールは設定しません。最低限の Lint/Formatter を導入し、**ディレクトリ構造もシンプル**にします。

---

### Lint / Formatter

1. **ESLint**
   - Next.js プロジェクト作成時に自動設定されることが多い
   - “extends: next/core-web-vitals” などを採用
2. **Prettier**
   - コードフォーマット統一
   - コミット時に自動整形 (husky + lint-staged など追加可)

---

### ディレクトリ構造

```
/src
  ├─ /app                          # Next.jsのApp Routerディレクトリ
  │   ├─ /page.tsx                 # ダッシュボード画面
  │   ├─ /sources/page.tsx         # ソース一覧
  │   ├─ /contents/page.tsx        # コンテンツ一覧
  │   ├─ /contents/[id]/page.tsx   # コンテンツ詳細
  │   ├─ /settings/
  │   │   ├─ /ai-models/page.tsx   # AIモデル設定
  │   │   ├─ /notifications/page.tsx # 通知設定
  │   │   └─ /...
  │   └─ /api                      # APIルートディレクトリ
  │       ├─ /auth/                # 認証関連API
  │       │   ├─ /login/route.ts
  │       │   ├─ /register/route.ts
  │       │   └─ /...
  │       ├─ /admin/               # 管理者用API
  │       │   ├─ /sources/route.ts
  │       │   ├─ /contents/route.ts
  │       │   └─ /...
  │       └─ /user/                # 一般ユーザー用API
  │           ├─ /contents/route.ts
  │           └─ /...
  │
  ├─ /components                   # 再利用可能なコンポーネント
  │   ├─ /ui                       # 基本UIコンポーネント
  │   │   ├─ /Button               # ボタンコンポーネント
  │   │   │   ├─ Button.tsx        # 基本ボタン
  │   │   │   ├─ IconButton.tsx    # アイコン付きボタン
  │   │   │   ├─ ButtonGroup.tsx   # ボタングループ
  │   │   │   └─ index.ts          # エクスポート
  │   │   ├─ /Card                 # カードコンポーネント
  │   │   │   ├─ Card.tsx          # 基本カード
  │   │   │   ├─ CardHeader.tsx    # カードヘッダー
  │   │   │   ├─ CardContent.tsx   # カードコンテンツ
  │   │   │   ├─ CardFooter.tsx    # カードフッター
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /layout                   # レイアウト関連コンポーネント
  │   │   ├─ /Header               # ヘッダーコンポーネント
  │   │   │   ├─ Header.tsx        # 基本ヘッダー
  │   │   │   ├─ HeaderNav.tsx     # ヘッダーナビゲーション
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   ├─ /features                 # 機能別コンポーネント
  │   │   ├─ /sources              # ソース関連コンポーネント
  │   │   │   ├─ SourceList.tsx    # ソース一覧
  │   │   │   ├─ SourceCard.tsx    # ソースカード
  │   │   │   ├─ SourceForm.tsx    # ソース追加/編集フォーム
  │   │   │   └─ index.ts          # エクスポート
  │   │   └─ /...
  │   │
  │   └─ /patterns                 # 再利用可能なパターン
  │       ├─ /DataTable            # データテーブルパターン
  │       │   ├─ DataTable.tsx     # 基本テーブル
  │       │   ├─ TableHeader.tsx   # テーブルヘッダー
  │       │   └─ index.ts          # エクスポート
  │       └─ /...
  │
  ├─ /hooks                        # カスタムフック
  │   ├─ /api                      # API関連フック
  │   │   ├─ /admin                # 管理者API用フック
  │   │   │   ├─ useSources.ts     # ソース管理フック
  │   │   │   ├─ useContents.ts    # コンテンツ管理フック
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI用フック
  │   │   │   ├─ useContents.ts    # コンテンツ取得フック
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API用フック
  │   │       ├─ useAuth.ts        # 認証フック
  │   │       └─ ...
  │   └─ /ui                       # UI関連フック
  │       ├─ useModal.ts           # モーダル制御フック
  │       └─ ...
  │
  ├─ /lib                          # ユーティリティと共通関数
  │   ├─ /api                      # API関連ユーティリティ
  │   ├─ /db                       # データベース関連
  │   │   ├─ client.ts             # Supabase接続
  │   │   └─ /repositories         # リポジトリクラス
  │   │       ├─ sourceRepository.ts
  │   │       ├─ contentRepository.ts
  │   │       └─ ...
  │   ├─ /services                 # ビジネスロジック
  │   │   ├─ /content              # コンテンツ関連サービス
  │   │   ├─ /source               # ソース関連サービス
  │   │   ├─ /ai                   # AI関連サービス
  │   │   └─ /notification         # 通知関連サービス
  │   ├─ /utils                    # 汎用ユーティリティ
  │   └─ /middleware               # ミドルウェア
  │
  ├─ /types                        # 型定義
  │   ├─ /api                      # API関連の型
  │   │   ├─ /admin                # 管理者API型
  │   │   │   ├─ sources.ts        # ソース関連型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   ├─ /user                 # ユーザーAPI型
  │   │   │   ├─ contents.ts       # コンテンツ関連型
  │   │   │   └─ ...
  │   │   └─ /auth                 # 認証API型
  │   │       ├─ auth.ts           # 認証関連型
  │   │       └─ ...
  │   └─ /models                   # モデル関連の型
  │       ├─ source.ts             # ソースモデル
  │       ├─ content.ts            # コンテンツモデル
  │       └─ ...
  │
  ├─ /context                      # Reactコンテキスト
  │   ├─ AuthContext.tsx           # 認証コンテキスト
  │   └─ ...
  │
  └─ /config                       # 設定ファイル
      ├─ constants.ts              # 定数定義
      ├─ routes.ts                 # ルート定義
      └─ ...
```

---

### 命名規則

- **ファイル名**: キャメルケース or パスカルケース (例: `MyComponent.jsx`)
- **変数/関数**: lowerCamelCase で統一 (例: `fetchData`)
- **定数**: UPPER_SNAKE_CASE (例: `API_BASE_URL`)
- **CSSクラス名**: Tailwind ユーティリティを使うため、命名は最小限

## 共通仕様

### レスポンシブデザイン
- すべての画面はモバイル（最小幅320px）、タブレット（最小幅768px）、デスクトップ（最小幅1024px）に対応すること
  - モバイルでは縦スクロールを基本とし、重要な情報を上部に配置
  - タブレットでは横向き表示も考慮し、情報の密度を調整
  - デスクトップでは複数カラムを活用し、情報を効率的に表示
- 画面サイズに応じたレイアウト調整を行い、ユーザー体験を最適化する
  - 各デバイスでの操作性を考慮し、タップ領域やクリック可能な要素を適切に配置
- フレックスボックスやグリッドレイアウトを用いて、要素の配置を柔軟に変更可能にする
  - レスポンシブなデザインを実現するために、フレックスボックスを使用して要素の並びを動的に変更
  - グリッドレイアウトを用いて、複雑なレイアウトを簡潔に実装
- メディアクエリを使用して、特定の画面サイズに応じたスタイルを適用し、視認性を向上させる
  - 各ブレークポイントでのスタイルを詳細に設定し、デバイス間での一貫性を保つ

### エラーハンドリング
- ユーザーに対して、具体的で理解しやすいエラーメッセージを表示する
  - エラーメッセージはユーザーの行動をガイドする内容とし、解決策を提示
- ネットワークエラーやバリデーションエラーを適切にキャッチし、ユーザーに通知する
  - エラー発生時には、ポップアップやトースト通知を用いて即座にユーザーに知らせる
- エラーログをサーバーに記録し、管理者に通知する仕組みを実装する
  - ログは定期的にレビューし、システムの改善に役立てる
- ユーザーがエラー発生時に再試行できるオプションを提供し、操作の継続を支援する
  - 再試行ボタンを設置し、ユーザーが簡単に操作をやり直せるようにする

### アクセシビリティ
- キーボード操作をサポートし、すべてのインタラクティブ要素にフォーカス可能にする
  - タブキーでのナビゲーションをスムーズにし、フォーカスインジケーターを明確に表示
- スクリーンリーダーでの読み上げに対応し、視覚障害者が情報を取得できるようにする
  - 重要な情報には適切なラベルを付与し、スクリーンリーダーでの理解を助ける
- WCAG 2.1に準拠した適切なコントラスト比を確保し、視認性を向上させる
  - テキストと背景のコントラストを高め、すべてのユーザーにとって読みやすいデザインを提供
- ARIA属性を適切に適用し、補助技術が要素の意味を正しく理解できるようにする
  - ARIAロールやプロパティを用いて、インターフェースの意味を明確に伝える
- フォーカス管理を徹底し、ユーザーが意図した順序で要素を操作できるようにする
  - フォーカスの移動順序を論理的に設定し、ユーザーの操作を円滑にする

### セキュリティ
- XSS（クロスサイトスクリプティング）対策として、ユーザー入力をエスケープし、信頼できないデータを直接DOMに挿入しない
  - すべての入力データをサニタイズし、潜在的な攻撃を防止
- CSRF（クロスサイトリクエストフォージェリ）対策として、トークンを用いたリクエスト検証を行う
  - 各リクエストにCSRFトークンを付与し、正当性を確認
- 認証・認可の確認を徹底し、ユーザーの権限に応じたアクセス制御を実施する
  - ユーザーのロールに基づき、アクセス可能な機能を制限
- セキュアな通信（HTTPS）を必須とし、データの盗聴や改ざんを防ぐ
  - すべての通信をHTTPSで暗号化し、セキュリティを強化
- セッション管理を強化し、一定時間の非操作で自動的にログアウトするタイムアウト設定を行う
  - セッションの有効期限を設定し、セキュリティリスクを低減
- 入力データをサニタイズし、SQLインジェクションやその他の攻撃を防ぐ
  - データベースへのクエリ実行時にプレースホルダーを使用し、安全性を確保

### UI/UXデザイン
- 一貫性のあるデザインシステムを採用し、全画面で統一感のあるユーザー体験を提供する
  - 共通のカラーパレット、フォント、アイコン、コンポーネントを使用
  - Tailwind CSSを使用し、クラス名の一貫性を確保
- モバイルファーストのアプローチで設計し、タッチ操作に最適化する
  - タップターゲットは最低44x44ピクセルを確保し、誤操作を防止
  - スワイプジェスチャーやピンチズームなどのタッチ操作をサポート
- 視覚的階層を明確にし、重要な情報や操作を優先的に表示する
  - コンテンツの重要度に応じた適切な視覚的ウェイトを設定
  - 主要アクションは目立つボタンで表示し、副次的アクションは控えめに設計
- 処理中や読み込み中の状態を明示し、ユーザーに適切なフィードバックを提供する
  - ローディングインジケーターやスケルトンスクリーンを表示
  - 長時間処理の場合は進捗状況を表示
- ダークモードとライトモードの両方をサポートし、ユーザーの好みや環境に合わせて切り替え可能にする
  - システム設定に連動した自動切り替え機能を実装
  - カラーコントラストはどちらのモードでも適切に保つ

### パフォーマンス最適化
- 画像の最適化と遅延読み込みを実装し、初期ロード時間を短縮する
  - 画像はWebP形式を優先し、適切なサイズに最適化
  - viewport外の画像はLazy Loadingを適用
- コードの分割（Code Splitting）を行い、必要な機能のみを初期ロード時に読み込む
  - ルートベースのコード分割を実装し、ページごとに必要なコードのみ読み込み
  - 共通コンポーネントは共有チャンクとして抽出
- キャッシュ戦略を導入し、再訪問時のロード時間を短縮する
  - 静的アセットには適切なCache-Controlヘッダーを設定
  - Service Workerを使用したオフラインサポートを検討
- 不要なレンダリングを防ぎ、スムーズなインタラクションを実現する
  - メモ化（React.memo, useMemo, useCallback）を適切に使用
  - 仮想スクロール（react-window/react-virtualized）を大量リスト表示に適用
- バンドルサイズを最小化し、初期読み込み時間を短縮する
  - Tree Shakingを活用し、未使用コードを除外
  - 重複依存関係を最小化

### 国際化対応
- すべてのテキストリソースを外部化し、多言語対応を容易にする
  - next-intlやreact-i18nextなどのライブラリを使用
  - 言語切り替え機能をUIに実装
- 日時表示はユーザーのロケールに合わせて最適化する
  - Intl.DateTimeFormatを活用し、地域に適した日時フォーマットを表示
- RTL（右から左）言語のサポートを考慮したレイアウト設計を行う
  - CSSの論理プロパティ（margin-inline-startなど）を使用
- 数値や通貨のフォーマットをロケールに応じて調整する
  - Intl.NumberFormatを使用して適切な桁区切りや小数点を表示

### テスト・品質保証
- ユニットテスト、統合テスト、E2Eテストを実装し、機能の正確性を確保する
  - Jestでのユニットテスト、React Testing Libraryでのコンポーネントテスト
  - Cypressを用いたE2Eテストで実際のユーザー操作をシミュレート
- クロスブラウザテストを実施し、主要ブラウザでの互換性を確認する
  - Chrome, Firefox, Safari, Edgeでの動作検証
  - Browserstack等のサービスを活用
- パフォーマンス指標を定期的に測定し、最適化の効果を検証する
  - Lighthouse, Web Vitals等のツールで計測
  - コア指標（LCP, FID, CLS）の数値目標を設定
- アクセシビリティ監査を実施し、障壁を特定・解消する
  - axe-coreやWAVE等のツールで自動チェック
  - キーボード操作のみでの全機能検証
  
### テストカバレッジの目標

フロントエンドのテストカバレッジは以下の目標を設定してください：

1. **APIクライアント**: 90%以上のカバレッジ
   - すべてのHTTPメソッド（GET, POST, PUT, DELETE）
   - 認証トークンの処理
   - エラーハンドリング

2. **サービスレイヤー**: 80%以上のカバレッジ
   - 主要なビジネスロジック
   - データ変換処理
   - エラー処理

3. **React Queryフック**: 80%以上のカバレッジ
   - データ取得
   - キャッシュ操作
   - エラー状態

4. **UIコンポーネント**: 70%以上のカバレッジ
   - 主要なユーザーインタラクション
   - 条件付きレンダリング
   - エラー状態の表示

### テスト実行のベストプラクティス

1. **継続的インテグレーション**:
   - プルリクエスト時に自動的にテストを実行
   - カバレッジレポートを生成して確認

2. **テストの分類**:
   - 単体テスト: 個々の関数やコンポーネント
   - 統合テスト: 複数のコンポーネントやサービスの連携
   - E2Eテスト: ユーザーフローの検証

3. **テストデータ**:
   - テストごとにモックデータを用意
   - テストデータは実際のデータ構造に近いものを使用
   - 境界値や特殊なケースも考慮

4. **テストの独立性**:
   - 各テストは独立して実行できるようにする
   - テスト間で状態を共有しない
   - beforeEach/afterEachでテスト環境をリセット