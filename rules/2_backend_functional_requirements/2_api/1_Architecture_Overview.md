# アーキテクチャ概要

## 前提条件

本システムでは、**お金をかけずに、容易に経験の浅いエンジニアが短期間で実装**できることを第一優先とし、将来的な拡張にも対応しやすい設計を目指します。以下のガイドラインは、現在の要件と運用規模を前提としたアーキテクチャ方針です。

## 1. モノリシック or マイクロサービス

### 選定方針と理由

- **現状はモノリシック構成**:
  - Next.js（フロント＆バックエンド） + Supabase（DB）を1つのリポジトリ/プロジェクトで管理し、**Vercel** 上で動作させます。
  - サーバレス環境では「小規模モノリシック」でも十分運用可能、設定が簡単。

- **将来的な拡張**:
  - コンテンツが大量＆要約処理が大規模になる場合、**Microservices** (AI処理専用サービス等) や別コンテナ分割を検討。
  - 需要が増えた際には**AI要約処理**を Queue + Worker に切り出す形も想定可。

### メリット/デメリット
- **メリット**:
  - コードベースが1つで済み、**初心者でも構成を理解しやすい**。
  - **Vercel 無料枠**内で管理しやすい。
- **デメリット**:
  - 大規模化時、モノリシックがボトルネックになる可能性。
  - CI/CD や更新が大きくなるとビルド時間が延びる。

## 2. サーバレスアーキテクチャ

### 対象範囲

- **Next.js** を Vercel 上で Serverless Functions (API Routes) として動かす。
- Cron Jobs (Vercel) を利用して定期実行。
- **Supabase** はマネージド PostgreSQL でサーバレスに近い形。

### 導入メリット

- **コストがほぼゼロ** (無料枠内)
- 運用負荷が少なく、**エンジニアがインフラ構築不要**
- デプロイとスケールが自動化され、**初心者でも扱いやすい**

### デメリット / 将来検討

- Vercel の無料枠・API 実行回数に制限がある。
- ステートレスな処理に特化、動画変換などヘビー処理は**有料プラン or Worker化**を検討。
- AI要約の大規模化時に**外部ジョブキューサービス**との連携が必要になるかも。

## 3. レイヤードアーキテクチャ

本システムは小規模モノリシックかつサーバレス環境で動かすため、**シンプルなレイヤー構成**を想定します。

1. **プレゼンテーション層 (UI)**
   - Next.js のページコンポーネント + Tailwind CSS
   - フロント側で認証・画面表示・ユーザー操作を受け付け

2. **APIレイヤー** (`/app/api/*`)
   - Next.js の API Routes (Serverless Functions) で REST API 的に実装
   - HTTPリクエストの受付
   - 認証・認可の確認
   - リクエストのバリデーション
   - 適切なサービスの呼び出し
   - レスポンスの整形

3. **サービスレイヤー** (`/lib/services/*`)
   - ビジネスロジックの実装
   - トランザクション管理
   - 複数リポジトリの連携
   - 外部APIとの連携

4. **リポジトリレイヤー** (`/lib/db/repositories/*`)
   - データアクセスロジックの抽象化
   - クエリの実行
   - データの変換（DB形式 ⇔ アプリケーション形式）

5. **ユーティリティレイヤー** (`/lib/utils/*`)
   - 共通機能の提供
   - ヘルパー関数
   - バリデーション
   - エラーハンドリング

## 4. ディレクトリ構造

プロジェクトのディレクトリ構造については、共通ディレクトリ構造ドキュメントを参照してください：
[共通ディレクトリ構造](../../0_common/3_Directory_Structure.md)

## 5. 認証・認可

### 認証方式

- **Supabase Auth** を利用
  - メール/パスワード認証
  - ソーシャルログイン（Google, GitHub など）
  - JWT トークンベースの認証

### 認可方式

- **Row Level Security (RLS)** を活用
  - Supabase の RLS ポリシーでデータアクセス制御
  - ユーザーロールに基づいたアクセス制御
  - API レベルでの追加的な認可チェック

## 6. エラーハンドリング

### エラー種別

- **クライアントエラー** (4xx)
  - バリデーションエラー
  - 認証・認可エラー
  - リソース不存在エラー
- **サーバーエラー** (5xx)
  - 内部エラー
  - 外部サービス連携エラー
  - データベースエラー

### エラーレスポンス形式

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "入力値が不正です",
    "details": [
      {
        "field": "email",
        "message": "有効なメールアドレスを入力してください"
      }
    ]
  }
}
```

## 7. パフォーマンス最適化

### キャッシュ戦略

- **Vercel Edge Cache** の活用
  - 静的コンテンツのキャッシュ
  - API レスポンスのキャッシュ（適切な場合）
- **クライアントサイドキャッシュ**
  - React Query / SWR によるデータキャッシュ
  - ローカルストレージ / IndexedDB の活用

### データベース最適化

- **インデックス設計**
  - 頻繁に検索されるフィールドにインデックスを作成
  - 複合インデックスの活用
- **クエリ最適化**
  - 必要なデータのみを取得
  - N+1問題の回避
  - ページネーションの実装

## 8. スケーラビリティ

### 現状の制約

- Vercel の無料枠では同時実行数に制限あり
- Supabase の無料枠ではデータベース容量に制限あり

### スケールアップ戦略

- **Vercel Pro** へのアップグレード
  - 同時実行数の増加
  - 実行時間の延長
- **Supabase Pro** へのアップグレード
  - データベース容量の増加
  - 同時接続数の増加

### スケールアウト戦略

- **マイクロサービス化**
  - AI処理部分の分離
  - バッチ処理の分離
- **キューイングシステムの導入**
  - 非同期処理の実装
  - ジョブの分散処理