# 外部サービス連携 要件定義 (最新版)

> **前提**
> - 本システムでは「経験の浅いエンジニアでも低コストで導入しやすく、将来的な機能拡張にも耐えられる」外部サービス連携を目指す。
> - 必須連携：**SNS認証（Google OAuth）**、**決済サービス**（必要な場合）、**メール配信**、**その他拡張的なAPI**（地図/レコメンドなど）
> - **Mastra.ai** 等のエージェント機能との連携も視野に入れ、複数段階要約（overview, heading, detail）に対応する。

以下では、SNS認証 → 決済サービス → メール配信 → その他外部APIの順に、具体的な要件・フロー・エラー対策を示す。
内容は**お金をかけずに、容易に経験の浅いエンジニアが実装できる**ことを重視し、**将来の機能追加**に耐えうる構成とする。

---

## 1. SNS認証

### 1.1 連携フロー

1. **Google OAuth 2.0**
   - フロントエンド（Next.js）側で「Googleでログイン」ボタンを設置
   - ボタン押下 → Googleログインページへリダイレクト
   - 同意後、アプリのコールバックURL (`/api/auth/google-callback`) に `code` & `state` が返却
   - サーバーで `code` を使って Googleのトークン取得API を呼び出し → `id_token` or `access_token`
   - トークンを検証し、ユーザーのメールアドレス等を取得
   - ローカルDB（Supabase）でユーザーを見つける/作成する
   - **JWT**を発行し、フロントに返す（Cookie or LocalStorageで保持）

2. **GitHub OAuth** (拡張例)
   - Googleと似たOAuthフロー (任意で今後追加可能)

3. **(任意)** Firebase Authentication
   - Google認証をFirebase上で完結させる方法もあるが、複雑度が上がるため今回は省略。

#### 実装の容易性
- Google Identity Servicesの公式JavaScript SDKを利用→トークン取得が簡単。
- **NextAuth.js**などのライブラリを使えば、さらにコード量を大幅削減可能。

### 1.2 アクセストークン管理

- **JWT**を最終的にサーバーが発行 → `Authorization: Bearer <token>` ヘッダ or Cookieで送受信
- 有効期限 (`exp`) を設定（例：1時間）
- リフレッシュトークンは簡単化のため今回は省略可（ユーザーが再ログインor Googleログインで継続使用）
- HTTP Cookieの場合：`Secure` / `HttpOnly` / `SameSite` を有効化

### 1.3 エラー対処

- **ユーザーが認証キャンセル**: UIで「キャンセルしました」のメッセージ
- **無効なトークン**: 401エラー（`{ error: { code: "E401", message: "Invalid token" } }`）
- **Google連携失敗**: 500エラー or 400エラー（ネットワーク不良の場合はリトライ処理）

---

## 2. 決済サービス

> 必要に応じて導入（追加コストが懸念される場合は後回し推奨）

### 2.1 APIエンドポイント

- 推奨：**Stripe** (従量課金・SDK充実)、**Square** (シンプル)、**Instamojo** (インド向け)
- 例：Stripeの場合 → `api.stripe.com/v1/...`

### 2.2 Webhook

- 決済完了/失敗イベントを受け取るWebhookエンドポイントを `/api/payment/webhook` などで用意
- **署名検証**（Stripeの `Stripe-Signature` ヘッダ等）
- イベント例：`payment_intent.succeeded` / `payment_intent.failed`

### 2.3 リトライ方針

- Stripeの **Smart Retries** に任せる
- アプリで二重課金を防ぐべき → **idempotency key** を使い、重複支払いを回避

---

## 3. メール配信

### 3.1 送信タイミング

1. **トランザクションメール**（パスワードリセット、注文確認など）
   - 即時送信（イベント駆動）
2. **バルクメール**（ニュースレターなど）
   - 定期 or 手動バッチ実行

### 3.2 テンプレート管理

- **SendGrid**, **Mailgun**, **MailerSend** など
- **Handlebars**や**各社独自テンプレ**で件名・本文を動的に生成
- 無料プラン制限：例）SendGrid 100通/日、Mailgun 100通/日 など

### 3.3 大量送信時の制限

- 超過すると送信失敗やレートリミット → キューイング機構が必要
- 有料プラン or 日単位のスケジューリング

---

## 4. その他外部API

### 4.1 地図API

- **Google Maps API**: 機能豊富だが無料枠制限がある
- **OpenStreetMap + Leaflet**: 無料、オープンソース
- **Mapbox**: 無料枠あり、デザイン性高い

### 4.2 レコメンドエンジン

- **Recombee**, **Algolia Recommend**: 30日無料トライアルなど
- **オープンソース**: Apache Mahout, Surprise など(導入難度高い)

### 4.3 エラー対応

- 各APIのレスポンスコードに従い**適切にハンドリング**。
- ネットワークエラー時は基本的に**リトライ** or ユーザーに再試行を促すメッセージ。

---

## 5. Mastra.aiとの連携 (将来的なAIエージェント連携)

### 5.1 複数段階要約への活用

- 例）決済履歴やメール配信統計などを**Mastra.ai** APIに送信
- `overview → heading → detail` のステップ要約を Mastra.ai のワークフローとして定義
- 返却された要約を DB に保存し、ユーザーに表示

### 5.2 エージェント機能

- **Mastra.ai**のツール呼び出しを利用して：
  - 決済API（Stripe等）のステータス照会
  - メールサービスの配信統計取得
  - SNS認証ログの異常検出
- **Google/AWS**等のLLMや**Anthropic**にもルーティング可能（Vercel AI SDKとの組合せ）

---

## 6. エラー・共通方針

1. **HTTPステータス**
   - 2xx: 成功
   - 4xx: クライアントエラー（認証失敗、パラメータ不正など）
   - 5xx: サーバーまたは外部APIエラー
2. **共通レスポンス形式**
   ```json
   {
     "error": {
       "code": "E4xx",
       "message": "Error details",
       "details": {}
     }
   }
   ```
   - code: 任意の文字列 (E4001 など)
   - message: ユーザー向けメッセージ
   - details: 追加情報（省略可）

3. **リトライ戦略**
   - ネットワーク不良時には数回まで再試行
   - レートリミット超過などは**バックオフ**して再試行

4. **セキュリティ**
   - OAuthトークン、APIキーは暗号化
   - Webhook署名検証
   - CSRFトークンの使用 (認証付きページ)

---

## 7. まとめと今後のステップ

- **SNS認証（Google OAuth）**は最初に導入 → 必要に応じてGitHubや他SNSを追加
- **決済サービス**はStripe等を想定し、Webhookでステータス同期 → MVP段階では不要なら保留
- **メール配信**はSendGrid/Mailgun等を使い、トランザクションメールを即時送信 → ニュースレターはキューやレート注意
- **その他API**（地図、レコメンド）はプロジェクト特性に合わせて選択 → 後で追加が容易になるようAPI設計を拡張性高く
- **Mastra.ai**とのエージェント連携は後期フェーズ → 要約(overview→heading→detail)や外部API統合に応用可能

以上の方針で、外部サービス連携を**低コストかつ短期間**で実装しつつ、**将来的な機能追加**（複数サービス/OAuth, 決済, メール拡張, Mastra.aiエージェントなど）にも柔軟に対応できる構成を目指す。